<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android第三方框架,">










<meta name="description" content="[TOC] Android OkHttp3源码分析介绍OKHttp优点  支持HTTP2/SPDY（SPDY是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。） socket自动选择最好路线，并支持自动重连，拥有自动维护的socket连接池，减少握手次数，减少了请求延迟，共享Socket,减少对服务器的请求次数。 基于Headers的缓存">
<meta name="keywords" content="Android第三方框架">
<meta property="og:type" content="article">
<meta property="og:title" content="Android OkHttp3源码分析">
<meta property="og:url" content="http://yoursite.com/2019/06/03/Android OkHttp3源码分析/index.html">
<meta property="og:site_name" content="PHS1024">
<meta property="og:description" content="[TOC] Android OkHttp3源码分析介绍OKHttp优点  支持HTTP2/SPDY（SPDY是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。） socket自动选择最好路线，并支持自动重连，拥有自动维护的socket连接池，减少握手次数，减少了请求延迟，共享Socket,减少对服务器的请求次数。 基于Headers的缓存">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4061843-d7902f55efac6d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://dl.iteye.com/upload/attachment/0069/3451/412b4451-2738-3ebc-b1f6-a0cc13b9697b.jpg">
<meta property="og:image" content="http://dl.iteye.com/upload/attachment/0069/3492/bddb00b6-a3e1-3112-a4f4-4b3cb8687c70.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190604104031300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190604104031300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdn.net/20160828174519845">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190605100153475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2020-02-07T07:37:40.276Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android OkHttp3源码分析">
<meta name="twitter:description" content="[TOC] Android OkHttp3源码分析介绍OKHttp优点  支持HTTP2/SPDY（SPDY是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。） socket自动选择最好路线，并支持自动重连，拥有自动维护的socket连接池，减少握手次数，减少了请求延迟，共享Socket,减少对服务器的请求次数。 基于Headers的缓存">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/4061843-d7902f55efac6d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/03/Android OkHttp3源码分析/">





  <title>Android OkHttp3源码分析 | PHS1024</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PHS1024</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">PHS1024</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/03/Android OkHttp3源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="PHS1024">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/24489804?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PHS1024">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android OkHttp3源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-03T21:16:50+08:00">
                2019-06-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-02-07T15:37:40+08:00">
                2020-02-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <meta name="referrer" content="no-referrer">



<p>[TOC]</p>
<h1 id="Android-OkHttp3源码分析"><a href="#Android-OkHttp3源码分析" class="headerlink" title="Android OkHttp3源码分析"></a>Android OkHttp3源码分析</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>OKHttp优点</p>
<ol>
<li>支持HTTP2/SPDY（SPDY是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。）</li>
<li>socket自动选择最好路线，并支持自动重连，拥有自动维护的socket连接池，减少握手次数，减少了请求延迟，共享Socket,减少对服务器的请求次数。</li>
<li>基于Headers的缓存策略减少重复的网络请求。</li>
<li>拥有Interceptors轻松处理请求与响应（自动处理GZip压缩）。</li>
</ol>
<p>OKHttp的功能</p>
<ol>
<li>PUT，DELETE，POST，GET等请求</li>
<li>文件的上传下载</li>
<li>加载图片(内部会图片大小自动压缩)</li>
<li>支持请求回调，直接返回对象、对象集合</li>
<li>支持session的保持</li>
</ol>
<p><strong>一些类介绍</strong>：</p>
<ul>
<li><p>OkHttpClient：</p>
<p>  OkHttp框架的客户端，是一个用户面板；通过它对OkHttp进行各种设置，网络请求都是通过OkHttpClient完成的，每个OkHttpClient内部都维护了自己的任务队列、连接池、Cache、拦截器等</p>
</li>
<li><p>Call：</p>
<p>  描述一个实际的访问请求，用户的每一个网络请求都是一个Call实例；实际实现是RealCall和AsyncCall</p>
</li>
<li><p>Dispatcher：</p>
<p>  任务调度器，维护了一个线程池，维护了三个双端队列，一个用于同步请求，两个用于异步请求</p>
</li>
<li><p>ExchangeCodec：</p>
<p>  协议层，分别支持HTTP1.1和HTTP2.0，对HTTP请求编码和响应解码</p>
</li>
<li><p>Exchange：</p>
<p>  传输单个HTTP请求和响应对，处理ExchangeCodec这个实际I/O</p>
</li>
<li><p>ExchangeFinder：</p>
<p>  Exchange辅助查找类</p>
</li>
<li><p>RealConnection：</p>
<p>  描述一个物理socket连接，连接池中维护多个RealConnection实例</p>
</li>
<li><p>RealConnectionPool：</p>
<p>  连接池，存储RealConnection连接</p>
</li>
<li><p>ConnectionPool：</p>
<p>  连接池，内部持有RealConnectionPool，通过它来及进行连接池的复用</p>
</li>
<li><p>StreamAllocation：</p>
<p>  由于Http/2支持多路复用，一个RealConnection可以支持多个网络访问请求，所以OkHttp又引入了StreamAllocation来描述一个实际的网络请求开销（从逻辑上一个Stream对应一个Call，但在实际网络请求过程中一个Call常常涉及到多次请求。如重定向，Authenticate等场景。所以准确地说，一个Stream对应一次请求，而一个Call对应一组有逻辑关联的Stream），一个RealConnection对应一个或多个StreamAllocation,所以StreamAllocation可以看做是RealConenction的计数器，当RealConnection的引用计数变为0，且长时间没有被其他请求重新占用就将被释放。</p>
</li>
<li><p>Request：</p>
<p>  请求对象，构造网络请求，包含头部这些</p>
</li>
<li><p>Response：</p>
<p>  响应对象，构造网络响应，包含头部这些</p>
</li>
<li><p>Transmitter：</p>
<p>  发射器，更准确的说是用来通知和调度网络请求的，作用在整个网络请求生命周期；OkHttp的应用程序和网络层之间的桥梁。此类公开高级应用程序层：连接，请求，响应和流；==也是用来计算RealConnection的连接引用，判定是否为空闲连接==</p>
</li>
<li><p>RealCall：</p>
<p>  默认实现的Call对象，同步也是通过它来进行</p>
</li>
<li><p>AsyncCall：</p>
<p>  异步请求对象，执行异步请求</p>
</li>
<li><p>RealInterceptorChain：</p>
<p>  拦截器链对象，操作整个链式，每一次调用一个拦截器</p>
</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">              .addInterceptor(<span class="keyword">new</span> Interceptor() &#123;&#125;)</span><br><span class="line">              .addNetworkInterceptor(<span class="keyword">new</span> Interceptor() &#123;&#125;)</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">              .url(<span class="string">"http://"</span>)</span><br><span class="line">              .build();</span><br><span class="line">      okHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<p>一次简单的网络请求大致就这样了，接下来看看具体怎么来进行请求的吧</p>
<h3 id="OkHttpClient的创建"><a href="#OkHttpClient的创建" class="headerlink" title="OkHttpClient的创建"></a>OkHttpClient的创建</h3><p>首先我们通过Builder模式创建了OkHttpClient，最后发起网络请求的也是它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任务调度器，主要用于控制并发的请求，异步的时候就需要通过它来调度所有的网络请求</span></span><br><span class="line">    Dispatcher dispatcher;</span><br><span class="line">    <span class="comment">//代理类，用于一些代理设置，如Http、socks等</span></span><br><span class="line">    <span class="meta">@Nullable</span> Proxy proxy;</span><br><span class="line">    <span class="comment">//协议集合</span></span><br><span class="line">    List&lt;Protocol&gt; protocols;</span><br><span class="line">    <span class="comment">//连接的配置 如指定Http通过socket连接</span></span><br><span class="line">    List&lt;ConnectionSpec&gt; connectionSpecs;</span><br><span class="line">    <span class="comment">//拦截器集合，拦截器链</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//网络拦截器，针对网络请求的拦截器，比如经常用到了日志拦截器</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//事件监听器</span></span><br><span class="line">    EventListener.Factory eventListenerFactory;</span><br><span class="line">    <span class="comment">//代理选择器</span></span><br><span class="line">    ProxySelector proxySelector;</span><br><span class="line">    <span class="comment">//http cookis 持久化策略</span></span><br><span class="line">    CookieJar cookieJar;</span><br><span class="line">    <span class="comment">//缓存cache</span></span><br><span class="line">    <span class="meta">@Nullable</span> Cache cache;</span><br><span class="line">    <span class="comment">//OkHttp内部缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span> InternalCache internalCache;</span><br><span class="line">    <span class="comment">//socket工厂</span></span><br><span class="line">    SocketFactory socketFactory;</span><br><span class="line">    <span class="comment">//SSL socket工厂</span></span><br><span class="line">    <span class="meta">@Nullable</span> SSLSocketFactory sslSocketFactory;</span><br><span class="line">    <span class="comment">//证书链的清理类 CA证书</span></span><br><span class="line">    <span class="meta">@Nullable</span> CertificateChainCleaner certificateChainCleaner;</span><br><span class="line">    <span class="comment">//对host基本接口的验证</span></span><br><span class="line">    HostnameVerifier hostnameVerifier;</span><br><span class="line">    <span class="comment">//约束的信任证书</span></span><br><span class="line">    CertificatePinner certificatePinner;</span><br><span class="line">    <span class="comment">//代理认证</span></span><br><span class="line">    Authenticator proxyAuthenticator;</span><br><span class="line">    Authenticator authenticator;</span><br><span class="line">    <span class="comment">//连接池 复用连接</span></span><br><span class="line">    ConnectionPool connectionPool;</span><br><span class="line">    <span class="comment">//DNS解析</span></span><br><span class="line">    Dns dns;</span><br><span class="line">    <span class="comment">//SSL重定向</span></span><br><span class="line">    <span class="keyword">boolean</span> followSslRedirects;</span><br><span class="line">    <span class="comment">//重定向</span></span><br><span class="line">    <span class="keyword">boolean</span> followRedirects;</span><br><span class="line">    <span class="comment">//是否失败自动重连</span></span><br><span class="line">    <span class="keyword">boolean</span> retryOnConnectionFailure;</span><br><span class="line">    <span class="comment">//完整调用请求超时时间</span></span><br><span class="line">    <span class="keyword">int</span> callTimeout;</span><br><span class="line">    <span class="comment">//连接超时时间</span></span><br><span class="line">    <span class="keyword">int</span> connectTimeout;</span><br><span class="line">    <span class="comment">//读取数据超时时间</span></span><br><span class="line">    <span class="keyword">int</span> readTimeout;</span><br><span class="line">    <span class="comment">//发送数据超时时间</span></span><br><span class="line">    <span class="keyword">int</span> writeTimeout;</span><br><span class="line">    <span class="comment">//时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> pingInterval;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">      	protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">      	connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">      	eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">      	proxySelector = ProxySelector.getDefault();</span><br><span class="line">      	<span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">      	&#125;</span><br><span class="line">      	cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">      	socketFactory = SocketFactory.getDefault();</span><br><span class="line">      	hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">      	certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">      	proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">      	authenticator = Authenticator.NONE;</span><br><span class="line">      	connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">      	dns = Dns.SYSTEM;</span><br><span class="line">      	followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">      	followRedirects = <span class="keyword">true</span>;</span><br><span class="line">      	retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">      	callTimeout = <span class="number">0</span>;</span><br><span class="line">      	connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">      	readTimeout = <span class="number">10_000</span>;</span><br><span class="line">      	writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">      	pingInterval = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Builder(OkHttpClient okHttpClient) &#123;</span><br><span class="line">      	<span class="keyword">this</span>.dispatcher = okHttpClient.dispatcher;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder的成员属性注释在代码中了，OkHttpClient基本上跟Builder是对应的；接着在Builder创建的时候，会将这些参数设置一个默认值；还可以通过OkHttpClient来再创建一个</p>
<ul>
<li>dispatcher：创建一个Dispatcher，后面看同步、异步的时候会看到</li>
<li>protocols：默认使用HTTP_1_1（http/1.1）和HTTP_2（http/2）两种HTTP协议</li>
<li>connectionSpecs：默认连接规格——MODERN_TLS（现代TLS）和CLEARTEXT（明文）</li>
<li>eventListenerFactory ：默认是一个空实现</li>
<li>proxySelector：默认是系统代理，如果是null则设置为没有代理（NullProxySelector）</li>
<li>cookieJar：默认没有cookis（空实现）</li>
<li>socketFactory：DCL返回的默认socketFactory（DefaultSocketFactory），原始的Java Socket</li>
<li>hostnameVerifier：默认OkHostnameVerifier</li>
<li>certificatePinner：默认CertificatePinner</li>
<li>proxyAuthenticator：默认没有代理认证</li>
<li>authenticator：默认没有</li>
<li>connectionPool：创建连接复用池</li>
<li>dns：默认使用系统的DNS</li>
<li>followSslRedirects：true表示遵循SSL重定向</li>
<li>followRedirects：true表示开启普通重定向</li>
<li>retryOnConnectionFailure：true表示默认开启连接失败后自动重连</li>
<li>callTimeout ：默认请求超时0</li>
<li>connectTimeout：默认连接超时时间10_000</li>
<li>readTimeout：默认读取超时时间10_000</li>
<li>writeTimeout：默认发送超时时间10_000</li>
<li>pingInterval：默认时间间隔0</li>
</ul>
<p>然后就是通过Builder模式的API我们可以自定义这些设置，下面我们随便看几个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">callTimeout</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">	callTimeout = checkDuration(<span class="string">"timeout"</span>, timeout, unit);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interceptor == null"</span>);</span><br><span class="line">      	interceptors.add(interceptor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addNetworkInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interceptor == null"</span>);</span><br><span class="line">		networkInterceptors.add(interceptor);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>超时时间检验后就直接赋值，拦截器也是直接添加到对应的拦截器集合中，没啥特殊的</p>
<p>接着看Builder的build方法，创建OkHttpClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OkHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是new了OkHttpClient，将Builder作为参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dispatcher = builder.dispatcher;</span><br><span class="line">    <span class="keyword">this</span>.proxy = builder.proxy;</span><br><span class="line">    <span class="keyword">this</span>.protocols = builder.protocols;</span><br><span class="line">    <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</span><br><span class="line">    <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);</span><br><span class="line">    <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);</span><br><span class="line">    <span class="keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;</span><br><span class="line">    <span class="keyword">this</span>.proxySelector = builder.proxySelector;</span><br><span class="line">    <span class="keyword">this</span>.cookieJar = builder.cookieJar;</span><br><span class="line">    <span class="keyword">this</span>.cache = builder.cache;</span><br><span class="line">    <span class="keyword">this</span>.internalCache = builder.internalCache;</span><br><span class="line">    <span class="keyword">this</span>.socketFactory = builder.socketFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isTLS = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;</span><br><span class="line">      	isTLS = isTLS || spec.isTls();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (builder.sslSocketFactory != <span class="keyword">null</span> || !isTLS) &#123;</span><br><span class="line">      	<span class="keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;</span><br><span class="line">      	<span class="keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	X509TrustManager trustManager = Util.platformTrustManager();</span><br><span class="line">      	<span class="keyword">this</span>.sslSocketFactory = newSslSocketFactory(trustManager);</span><br><span class="line">      	<span class="keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sslSocketFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	Platform.get().configureSslSocketFactory(sslSocketFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;</span><br><span class="line">    <span class="keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</span><br><span class="line">        certificateChainCleaner);</span><br><span class="line">    <span class="keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;</span><br><span class="line">    <span class="keyword">this</span>.authenticator = builder.authenticator;</span><br><span class="line">    <span class="keyword">this</span>.connectionPool = builder.connectionPool;</span><br><span class="line">    <span class="keyword">this</span>.dns = builder.dns;</span><br><span class="line">    <span class="keyword">this</span>.followSslRedirects = builder.followSslRedirects;</span><br><span class="line">    <span class="keyword">this</span>.followRedirects = builder.followRedirects;</span><br><span class="line">    <span class="keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;</span><br><span class="line">    <span class="keyword">this</span>.callTimeout = builder.callTimeout;</span><br><span class="line">    <span class="keyword">this</span>.connectTimeout = builder.connectTimeout;</span><br><span class="line">    <span class="keyword">this</span>.readTimeout = builder.readTimeout;</span><br><span class="line">    <span class="keyword">this</span>.writeTimeout = builder.writeTimeout;</span><br><span class="line">    <span class="keyword">this</span>.pingInterval = builder.pingInterval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interceptors.contains(<span class="keyword">null</span>)) &#123;</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Null interceptor: "</span> + interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (networkInterceptors.contains(<span class="keyword">null</span>)) &#123;</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Null network interceptor: "</span> + networkInterceptors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在OkHttpClient的构造函数中，就是一个简单的赋值和检验</p>
<p>需要注意的是，如果在Builder中没有配置sslSocketFactory和certificateChainCleaner，那么它们就是null，在OkHttpClient的构造函数中，会进行null判断，为null的时候会通过X509TrustManager去创建对应的默认值</p>
<p>interceptors和networkInterceptors中是不能包含null的，否则会抛出异常</p>
<p>至此，配置好各种参数，一个OkHttpClient就创建完成了</p>
<h3 id="Request的创建"><a href="#Request的创建" class="headerlink" title="Request的创建"></a>Request的创建</h3><p>接着网络请求第二步，创建我们的请求Request，同样是通过Builder模式来创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="meta">@Nullable</span> HttpUrl url;</span><br><span class="line">    <span class="comment">//请求方法</span></span><br><span class="line">    String method;</span><br><span class="line">    <span class="comment">//请求头 Builder</span></span><br><span class="line">    Headers.Builder headers;</span><br><span class="line">    <span class="comment">//请求body</span></span><br><span class="line">    <span class="meta">@Nullable</span> RequestBody body;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Object&gt; tags = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">this</span>.method = <span class="string">"GET"</span>;</span><br><span class="line">      	<span class="keyword">this</span>.headers = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Builder(Request request) &#123;</span><br><span class="line">      	<span class="keyword">this</span>.url = request.url;</span><br><span class="line">      	<span class="keyword">this</span>.method = request.method;</span><br><span class="line">      	<span class="keyword">this</span>.body = request.body;</span><br><span class="line">      	<span class="keyword">this</span>.tags = request.tags.isEmpty()</span><br><span class="line">          	? Collections.emptyMap()</span><br><span class="line">          	: <span class="keyword">new</span> LinkedHashMap&lt;&gt;(request.tags);</span><br><span class="line">      	<span class="keyword">this</span>.headers = request.headers.newBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Request的Builder就很简单，不像OkHttpClient那么多参数了；默认请求方法method是GEt方法，请求头headers也是直接new的；接着看一下Builder中的API吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">url</span><span class="params">(HttpUrl url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"url == null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">url</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"url == null"</span>);</span><br><span class="line">    <span class="comment">// Silently replace web socket URLs with HTTP URLs.</span></span><br><span class="line">    <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"ws:"</span>, <span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">        url = <span class="string">"http:"</span> + url.substring(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"wss:"</span>, <span class="number">0</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        url = <span class="string">"https:"</span> + url.substring(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url(HttpUrl.get(url));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addHeader</span><span class="params">(String name, String value)</span> </span>&#123;</span><br><span class="line">    headers.add(name, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>先看一下请求头的设置吧，其实很简单，就是通过Headers的Builder去设置</p>
<p>重点看一下URL的设置吧，通常我们的URL是一个String，那么在Request中确实HttpUrl，那就说明需要进行转换</p>
<p>首先针对web socket的URL和HTTP的URL做了一个替换，接着通过<code>HttpUrl.get()</code>方法转为HttpUrl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpUrl <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder().parse(<span class="keyword">null</span>, url).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过HttpUrl的Builder进行构造HttpUrl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Builder <span class="title">parse</span><span class="params">(@Nullable HttpUrl base, String input)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pos = skipLeadingAsciiWhitespace(input, <span class="number">0</span>, input.length());</span><br><span class="line">    <span class="keyword">int</span> limit = skipTrailingAsciiWhitespace(input, pos, input.length());</span><br><span class="line">    <span class="comment">// Scheme.</span></span><br><span class="line">    <span class="keyword">int</span> schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);</span><br><span class="line">    <span class="keyword">if</span> (schemeDelimiterOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input.regionMatches(<span class="keyword">true</span>, pos, <span class="string">"https:"</span>, <span class="number">0</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">          	<span class="keyword">this</span>.scheme = <span class="string">"https"</span>;</span><br><span class="line">          	pos += <span class="string">"https:"</span>.length();</span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.regionMatches(<span class="keyword">true</span>, pos, <span class="string">"http:"</span>, <span class="number">0</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">          	<span class="keyword">this</span>.scheme = <span class="string">"http"</span>;</span><br><span class="line">          	pos += <span class="string">"http:"</span>.length();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Expected URL scheme 'http' or 'https' but was '"</span></span><br><span class="line">              + input.substring(<span class="number">0</span>, schemeDelimiterOffset) + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scheme = base.scheme;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"Expected URL scheme 'http' or 'https' but no colon was found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// Authority.</span></span><br><span class="line">    <span class="keyword">boolean</span> hasUsername = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasPassword = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> slashCount = slashCount(input, pos, limit);</span><br><span class="line">    <span class="keyword">if</span> (slashCount &gt;= <span class="number">2</span> || base == <span class="keyword">null</span> || !base.scheme.equals(<span class="keyword">this</span>.scheme)) &#123;</span><br><span class="line">        pos += slashCount;</span><br><span class="line">        authority:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> componentDelimiterOffset = delimiterOffset(input, pos, limit, <span class="string">"@/\\?#"</span>);</span><br><span class="line">          	<span class="keyword">int</span> c = componentDelimiterOffset != limit</span><br><span class="line">              ? input.charAt(componentDelimiterOffset)</span><br><span class="line">              : -<span class="number">1</span>;</span><br><span class="line">          	<span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            	<span class="keyword">case</span> <span class="string">'@'</span>:</span><br><span class="line">              		<span class="comment">// User info precedes.</span></span><br><span class="line">              		<span class="keyword">if</span> (!hasPassword) &#123;</span><br><span class="line">                		<span class="keyword">int</span> passwordColonOffset = delimiterOffset(</span><br><span class="line">                    		input, pos, componentDelimiterOffset, <span class="string">':'</span>);</span><br><span class="line">                		String canonicalUsername = canonicalize(input, pos, passwordColonOffset, USERNAME_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                		<span class="keyword">this</span>.encodedUsername = hasUsername</span><br><span class="line">                    		? <span class="keyword">this</span>.encodedUsername + <span class="string">"%40"</span> + canonicalUsername : canonicalUsername;</span><br><span class="line">                		<span class="keyword">if</span> (passwordColonOffset != componentDelimiterOffset) &#123;</span><br><span class="line">                  			hasPassword = <span class="keyword">true</span>;</span><br><span class="line">                  			<span class="keyword">this</span>.encodedPassword = canonicalize(input, passwordColonOffset + <span class="number">1</span>, componentDelimiterOffset, PASSWORD_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                		&#125;</span><br><span class="line">                		hasUsername = <span class="keyword">true</span>;</span><br><span class="line">              		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                		<span class="keyword">this</span>.encodedPassword = <span class="keyword">this</span>.encodedPassword + <span class="string">"%40"</span> + canonicalize(input, pos,</span><br><span class="line">                    	componentDelimiterOffset, PASSWORD_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">              		&#125;</span><br><span class="line">                    pos = componentDelimiterOffset + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            	<span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">            	<span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">              		<span class="comment">// Host info precedes.</span></span><br><span class="line">              		<span class="keyword">int</span> portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);</span><br><span class="line">              		<span class="keyword">if</span> (portColonOffset + <span class="number">1</span> &lt; componentDelimiterOffset) &#123;</span><br><span class="line">                        host = canonicalizeHost(input, pos, portColonOffset);</span><br><span class="line">                        port = parsePort(input, portColonOffset + <span class="number">1</span>, componentDelimiterOffset);</span><br><span class="line">                        <span class="keyword">if</span> (port == -<span class="number">1</span>) &#123;</span><br><span class="line">                          	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid URL port: \""</span></span><br><span class="line">                              + input.substring(portColonOffset + <span class="number">1</span>, componentDelimiterOffset) + <span class="string">'"'</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        host = canonicalizeHost(input, pos, portColonOffset);</span><br><span class="line">                        port = defaultPort(scheme);</span><br><span class="line">                  	&#125;</span><br><span class="line">              		<span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            INVALID_HOST + <span class="string">": \""</span> + input.substring(pos, portColonOffset) + <span class="string">'"'</span>);</span><br><span class="line">              		&#125;</span><br><span class="line">                  	pos = componentDelimiterOffset;</span><br><span class="line">                  	<span class="keyword">break</span> authority;</span><br><span class="line">          	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is a relative link. Copy over all authority components. Also maybe the path &amp; query.</span></span><br><span class="line">        <span class="keyword">this</span>.encodedUsername = base.encodedUsername();</span><br><span class="line">        <span class="keyword">this</span>.encodedPassword = base.encodedPassword();</span><br><span class="line">        <span class="keyword">this</span>.host = base.host;</span><br><span class="line">        <span class="keyword">this</span>.port = base.port;</span><br><span class="line">        <span class="keyword">this</span>.encodedPathSegments.clear();</span><br><span class="line">        <span class="keyword">this</span>.encodedPathSegments.addAll(base.encodedPathSegments());</span><br><span class="line">        <span class="keyword">if</span> (pos == limit || input.charAt(pos) == <span class="string">'#'</span>) &#123;</span><br><span class="line">          	encodedQuery(base.encodedQuery());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Resolve the relative path.</span></span><br><span class="line">    <span class="keyword">int</span> pathDelimiterOffset = delimiterOffset(input, pos, limit, <span class="string">"?#"</span>);</span><br><span class="line">    resolvePath(input, pos, pathDelimiterOffset);</span><br><span class="line">    pos = pathDelimiterOffset;</span><br><span class="line">    <span class="comment">// Query.</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; limit &amp;&amp; input.charAt(pos) == <span class="string">'?'</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> queryDelimiterOffset = delimiterOffset(input, pos, limit, <span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">this</span>.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(</span><br><span class="line">            input, pos + <span class="number">1</span>, queryDelimiterOffset, QUERY_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">        pos = queryDelimiterOffset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fragment.</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; limit &amp;&amp; input.charAt(pos) == <span class="string">'#'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.encodedFragment = canonicalize(</span><br><span class="line">            input, pos + <span class="number">1</span>, limit, FRAGMENT_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是对String进行解析了，通过字符匹配，最后得到对应的HttpUrl需要的参数，最后通过HttpUrl的Builder的build方法，创建了HttpUrl</p>
<p>这样，Request中的url就得到了</p>
<p>先看一下HTTP请求报文结构</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4061843-d7902f55efac6d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP报文结构"></p>
<p>再看一下网上找的HTTP请求报文图吧</p>
<p><img src="http://dl.iteye.com/upload/attachment/0069/3451/412b4451-2738-3ebc-b1f6-a0cc13b9697b.jpg" alt="HTTP请求报文"></p>
<p><img src="http://dl.iteye.com/upload/attachment/0069/3492/bddb00b6-a3e1-3112-a4f4-4b3cb8687c70.jpg" alt="HTTP相应报文"></p>
<h3 id="得到Call对象newCall"><a href="#得到Call对象newCall" class="headerlink" title="得到Call对象newCall"></a>得到Call对象newCall</h3><p>接着第三步，通过OkHttpClient的newCall方法得到一个Call对象，然后通过enqueue方法进行网络请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用newCall方法，默认返回了RealCall对象，进行网络请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.transmitter = <span class="keyword">new</span> Transmitter(client, call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建RealCall的时候，需要有OkHttpClient、Request，还有一个布尔值forWebSocket，标识是否为Web Sokcet，从前面知道，默认是false</p>
<p>然后直接创建了RealCall对象，同时也创建了Transmitter（发射机，OkHttp的应用程序和网络层之间的桥梁）</p>
<p>在后面的分析前先看看这个Transmitter，这个贯穿了整个网络请求，每一个RealCall都对应着一个Transmitter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//OkHttpClient</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">    <span class="comment">//连接池 RealConnectionPool</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> RealConnectionPool connectionPool;</span><br><span class="line">  	<span class="comment">//Call对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Call call;</span><br><span class="line">  	<span class="comment">//事件监听</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener eventListener;</span><br><span class="line">  	<span class="comment">//异步超时计时器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AsyncTimeout timeout = <span class="keyword">new</span> AsyncTimeout() &#123;</span><br><span class="line">    	<span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">timedOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      		cancel();</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;;</span><br><span class="line">	<span class="comment">//call的堆栈</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="meta">@Nullable</span> Object callStackTrace;</span><br><span class="line">	<span class="comment">//请求Request</span></span><br><span class="line">  	<span class="keyword">private</span> Request request;</span><br><span class="line">  	<span class="comment">//Exchange的辅助查找类</span></span><br><span class="line">    <span class="keyword">private</span> ExchangeFinder exchangeFinder;</span><br><span class="line">  	<span class="comment">//连接</span></span><br><span class="line">  	<span class="keyword">public</span> RealConnection connection;</span><br><span class="line">    <span class="comment">//Exchange，传输单个HTTP请求和响应对。在处理实际的I/O的 ExchangeCodec上的这层连接管理和事件</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="meta">@Nullable</span> Exchange exchange;</span><br><span class="line">    <span class="comment">//请求结束</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> exchangeRequestDone;</span><br><span class="line">  	<span class="comment">//响应结束</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> exchangeResponseDone;</span><br><span class="line">    <span class="comment">//是否取消</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line">  	<span class="comment">//超时退出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> timeoutEarlyExit;</span><br><span class="line">  	<span class="comment">//没有更多的Exchange</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> noMoreExchanges;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">Transmitter</span><span class="params">(OkHttpClient client, Call call)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.client = client;</span><br><span class="line">    	<span class="keyword">this</span>.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());</span><br><span class="line">    	<span class="keyword">this</span>.call = call;</span><br><span class="line">    	<span class="keyword">this</span>.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    	<span class="keyword">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class="line">  	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Transmitter的构造方法中，得到了OkHttpClient、ConnectionPool、Call等参数，从后面网络请求可以知道，Transmitter维持着整个网络请求的进行和消息通知</p>
<h3 id="同步请求execute"><a href="#同步请求execute" class="headerlink" title="同步请求execute"></a>同步请求execute</h3><p>如果是同步请求，就是调用execute方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">      		executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//添加到同步队列</span></span><br><span class="line">      	client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">      	<span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>executed</code>表示对应的<code>call</code>是否已经执行, 这里同步锁可以避免了竞态条件的出现, 可以看出一个<code>call</code>实例只能被执行一次, 是一个”消耗品”；通过Transmitter来通知和通信，然后这个方法主要做了两件事：一是通过OkHttpClient的dispatcher来进行分发（其实是添加到同步队列，交由Dispatcher分发），二是通过拦截器链进行请求并得到结果</p>
<ul>
<li><p>添加到Dispatcher的同步队列</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在Dispatcher中的executed方法，直接调用runningSyncCalls，将RealCall添加进去，runningSyncCalls是一个双端队列，里面保存了每一个同步请求的RealCall对象</p>
<p>  也就是说，RealCall默认的是一个同步请求的Call</p>
<p>  execute就是将RealCall添加到Dispatcher的双端队列中，等待执行（其实Dispatcher维护了一个线程池，会在这里调度所有的网络请求，后面讲咯）</p>
</li>
<li><p>在看通过拦截器链之前，先看看请求结束后做了什么，不然后面篇幅过长容易忘</p>
<p>  调用dispatcher的finished方法</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  Dispatcher中有重载的finished方法，不过我们这里自然就是RealCall这个了</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      	idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上锁的形式，从runningSyncCalls中移除了RealCall</p>
<p>  至于后面的isRunning是对异步的一些操作和一些准备工作，后面异步请求再说</p>
</li>
<li><p>通过拦截器链：<code>getResponseWithInterceptorChain()</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//自定义拦截器</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//失败重连或重定向拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    <span class="comment">//请求和响应的转换拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//缓存拦截器 从缓存中请求并将响应写入缓存</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//建立连接拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        <span class="comment">//自定义的network拦截器</span></span><br><span class="line">      	interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个拦截器，处理网络调用服务器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">	<span class="comment">//责任链的包装，去调用拦截器</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	Response response = chain.proceed(originalRequest);</span><br><span class="line">      	<span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">        	closeQuietly(response);</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      	calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">      	<span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        	transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  首先就是添加拦截器，把所有的拦截器都添加到一个集合，自定义的拦截器在前，再加上RetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、CallServerInterceptor等几个，然后通过RealInterceptorChain开始第一个拦截器的调用</p>
<p>  response是通过<code>chain.proceed(originalRequest)</code>得到，chain就是RealInterceptorChain，跟进去看一下</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    <span class="comment">//一些检查</span></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">//请求下一个责任链</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">    <span class="comment">//获取当前的拦截器</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">//执行, 返回响应</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">	<span class="comment">//后面是一些检查</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  首先就是重载了一次proceed方法，然后还是通过包装RealInterceptorChain，来尽心下一个拦截器的使用，可以注意到这里的index+1，也就是说最后是遍历完整个interceptors集合的，然后就是取出拦截器，通过intercept方法对response进行拦截过滤（这里就留着后面看拦截器的时候再看）</p>
<p>  整个拦截器链的调用大致如下</p>
<p>  <img src="https://img-blog.csdnimg.cn/20190604104031300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="拦截器链"></p>
</li>
</ul>
<h3 id="异步请求enqueue"><a href="#异步请求enqueue" class="headerlink" title="异步请求enqueue"></a>异步请求enqueue</h3><p>后面就是执行Call的enqueue方法，那么默认就是RealCall的enqueue方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样交给Dispatcher一个Call，异步就是AsyncCall</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">        <span class="comment">// the same host.</span></span><br><span class="line">        <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">        	AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">        	<span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将AsyncCall添加到readyAsyncCalls中，readyAsyncCalls也是一个双端队列，这是一个准备执行状态的请求队列，同时还有一个runningAsyncCalls，就是正在执行状态的请求队列</p>
<p>然后调用<code>promoteAndExecute()</code>进行调度，将符合条件的从准备状态队列添加到正在执行队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      	<span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        	AsyncCall asyncCall = i.next();</span><br><span class="line">			<span class="comment">//判断当前异步请求数是否小于最大请求数 以及 同主机的请求数是否小于每个主机的最大请求数</span></span><br><span class="line">        	<span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">        	<span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">        	i.remove();</span><br><span class="line">            asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">            executableCalls.add(asyncCall);</span><br><span class="line">            runningAsyncCalls.add(asyncCall);</span><br><span class="line">      	&#125;</span><br><span class="line">      	isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">      	AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">      	asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历readyAsyncCalls，如果runningAsyncCalls到达最大连接数（maxRequests默认最大64）跳出循环，如果请求主机数达到最大（maxRequestsPerHost默认为5），则将readyAsyncCalls中的请求取出添加到runningAsyncCalls和executableCalls中</p>
<p>然后遍历executableCalls可执行的Call，调用<code>asyncCall.executeOn(executorService())</code>，其中<code>executorService()</code>方法就是准备线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          	<span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>executorService就是一个线程池，保活是60s，采用SynchronousQueue</p>
<p>接着回到之前看看AsyncCall的executeOn方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">"executor rejected"</span>);</span><br><span class="line">        ioException.initCause(e);</span><br><span class="line">        transmitter.noMoreExchanges(ioException);</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里主要就是通过executorService线程池来执行当前的AsyncCall请求</p>
<p>AsyncCall继承自NamedRunnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String oldName = Thread.currentThread().getName();</span><br><span class="line">        Thread.currentThread().setName(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	execute();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          	Thread.currentThread().setName(oldName);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NamedRunnable实现了Runnable，重写了run方法，在run方法中，调用了抽象方法<code>execute()</code>，具体实现就是我们的AsyncCall，所以线程池执行的代码就是AsyncCall的execute方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">          	<span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">          	Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要的就是通过<code>getResponseWithInterceptorChain()</code>获取Response，这个就跟前面同步请求一样了，通过责任链的方式去调用所有的拦截器，得到response，然后回调</p>
<p>结束后，调用dispatcher的finished方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    call.callsPerHost().decrementAndGet();</span><br><span class="line">    finished(runningAsyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      	idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从runningAsyncCalls移除这个AsyncCall，再次通过<code>promoteAndExecute()</code>来判断调度当前异步请求数是否超过最大请求, 如果没有, 则会从异步请求等待队列中获取出来再进行请求执行</p>
<h3 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h3><p>整个拦截器调用大致如下，下面我就只分析默认的情况下的拦截器链</p>
<p><img src="https://img-blog.csdnimg.cn/20190604104031300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="拦截器链"></p>
<h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><p>通过死循环实现重连，在连接失败后进行重新连接，必要时进行重定向，如果调用被取消，可能会抛出IOException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取Request</span></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    <span class="comment">//拦截器链</span></span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    <span class="comment">//发射器 用于通信</span></span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//通知准备连接 初始化ExchangeFinder等</span></span><br><span class="line">      	transmitter.prepareToConnect(request);</span><br><span class="line">		<span class="comment">//是否取消 因为transmitter的存在，是可以随时取消，中断网络请求的</span></span><br><span class="line">      	<span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      	&#125;</span><br><span class="line"></span><br><span class="line">      	Response response;</span><br><span class="line">      	<span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      	<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过拦截器链，调用下一个拦截器</span></span><br><span class="line">        	response = realChain.proceed(request, transmitter, <span class="keyword">null</span>);</span><br><span class="line">        	success = <span class="keyword">true</span>;</span><br><span class="line">      	&#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        	...</span><br><span class="line">      	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        	...</span><br><span class="line">      	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	<span class="comment">//异常情况，通知释放资源</span></span><br><span class="line">        	<span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          		transmitter.exchangeDoneDueToException();</span><br><span class="line">        	&#125;</span><br><span class="line">      	&#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 如果前一个有Response，检测前一个Response</span></span><br><span class="line">      	<span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                        .body(<span class="keyword">null</span>)</span><br><span class="line">                        .build())</span><br><span class="line">                .build();</span><br><span class="line">      	&#125;</span><br><span class="line">		<span class="comment">//创建Exchange，传输单个HTTP请求和响应对。这层连接管理和事件</span></span><br><span class="line">      	Exchange exchange = Internal.instance.exchange(response);</span><br><span class="line">        <span class="comment">//连接用于到达抽象源服务器的具体路由。创建连接时，客户端有很多选项</span></span><br><span class="line">      	Route route = exchange != <span class="keyword">null</span> ? exchange.connection().route() : <span class="keyword">null</span>;</span><br><span class="line">      	Request followUp = followUpRequest(response, route);</span><br><span class="line">		<span class="comment">//followUp为null，表示不要重定向，释放资源并且返回response</span></span><br><span class="line">      	<span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; exchange.isDuplex()) &#123;</span><br><span class="line">          		transmitter.timeoutEarlyExit();</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">return</span> response;</span><br><span class="line">      	&#125;</span><br><span class="line">		<span class="comment">//如果是不可重复的请求体，抛出异常</span></span><br><span class="line">      	RequestBody followUpBody = followUp.body();</span><br><span class="line">      	<span class="keyword">if</span> (followUpBody != <span class="keyword">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        	<span class="keyword">return</span> response;</span><br><span class="line">      	&#125;</span><br><span class="line"></span><br><span class="line">      	closeQuietly(response.body());</span><br><span class="line">      	<span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">        	exchange.detachWithViolence();</span><br><span class="line">      	&#125;</span><br><span class="line">		<span class="comment">//最大重定向次数20</span></span><br><span class="line">      	<span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      	&#125;</span><br><span class="line">		<span class="comment">//赋值</span></span><br><span class="line">      	request = followUp;</span><br><span class="line">      	priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取到Request、RealInterceptorChain和Transmitter，都是从拦截器链中获取的</p>
<p>通过死循环</p>
<ul>
<li>针对请求Request，通过拦截器链RealInterceptorChain，调用下一个拦截器，出现异常，则通过Transmitter通知并停止该次请求，释放资源</li>
<li>针对响应Response，检查上次的Response，创建Exchange来传输单个HTTP请求和响应对，结合Route路由；接着就是检查是否需要重定向，是否达到最大重定向次数</li>
</ul>
<h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><p>构建访问网络的桥梁，首先，将用户请求转换成网络请求，然后访问网络，最后将网络响应转换成用户响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    <span class="comment">//通过Builder复制一个Request</span></span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">	<span class="comment">//将用户的Request构造成服务器的Request</span></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="comment">//请求体存在，进行转换</span></span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	MediaType contentType = body.contentType();</span><br><span class="line">        <span class="comment">//类型这些都很简单明了了</span></span><br><span class="line">      	<span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">      	<span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        	requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">        	requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">      	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">        	requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//Host主机</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//保持连接</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Gzip压缩</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">      	requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//设置Cookies</span></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      	requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//传入已构造好的服务器Request，调用下一个拦截器，获取服务器的networkResponse </span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">	<span class="comment">//后面是对Response的处理</span></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">        &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      	GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">        <span class="comment">//移除一些信息</span></span><br><span class="line">      	Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">              .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">              .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">              .build();</span><br><span class="line">      	responseBuilder.headers(strippedHeaders);</span><br><span class="line">      	String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">        <span class="comment">//响应体构造为RealResponseBody</span></span><br><span class="line">      	responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先将用户的Request（也就是我们自己构造的Request）复制一份，然后转换请求体，变成服务器需要的请求——主要是请求头的处理；然后通过拦截器链调用下一个拦截器</li>
<li>针对服务器返回的Response，进行处理和转换，转为用户Response</li>
</ul>
<h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><p>缓存拦截器，从缓存中获取服务器请求，或者把服务器响应写入缓存中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">	<span class="comment">//获取缓存策略</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">	<span class="comment">//从缓存中追踪Response</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果缓存不适用，则关闭</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果网络被禁止，且缓存为空，则返回失败</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">              .request(chain.request())</span><br><span class="line">              .protocol(Protocol.HTTP_1_1)</span><br><span class="line">              .code(<span class="number">504</span>)</span><br><span class="line">              .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">              .body(Util.EMPTY_RESPONSE)</span><br><span class="line">              .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">              .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不需要网络时，从缓存中获取</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">              .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">              .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用下一个拦截者，从网络获取Response</span></span><br><span class="line">      	networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">// 关闭body，防止内存泄露</span></span><br><span class="line">      	<span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	closeQuietly(cacheCandidate.body());</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果缓存中存在Response，同时检测networkResponse是否被修改</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line">            networkResponse.body().close(); </span><br><span class="line">            <span class="comment">//更新缓存中的数据至最新</span></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">      	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	closeQuietly(cacheResponse.body());</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//构建response </span></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line">	<span class="comment">//把之前未缓存的添加至缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">              	<span class="comment">// The cache cannot be written.</span></span><br><span class="line">            &#125;</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><p>打开一个连接，去连接目标服务器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line">    <span class="comment">//默认GET请求</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">//如果不是，则需要做转换</span></span><br><span class="line">    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line">	<span class="comment">//调用下一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Transmitter的newExchange去捕获新的Request和Response</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Exchange <span class="title">newExchange</span><span class="params">(Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//连接池</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (noMoreExchanges) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (exchange != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot make a new request because the previous response "</span></span><br><span class="line">            + <span class="string">"is still open: please call response.close()"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取ExchangeCodec对象，对HTTP请求编码和响应解码</span></span><br><span class="line">    ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">//构建转换后的结果，创建了Exchange对象</span></span><br><span class="line">    Exchange result = <span class="keyword">new</span> Exchange(<span class="keyword">this</span>, call, eventListener, exchangeFinder, codec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">this</span>.exchange = result;</span><br><span class="line">      <span class="keyword">this</span>.exchangeRequestDone = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">this</span>.exchangeResponseDone = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExchangeFinder是一个辅助查找Exchange类，看看<code>exchangeFinder.find(client, chain, doExtensiveHealthChecks)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeCodec <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//找到一个可用的健康的连接，如果没有健康安全的连接，则会一直查找直到有为止</span></span><br><span class="line">      	RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">        <span class="comment">//根据具体的resultConnection 创建ExchangeCodec</span></span><br><span class="line">      	<span class="keyword">return</span> resultConnection.newCodec(client, chain);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">      	trackFailure();</span><br><span class="line">      	<span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      	trackFailure();</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到Connection，RealConnection是整个协议部分，socket、握手等动作；</p>
<p>先看看如何通过<code>findHealthyConnection()</code>找到连接的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      	RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//如果是一个新连接，也需要检查</span></span><br><span class="line">      	<span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">          		<span class="keyword">return</span> candidate;</span><br><span class="line">        	&#125;</span><br><span class="line">      	&#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//检查，如果不是一个好连接，则从连接池中移除，继续查找</span></span><br><span class="line">      	<span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        	candidate.noNewExchanges();</span><br><span class="line">        	<span class="keyword">continue</span>;</span><br><span class="line">      	&#125;</span><br><span class="line"></span><br><span class="line">      	<span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过死循环，通过<code>findConnection()</code>查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line">    RealConnection result = <span class="keyword">null</span>;</span><br><span class="line">    Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">    RealConnection releasedConnection;</span><br><span class="line">    Socket toClose;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      	hasStreamFailure = <span class="keyword">false</span>; <span class="comment">// This is a fresh attempt.</span></span><br><span class="line"></span><br><span class="line">      	<span class="comment">//尝试用已经有了的连接，直接从Transmitter的引用拿去</span></span><br><span class="line">      	releasedConnection = transmitter.connection;</span><br><span class="line">        <span class="comment">//releaseConnectionNoEvents方法来判断这个连接是不是已经释放了</span></span><br><span class="line">      	toClose = transmitter.connection != <span class="keyword">null</span> &amp;&amp; transmitter.connection.noNewExchanges</span><br><span class="line">              ? transmitter.releaseConnectionNoEvents()</span><br><span class="line">              : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      	<span class="keyword">if</span> (transmitter.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果不为null，赋给result</span></span><br><span class="line">            result = transmitter.connection;</span><br><span class="line">            releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      	&#125;</span><br><span class="line"></span><br><span class="line">      	<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//为null，尝试从连接池中获取，并将RealConnection和Transmitter关联上，这个方法里如果找到了连接，会将该连接的transmitters（连接引用，Trnsmitter）进行+1</span></span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="keyword">null</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">              	foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">              	result = transmitter.connection;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//路由</span></span><br><span class="line">              	selectedRoute = nextRouteToTry;</span><br><span class="line">             	nextRouteToTry = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCurrentRoute()) &#123;</span><br><span class="line">              	selectedRoute = transmitter.connection.route();</span><br><span class="line">            &#125;</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭socket</span></span><br><span class="line">    closeQuietly(toClose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      	eventListener.connectionAcquired(call, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">//如果result不为null，说明直接从Transmitter中或者从连接池中找到了这个连接，返回</span></span><br><span class="line">      	<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否需要一个新的路由</span></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">      	newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">      	routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Route&gt; routes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">      	<span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">            <span class="comment">//重新设置路由后，再一次尝试从连接池获取这个连接</span></span><br><span class="line">            routes = routeSelection.getAll();</span><br><span class="line">            <span class="comment">//具体分析请看后面的连接池部分</span></span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">                address, transmitter, routes, <span class="keyword">false</span>)) &#123;</span><br><span class="line">              	foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">              	result = transmitter.connection;</span><br><span class="line">            &#125;</span><br><span class="line">      	&#125;</span><br><span class="line">		<span class="comment">//如果还是没有找到连接</span></span><br><span class="line">      	<span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">              	selectedRoute = routeSelection.next();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建一个新的连接</span></span><br><span class="line">            result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">            connectingConnection = result;</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果第二次从连接池中找到，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      	eventListener.connectionAcquired(call, result);</span><br><span class="line">      	<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时是一个新连接，需要进行connect，进行TCP和TLS握手</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br><span class="line">    <span class="comment">//更新连接池中的路由信息</span></span><br><span class="line">    connectionPool.routeDatabase.connected(result.route());</span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      	connectingConnection = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">//再次尝试从连接池中获取，避免多线程下重复添加</span></span><br><span class="line">      	<span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// We lost the race! Close the connection we created and return the pooled connection.</span></span><br><span class="line">            result.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">            socket = result.socket();</span><br><span class="line">            result = transmitter.connection;</span><br><span class="line">     	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新连接，存入连接池</span></span><br><span class="line">            connectionPool.put(result);</span><br><span class="line">            transmitter.acquireConnectionNoEvents(result);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找连接主要做了以下几件事：</p>
<ol>
<li>直接从Transmitter中获取这个连接，看是否能直接获取到；如果没有，进行2</li>
<li>第一次尝试从连接池中获取连接，将连接关联到对应的Transmitter中；如果没有，进行3</li>
<li>更新路由信息后，再一次从连接池中获取，关联到Transmitter中；如果没有，进行4</li>
<li>创建一个新的连接，进行TCP+TLS握手，连接，同时更新连接池中的路由信息</li>
<li>第三次从连接池中获取，是否有连接存在（这里我想主要是多线程同时创建了这个新连接）；如果没有，则将新连接放入到连接池中；然后返回</li>
</ol>
<p>然后我们还需要注意到其中的一个调用，109行<code>transmitter.acquireConnectionNoEvents(result);</code>这是将该Transmitter设置到连接中去，因为每一个连接中有一个引用计数，记的就是Transmitter引用（因为每一个Call是一个Transmitter，就是一次请求，但是可以复用同一个RealConnection）；这行代码主要是针对新连接的调用，那么针对从连接池或者直接从Transmitter获取的连接，也会调用<code>transmitter.acquireConnectionNoEvents(result);</code>这个方法，进行连接引用计数+1，只不过后面的两种是通过连接池去调用的这个方法，具体可以在连接池的<code>connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)</code>中看到，后面连接池有讲到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireConnectionNoEvents</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    connection.transmitters.add(<span class="keyword">new</span> TransmitterReference(<span class="keyword">this</span>, callStackTrace));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就是将这个连接的引用计数里面再加一次（因为又连接了一次），主要就是通过TransmitterReference的List</p>
<p>接着<code>resultConnection.newCodec(client, chain)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ExchangeCodec <span class="title">newCodec</span><span class="params">(OkHttpClient client, Interceptor.Chain chain)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (http2Connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">new</span> Http2ExchangeCodec(client, <span class="keyword">this</span>, chain, http2Connection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	socket.setSoTimeout(chain.readTimeoutMillis());</span><br><span class="line">      	source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);</span><br><span class="line">      	sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);</span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">new</span> Http1ExchangeCodec(client, <span class="keyword">this</span>, source, sink);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>根据connection，返回对应的ExchangeCodec（真正进行I/O流的地方），有HTTP2和HTTP1对应的两种</p>
<p>回到ConnectInterceptor的intercept方法，获取到新的Request和Response后，调用下一个拦截器</p>
<h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><p>拦截器链中的最后一个链点，通过网络请求服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Exchange exchange = realChain.exchange();</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">	<span class="comment">//写入请求头</span></span><br><span class="line">    exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//检测是否有body的请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果请求头是"100-continue"，等待服务器的响应</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">            exchange.flushRequest();</span><br><span class="line">            responseHeadersStarted = <span class="keyword">true</span>;</span><br><span class="line">            exchange.responseHeadersStart();</span><br><span class="line">            responseBuilder = exchange.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将请求体转换成sink，并封装在CountingSink 内部</span></span><br><span class="line">            <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">                <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">                exchange.flushRequest();</span><br><span class="line">              	BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                  	exchange.createRequestBody(request, <span class="keyword">true</span>));</span><br><span class="line">              	request.body().writeTo(bufferedRequestBody);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">              	BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                  	exchange.createRequestBody(request, <span class="keyword">false</span>));</span><br><span class="line">              	request.body().writeTo(bufferedRequestBody);</span><br><span class="line">              	bufferedRequestBody.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exchange.noRequestBody();</span><br><span class="line">            <span class="keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">              	exchange.noNewExchangesOnConnection();</span><br><span class="line">            &#125;</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	exchange.noRequestBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.body() == <span class="keyword">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">      	exchange.finishRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">      	exchange.responseHeadersStart();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//从httpCodec中获取响应头</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//构建response</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = response.code();</span><br><span class="line">    <span class="comment">//如果服务器返回的状态码是100，再次尝试读取具体的response</span></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      	response = exchange.readResponseHeaders(<span class="keyword">false</span>)</span><br><span class="line">              .request(request)</span><br><span class="line">              .handshake(exchange.connection().handshake())</span><br><span class="line">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      	code = response.code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response);</span><br><span class="line">	<span class="comment">//如果是WebSocket，并且返回状态码为101，表示响应body为空</span></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      	response = response.newBuilder()</span><br><span class="line">          	.body(Util.EMPTY_RESPONSE)</span><br><span class="line">          	.build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//读取body</span></span><br><span class="line">      	response = response.newBuilder()</span><br><span class="line">          	.body(exchange.openResponseBody(response))</span><br><span class="line">          	.build();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果响应头部是"close"，关闭流</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">        || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">      	exchange.noNewExchangesOnConnection();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//协议异常</span></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">          <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连接池复用"><a href="#连接池复用" class="headerlink" title="连接池复用"></a>连接池复用</h2><p>当然大量的连接每次连接关闭都要三次握手四次分手的很显然会造成性能低下，因此http有一种叫做keepalive connections的机制，它可以在传输数据后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手</p>
<p><img src="https://img-blog.csdn.net/20160828174519845" alt="连接复用"></p>
<p>Okhttp支持5个并发KeepAlive，默认链路生命为5分钟(链路空闲后，保持存活的时间)。</p>
<p>创建连接池实在OkHttpClient初始化的时候，ConnectinoPool通过直接new出的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> RealConnectionPool delegate;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> maxIdleConnections, <span class="keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.delegate = <span class="keyword">new</span> RealConnectionPool(maxIdleConnections, keepAliveDuration, timeUnit);</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/** Returns the number of idle connections in the pool. */</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">idleConnectionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> delegate.idleConnectionCount();</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/** Returns total number of connections in the pool. */</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connectionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> delegate.connectionCount();</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/** Close and remove all idle connections in the pool. */</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	delegate.evictAll();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里就可以看到，默认的是5个并发KeepAlive，默认链路生命是5分钟，直接创建了RealConnectionPool对象</p>
<h3 id="RealConnectionPool"><a href="#RealConnectionPool" class="headerlink" title="RealConnectionPool"></a>RealConnectionPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnectionPool</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">      Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class="line">      <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">"OkHttp ConnectionPool"</span>, <span class="keyword">true</span>));</span><br><span class="line">  	<span class="comment">//空闲的socket最大连接数</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleConnections;</span><br><span class="line">    <span class="comment">//socket的keepAlive时间</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveDurationNs;</span><br><span class="line">    <span class="comment">//用来进行自动清理无用的连接</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;</span><br><span class="line">    	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          	<span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">          	<span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">          	<span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">                waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (RealConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">                  	<span class="keyword">try</span> &#123;</span><br><span class="line">                    	RealConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">                  	&#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                  	&#125;</span><br><span class="line">                &#125;</span><br><span class="line">          	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;;</span><br><span class="line">	<span class="comment">//双端队列维护RealConnection</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  	<span class="comment">//路由数据库，它用来记录连接失败的Route的黑名单，当连接失败的时候就会把失败的线路加进去</span></span><br><span class="line">    <span class="keyword">final</span> RouteDatabase routeDatabase = <span class="keyword">new</span> RouteDatabase();</span><br><span class="line">  	<span class="comment">//是否自动回收空闲连接</span></span><br><span class="line">    <span class="keyword">boolean</span> cleanupRunning;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在RealConnectionPool中维护了一个线程池，来进行回收和复用；connections是一个记录连接的双端队列；routeDatabase是记录路由失败的线路，cleanupRunnable是用来进行自动回收连接的。</p>
<p>然后我们重点看一下cleanupRunnable：首先是一个死循环，一直执行，通过cleanup方法进行回收连接，并返回了下次清理的间隔时间（以纳米为单位，下次调用这个方法的时间），-1表示不需要再进行回收，则跳出循环，否则一直进行回收，同时让连接池RealConnectionPool等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      	<span class="comment">//遍历所有的连接</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            RealConnection connection = i.next();</span><br><span class="line">            <span class="comment">//判断是否正在使用 </span></span><br><span class="line">            <span class="comment">//查询此连接的StreamAllocation的引用数量，如果大于0则inUseConnectionCount数量加1，否则idleConnectionCount加1</span></span><br><span class="line">            <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              	inUseConnectionCount++;</span><br><span class="line">              	<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            idleConnectionCount++;</span><br><span class="line">            <span class="comment">//确定这个连接需要进行回收 标记连接</span></span><br><span class="line">            <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">            <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">              	longestIdleDurationNs = idleDurationNs;</span><br><span class="line">              	longestIdleConnection = connection;</span><br><span class="line">            &#125;</span><br><span class="line">      	&#125;</span><br><span class="line">		<span class="comment">//如果空闲连接keepAlive时间超过5分钟，或者空闲连接数超过5个，则从Deque中移除此连接</span></span><br><span class="line">      	<span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">            <span class="comment">//从connections中移除</span></span><br><span class="line">            connections.remove(longestIdleConnection);</span><br><span class="line">      	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">//如果空闲连接大于0，则返回此连接即将到期的时间</span></span><br><span class="line">        	<span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">//如果没有空闲连接，并且活跃连接大于0则返回5分钟</span></span><br><span class="line">        	<span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//没有连接</span></span><br><span class="line">        	cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//关闭连接</span></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据连接中的引用计数来计算空闲连接数和活跃连接数，然后标记出空闲的连接，如果空闲连接keepAlive时间超过5分钟，或者空闲连接数超过5个，则从Deque中移除此连接。接下来根据空闲连接或者活跃连接来返回下次需要清理的时间数：如果空闲连接大于0则返回此连接即将到期的时间，如果都是活跃连接并且大于0则返回默认的keepAlive时间5分钟，如果没有任何连接则跳出循环并返回-1</p>
<p>看看怎么来判断活跃连接的1<code>pruneAndGetAllocationCount()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    List&lt;Reference&lt;Transmitter&gt;&gt; references = connection.transmitters;</span><br><span class="line">    <span class="comment">//遍历引用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">      	Reference&lt;Transmitter&gt; reference = references.get(i);</span><br><span class="line">		<span class="comment">//如果还在使用</span></span><br><span class="line">      	<span class="keyword">if</span> (reference.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	i++;</span><br><span class="line">        	<span class="keyword">continue</span>;</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="comment">// We've discovered a leaked transmitter. This is an application bug.</span></span><br><span class="line">      	TransmitterReference transmitterRef = (TransmitterReference) reference;</span><br><span class="line">      	String message = <span class="string">"A connection to "</span> + connection.route().address().url()</span><br><span class="line">          + <span class="string">" was leaked. Did you forget to close a response body?"</span>;</span><br><span class="line">      	Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);</span><br><span class="line">		<span class="comment">//如果没有使用，则移除</span></span><br><span class="line">      	references.remove(i);</span><br><span class="line">      	connection.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//如果列表为空则说明此连接没有被引用了，则返回0，表示此连接是空闲连接</span></span><br><span class="line">      	<span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">        	connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则还有引用</span></span><br><span class="line">    <span class="keyword">return</span> references.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历RealConnection的transmitters列表，通过前面，我们知道每一次Call都会有一个Transmitter，这就对应着这个连接是否是空闲的，Transmitter越多，代表Call越多，连接次数越多，transmitters不为空，就不是空闲连接是活跃连接</p>
<p>回到cleanup方法，我们看看最后的<code>closeQuietly(longestIdleConnection.socket())</code>关闭连接</p>
<p>在Utils中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeQuietly</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="keyword">try</span> &#123;</span><br><span class="line">        	socket.close();</span><br><span class="line">      	&#125; <span class="keyword">catch</span> (AssertionError e) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (!isAndroidGetsocknameError(e)) <span class="keyword">throw</span> e;</span><br><span class="line">      	&#125; <span class="keyword">catch</span> (RuntimeException rethrown) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> rethrown;</span><br><span class="line">      	&#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就很简单了，关闭套接字Socket就可以了</p>
<p>这样，一个空闲连接就被回收关闭了</p>
<h3 id="缓存操作"><a href="#缓存操作" class="headerlink" title="缓存操作"></a>缓存操作</h3><ul>
<li><p>put</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">      	cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">      	executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    connections.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  put操作就很简单，根据cleanupRunning判断是否在进行自动回收，没有则先通过线程池执行cleanupRunnable进行回收，然后将连接connection添加到双端队列connections中</p>
</li>
<li><p>get</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">transmitterAcquirePooledConnection</span><span class="params">(Address address, Transmitter transmitter,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable List&lt;Route&gt; routes, <span class="keyword">boolean</span> requireMultiplexed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed()) <span class="keyword">continue</span>;</span><br><span class="line">      	<span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">continue</span>;</span><br><span class="line">      	transmitter.acquireConnectionNoEvents(connection);</span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这个方法就是尝试从连接池中获取连接；遍历connections，根据address和route来判断是不是所需要的连接，如果找到了对应的连接，就放到对应的Transmitter中，返回true，否则返回false</p>
<p>  找到连接后，会调用<code>transmitter.acquireConnectionNoEvents(connection);</code>将这个连接的引用次数+1</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireConnectionNoEvents</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    connection.transmitters.add(<span class="keyword">new</span> TransmitterReference(<span class="keyword">this</span>, callStackTrace));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  创建了一个TransmitterReference引用，添加到连接的transmitters中</p>
<p>  <code>final List&lt;Reference&lt;Transmitter&gt;&gt; transmitters = new ArrayList&lt;&gt;();</code></p>
<p>  这个transmitters就是一个连接引用的list，记录所有引用这个连接的Transmitter</p>
</li>
<li><p>关闭所有空闲连接</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;RealConnection&gt; evictedConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      	<span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        	RealConnection connection = i.next();</span><br><span class="line">        	<span class="keyword">if</span> (connection.transmitters.isEmpty()) &#123;</span><br><span class="line">              	connection.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">              	evictedConnections.add(connection);</span><br><span class="line">              	i.remove();</span><br><span class="line">        	&#125;</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : evictedConnections) &#123;</span><br><span class="line">      	closeQuietly(connection.socket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  取出所有空闲连接，然后通过closeQuietly关闭</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次不想写总结了，直接放图吧，太多了</p>
<p><img src="https://img-blog.csdnimg.cn/20190605100153475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="OkHttp3"></p>
<h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><ul>
<li><a href="https://blog.csdn.net/u010256388/article/details/68491509" target="_blank" rel="noopener">HTTP请求行、请求头、请求体详解</a></li>
<li><a href="https://xiaozhuanlan.com/topic/4023695781" target="_blank" rel="noopener">okHttp3源码解析(一)</a></li>
<li><a href="https://juejin.im/post/5af93575518825426539917b" target="_blank" rel="noopener">OkHttp3 源码解析执行流程</a></li>
<li><a href="https://blog.csdn.net/itachi85/article/details/52085256" target="_blank" rel="noopener">Android网络编程（七）源码解析OkHttp前篇 请求网络</a></li>
<li><a href="https://blog.csdn.net/itachi85/article/details/52335403" target="_blank" rel="noopener">Android网络编程（八）源码解析OkHttp后篇[复用连接池]</a></li>
<li><a href="https://blog.csdn.net/zhangqiluGrubby/article/details/80169374" target="_blank" rel="noopener">Android OkHttp3源码详解——整体框架</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android第三方框架/" rel="tag"># Android第三方框架</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/02/Android Binder学习/" rel="next" title="Android——Binder机制">
                <i class="fa fa-chevron-left"></i> Android——Binder机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/11/Android RxJava2源码分析/" rel="prev" title="Android RxJava2源码浅析">
                Android RxJava2源码浅析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/24489804?s=460&v=4" alt="PHS1024">
            
              <p class="site-author-name" itemprop="name">PHS1024</p>
              <p class="site-description motion-element" itemprop="description">黑色的眼睛在黑夜里前行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MinorPeng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-OkHttp3源码分析"><span class="nav-number">1.</span> <span class="nav-text">Android OkHttp3源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-number">1.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析"><span class="nav-number">1.2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单使用"><span class="nav-number">1.2.1.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OkHttpClient的创建"><span class="nav-number">1.2.2.</span> <span class="nav-text">OkHttpClient的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request的创建"><span class="nav-number">1.2.3.</span> <span class="nav-text">Request的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#得到Call对象newCall"><span class="nav-number">1.2.4.</span> <span class="nav-text">得到Call对象newCall</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步请求execute"><span class="nav-number">1.2.5.</span> <span class="nav-text">同步请求execute</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步请求enqueue"><span class="nav-number">1.2.6.</span> <span class="nav-text">异步请求enqueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拦截器链"><span class="nav-number">1.2.7.</span> <span class="nav-text">拦截器链</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RetryAndFollowUpInterceptor"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">RetryAndFollowUpInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BridgeInterceptor"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">BridgeInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CacheInterceptor"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">CacheInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConnectInterceptor"><span class="nav-number">1.2.7.4.</span> <span class="nav-text">ConnectInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CallServerInterceptor"><span class="nav-number">1.2.7.5.</span> <span class="nav-text">CallServerInterceptor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接池复用"><span class="nav-number">1.3.</span> <span class="nav-text">连接池复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RealConnectionPool"><span class="nav-number">1.3.1.</span> <span class="nav-text">RealConnectionPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存操作"><span class="nav-number">1.3.2.</span> <span class="nav-text">缓存操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特别鸣谢"><span class="nav-number">1.5.</span> <span class="nav-text">特别鸣谢</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PHS1024</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
