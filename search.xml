<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android 目录</title>
      <link href="/2020/03/02/Android%20%E7%9B%AE%E5%BD%95/"/>
      <url>/2020/03/02/Android%20%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>[Toc]</p><h1 id="Android-目录"><a href="#Android-目录" class="headerlink" title="Android 目录"></a>Android 目录</h1><h2 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h2><p>内部存储位于系统中很特殊的一个位置，对于设备中每一个安装的 App，系统都会在 <strong>data/data/packagename/xxx</strong>或者<strong>data/user/0/packagename/xxx</strong> 自动创建与之对应的文件夹。如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。对于这个内部目录，用户是无法访问的，除非获取root权限。</p><ul><li><code>context.getFilesDir()</code>：<code>/data/user/0/packagename/files</code></li><li><code>context.getCacheDir()</code>：<code>/data/user/0/packagename/cache</code>缓存目录，当内存不足时会优先被删掉</li></ul><h2 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h2><h3 id="机身自带的外部存储"><a href="#机身自带的外部存储" class="headerlink" title="机身自带的外部存储"></a>机身自带的外部存储</h3><p>这种属于现在主流的一种情况，大部分手机自带的存储空间变得很大，不再需要SD卡</p><p>私有包目录： <code>/storage/emulated/0/Android/data/packagename/</code></p><ul><li><p><code>context.getExternalCacheDir()</code>：<code>/storage/emulated/0/Android/data/packagename/cache</code></p></li><li><p><code>context.getExternalFilesDir(String)</code>：<code>/storage/emulated/0/Android/data/packagename/files/</code></p><table><thead><tr><th align="center">API</th><th align="center"><strong>对应路径</strong></th></tr></thead><tbody><tr><td align="center"><code>Environment.DIRECTORY_MUSIC</code></td><td align="center"><code>Music</code></td></tr><tr><td align="center"><code>DIRECTORY_PODCASTS</code></td><td align="center"><code>Podcasts</code></td></tr><tr><td align="center"><code>DIRECTORY_RINGTONES</code></td><td align="center"><code>Ringtones</code></td></tr><tr><td align="center"><code>DIRECTORY_ALARMS</code></td><td align="center"><code>Alarms</code></td></tr><tr><td align="center"><code>DIRECTORY_NOTIFICATIONS</code></td><td align="center"><code>Notifications</code></td></tr><tr><td align="center"><code>DIRECTORY_PICTURES</code></td><td align="center"><code>Pictures</code></td></tr><tr><td align="center"><code>DIRECTORY_MOVIES</code></td><td align="center"><code>Movies</code></td></tr><tr><td align="center"><code>DIRECTORY_DOWNLOADS</code></td><td align="center"><code>Download</code></td></tr><tr><td align="center"><code>DIRECTORY_DCIM</code></td><td align="center"><code>DCIM</code></td></tr><tr><td align="center"><code>DIRECTORY_DOCUMENTS</code></td><td align="center"><code>Documents</code></td></tr><tr><td align="center"><code>DIRECTORY_SCREENSHOTS</code></td><td align="center"><code>Screenshots</code></td></tr><tr><td align="center"><code>DIRECTORY_AUDIOBOOKS</code></td><td align="center"><code>Audiobooks</code></td></tr></tbody></table><p>  可根据<code>Environment</code>获取包目录下对应的目录</p></li></ul><p>公有目录：<code>/storage/emulated/0/</code></p><ul><li><p><code>Environment.getExternalStoragePublicDirectory(String)</code>：<code>/storage/emulated/0/</code></p><p>  通过<code>Environment</code>访问公有目录，如Music：<code>Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC)</code>对应的目录是<code>/storage/emulated/0/Music</code>，其他如Download等目录对应</p><p>  <em>在Android Q之后由于权限改变，不建议通过Environment去访问公有的目录，而是在自己的包目录下建立对应的目录</em></p></li></ul><h3 id="扩展SD卡的外部存储"><a href="#扩展SD卡的外部存储" class="headerlink" title="扩展SD卡的外部存储"></a>扩展SD卡的外部存储</h3><p>就是通过SD卡扩展的存储空间，一般来说是可以自由访问的空间，在以前的Android版本中，SD就是前面所说的外部存储来使用的</p><p>SD卡的状态</p><table><thead><tr><th align="center">标识</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center"><code>MEDIA_UNKNOWN</code></td><td align="center">SD卡未知</td></tr><tr><td align="center"><code>MEDIA_REMOVED</code></td><td align="center">SD卡移除</td></tr><tr><td align="center"><code>MEDIA_UNMOUNTED</code></td><td align="center">SD卡未安装</td></tr><tr><td align="center"><code>MEDIA_CHECKING</code></td><td align="center">SD卡检查中，刚装上SD卡时</td></tr><tr><td align="center"><code>MEDIA_NOFS</code></td><td align="center">SD卡为空白或正在使用不受支持的文件系统</td></tr><tr><td align="center"><code>MEDIA_MOUNTED</code></td><td align="center">SD卡安装</td></tr><tr><td align="center"><code>MEDIA_MOUNTED_READ_ONLY</code></td><td align="center">SD卡安装但是只读</td></tr><tr><td align="center"><code>MEDIA_SHARED</code></td><td align="center">SD卡共享</td></tr><tr><td align="center"><code>MEDIA_BAD_REMOVAL</code></td><td align="center">SD卡移除错误</td></tr><tr><td align="center"><code>MEDIA_UNMOUNTABLE</code></td><td align="center">存在SD卡但是不能挂载，例如发生在介质损坏</td></tr><tr><td align="center"><code>MEDIA_EJECTING</code></td><td align="center">SD卡弹出</td></tr></tbody></table><p>访问SD卡通常会通过<code>Environment</code>来进行访问</p><ul><li><code>Environment.getExternalStorageDirectory()</code>：SD卡根目录</li></ul><h2 id="系统目录"><a href="#系统目录" class="headerlink" title="系统目录"></a>系统目录</h2><ul><li><code>getRootDirectory()</code>：<code>/system</code></li><li><code>getDataDirectory()</code>：<code>/data</code></li><li><code>getDownloadCacheDirectory</code>：<code>/cache</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5a39e33bf265da430b7b60fc" target="_blank" rel="noopener">Android基础   你必须了解的应用文件目录</a></li><li><a href="https://juejin.im/post/5de7772af265da3398561133" target="_blank" rel="noopener">一篇文章搞懂android存储目录结构</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 常用加密算法</title>
      <link href="/2020/03/02/Android%20%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/02/Android%20%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Android-常用加密算法"><a href="#Android-常用加密算法" class="headerlink" title="Android 常用加密算法"></a>Android 常用加密算法</h1><p><strong>数字签名</strong>：</p><p>简单来说就是提供可鉴别的数字信息验证自身身份的一种方式。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。分别又发送者持有能够代表自己身份的私钥（不可泄漏），由接受者持有与私钥对应的公钥，能够在接受到来自发送者信息时用于验证身份。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>加密和解密密钥相同，加解密过程可逆</p><ul><li><p>DES</p><p>  Data Encryption Standard，数据加密算法</p><blockquote><p>Key：8字节</p><p>Data：8字节，数据</p><p>Mode：DES工作模式，有EBC（电子密码本模式）、CBC（加密分组链接模式  ）、CFB（加密反馈模式）、OFB（输出反馈模式）、CTR（计数器模式）；NoPadding（不填充）、Zeros填充（0填充）、PKCS5Padding填充</p></blockquote><p>  示例：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"GetInstance"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">desEncrypt</span><span class="params">(content: <span class="type">ByteArray</span>, pwd: <span class="type">ByteArray</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> random = SecureRandom()</span><br><span class="line">    <span class="keyword">val</span> desKey = DESKeySpec(pwd)</span><br><span class="line">    <span class="keyword">val</span> keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>)</span><br><span class="line">    <span class="keyword">val</span> secureKey = keyFactory.generateSecret(desKey)</span><br><span class="line">    <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"DES"</span>)</span><br><span class="line">    cipher.<span class="keyword">init</span>(Cipher.ENCRYPT_MODE, secureKey, random)</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"GetInstance"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">desDecrypt</span><span class="params">(content: <span class="type">ByteArray</span>, pwd: <span class="type">ByteArray</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> random = SecureRandom()</span><br><span class="line">    <span class="keyword">val</span> desKey = DESKeySpec(pwd)</span><br><span class="line">    <span class="keyword">val</span> keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>)</span><br><span class="line">    <span class="keyword">val</span> secureKey = keyFactory.generateSecret(desKey)</span><br><span class="line">    <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"DES"</span>)</span><br><span class="line">    cipher.<span class="keyword">init</span>(Cipher.DECRYPT_MODE, secureKey, random)</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>3DES</p><p>  Triple DES，三重数据加密算法，相当于是对每个数据块应用三次数据加密标准（DES）算法，加长了密钥长度</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tripleDesEncrypt</span><span class="params">(<span class="keyword">data</span>: <span class="type">ByteArray</span>, key: <span class="type">ByteArray</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> desKey = DESedeKeySpec(key)</span><br><span class="line">    <span class="keyword">val</span> keyFactory = SecretKeyFactory.getInstance(<span class="string">"desede"</span>)</span><br><span class="line">    <span class="keyword">val</span> secureKey = keyFactory.generateSecret(desKey)</span><br><span class="line">    <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"desede/ECB/PKCS5Padding"</span>)</span><br><span class="line">    cipher.<span class="keyword">init</span>(Cipher.ENCRYPT_MODE, secureKey)</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tripleDesDecrypt</span><span class="params">(<span class="keyword">data</span>: <span class="type">ByteArray</span>, key: <span class="type">ByteArray</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> desKey = DESedeKeySpec(key)</span><br><span class="line">    <span class="keyword">val</span> keyFactory = SecretKeyFactory.getInstance(<span class="string">"desede"</span>)</span><br><span class="line">    <span class="keyword">val</span> secureKey = keyFactory.generateSecret(desKey)</span><br><span class="line">    <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"desede/ECB/PKCS5Padding"</span>)</span><br><span class="line">    cipher.<span class="keyword">init</span>(Cipher.DECRYPT_MODE, secureKey)</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>AES</p><p>  Advanced Encryption Standard，高级加密标准，取代DES而出现</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">aesEncrypt</span><span class="params">(<span class="keyword">data</span>: <span class="type">ByteArray</span>, key: <span class="type">ByteArray</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> keygen = KeyGenerator.getInstance(<span class="string">"AES"</span>)</span><br><span class="line">    keygen.<span class="keyword">init</span>(<span class="number">128</span>, SecureRandom(key))</span><br><span class="line">    <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES"</span>)</span><br><span class="line">    cipher.<span class="keyword">init</span>(Cipher.ENCRYPT_MODE, SecretKeySpec(keygen.generateKey().encoded, <span class="string">"AES"</span>))</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">aesDecrypt</span><span class="params">(<span class="keyword">data</span>: <span class="type">ByteArray</span>, key: <span class="type">ByteArray</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> keygen = KeyGenerator.getInstance(<span class="string">"AES"</span>)</span><br><span class="line">    keygen.<span class="keyword">init</span>(<span class="number">128</span>, SecureRandom(key))</span><br><span class="line">    <span class="keyword">val</span> cipher = Cipher.getInstance(<span class="string">"AES"</span>)</span><br><span class="line">    cipher.<span class="keyword">init</span>(Cipher.DECRYPT_MODE, SecretKeySpec(keygen.generateKey().encoded, <span class="string">"AES"</span>))</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(<span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>加密和解密密钥不同</p><ul><li><p>RSA</p><p>  目前最有影响力的公钥加密算法，能抵抗目前已知所有密码攻击</p><p>  公钥私钥对</p></li><li><p>DSA</p><p>  Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature  Standard)。它是一种公开密钥算法，用作数字签名。DSA加密算法使用公开密钥，为接受者验证数据的完整性和数据发送者的身份，它也可用于由第三方去确定签名和所签数据的真实性</p></li><li><p>ECC</p><p>  它比其他的方法使用 <strong>更小的密钥</strong>，比如 <code>RSA</code> <strong>加密算法</strong>，提供 <strong>相当的或更高等级</strong> 的安全级别。不过一个缺点是 <strong>加密和解密操作</strong> 的实现比其他机制 <strong>时间长</strong> (相比 <code>RSA</code> 算法，该算法对 <code>CPU</code> 消耗严重)</p></li></ul><h2 id="其他散列算法"><a href="#其他散列算法" class="headerlink" title="其他散列算法"></a>其他散列算法</h2><p>摘要算法，不可逆过程，经过算法运算后都是生成固定长度的数据，使用16进行进行显示</p><ul><li><p>SHA-1</p><p>  160位摘要，强度更高</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> shaDigest = MessageDigest.getInstance(<span class="string">"SHA-1"</span>)</span><br><span class="line">shaDigest.update(bytes)</span><br><span class="line"><span class="keyword">return</span> shaDigest.digest()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>MD5</p><p>  1228位摘要，速度更快</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> shaDigest = MessageDigest.getInstance(<span class="string">"MD5"</span>)</span><br><span class="line">shaDigest.update(bytes)</span><br><span class="line"><span class="keyword">return</span> shaDigest.digest()</span><br></pre></td></tr></table></figure></li></ul><p>其他摘要算法类似</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="https://raw.githubusercontent.com/MinorPeng/Image/master/android_encryption_compare.png" alt="算法比较"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5b48b0d7e51d4519962ea383" target="_blank" rel="noopener">浅谈常见的七种加密算法及实现</a></li><li><a href="https://blog.csdn.net/Techzero/article/details/17282637" target="_blank" rel="noopener">Java DES 加密 解密 示例</a></li><li><a href="https://blog.csdn.net/mrli113/article/details/72884301" target="_blank" rel="noopener">Java实现DES加密解密算法</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">分组密码工作模式</a></li><li><a href="https://blog.csdn.net/alwaysrun/article/details/89076403" target="_blank" rel="noopener">常见对称加密算法与工作模式简介</a></li><li><a href="https://blog.csdn.net/u011781521/article/details/77932321" target="_blank" rel="noopener">JAVA AES加密与解密</a></li><li><a href="https://blog.csdn.net/u013565368/article/details/53081195" target="_blank" rel="noopener">常用加密解密算法【RSA、AES、DES、MD5】介绍和使用</a></li><li><a href="https://blog.csdn.net/happen_if/article/details/85219306" target="_blank" rel="noopener">DSA加密算法以及破解</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他面试题汇总</title>
      <link href="/2020/02/07/%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2020/02/07/%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="其他总结"><a href="#其他总结" class="headerlink" title="其他总结"></a>其他总结</h1><h2 id="数据库相关面试题"><a href="#数据库相关面试题" class="headerlink" title="数据库相关面试题"></a>数据库相关面试题</h2><ol><li><p>左链接和右链接的区别<br> 左连接where只影向右表，右连接where只影响左表。</p><p> <code>select * from tbl1 Left Join tbl2 where tbl1.ID = tbl2.ID</code><br> 左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据。简言之 Left Join影响到的是右边的表</p><p> <code>select * from tbl1 Right Join tbl2 where tbl1.ID = tbl2.ID</code><br> 检索结果是tbl2的所有数据和tbl1中满足where 条件的数据。简言之 Right Join影响到的是左边的表</p></li><li><p>SQL语句中对表或者字段取别名有什么好处？<br> （1）区别同名列的名称<br> （2）非法的表达式合法化<br> （3）按照你的意愿显示列的名称</p></li><li><p>索引的种类。<br> 主键索引、普通索引、唯一索引和全文索引<br> <a href="https://blog.csdn.net/hzy38324/article/details/44922651" target="_blank" rel="noopener">数据库调优教程（五） 索引的作用和索引的种类</a></p></li><li><p>主键和唯一键的区别，回答是否能为空，是否能做外键<br> 主键是不能重复且不能为空，唯一键是不能重复但可以为空的；一张表可以有多个唯一键但是只能有一个主键；主键可以做外键，唯一键也可以</p></li><li><p>如何做SQLite升级？<br> （1）让用户卸载老版本再安装新的程序； 缺点：可操作性低，软件卸载会造成老数据的丢失<br> （2）软件自行更新数据库结构。 可取：作为开发者必须妥善处理数据库的升级问题</p><p> <a href="https://juejin.im/entry/586b5ecc61ff4b006d7eef05#方法" target="_blank" rel="noopener">绝对值得一看的 Android 数据库升级攻略</a></p></li><li><p>Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入<br> Statement与PreparedStatement的区别:<br> 关系：PreparedStatement继承自Statement,都是接口<br> 区别：PreparedStatement可以使用占位符，是预编译的，表示预编译的 SQL 语句的对象，批处理比Statement效率高</p><p> 什么是SQL注入：<br> 所谓SQL注入式攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容直接用来构造(或者影响)动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击</p><p> 如何防止SQL注入：<br> ⑴ 对于动态构造SQL查询的场合，可以使用下面的技术:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一：替换单引号，即把所有单独出现的单引号改成两个单引号，防止攻击者修改SQL命令的含义  </span><br><span class="line">第二：删除用户输入内容中的所有连字符，防止攻击者构造出类如“SELECT * from Users WHERE login= ’mas’ —— AND password=’’”之类的查询，因为这类查询的后半部分已经被注释掉，不再有效，攻击者只要知道一个合法的用户登录名称，根本不需要知道用户的密码就可以顺利获得访问权限  </span><br><span class="line">第三：对于用来执行查询的数据库帐户，限制其权限。用不同的用户帐户执行查询、插入、更新、删除操作。由于隔离了不同帐户可执行的操作，因而也就防止了原本用于执行SELECT命令的地方却被用于执行INSERT、UPDATE或DELETE命令</span><br></pre></td></tr></table></figure><p> （2）用存储过程来执行所有的查询。SQL参数的传递方式将防止攻击者利用单引号和连字符实施攻击。此外，它还使得数据库权限可以限制到只允许特定的存储过程执行，所有的用户输入必须遵从被调用的存储过程的安全上下文，这样就很难再发生注入式攻击了<br> （3）限制表单或查询字符串输入的长度。如果用户的登录名字最多只有10个字符，那么不要认可表单中输入的10个以上的字符，这将大大增加攻击者在SQL命令中插入有害代码的难度<br> （4）检查用户输入的合法性，确信输入的内容只包含合法的数据。数据检查应当在客户端和服务器端都执行——之所以要执行服务器端验证，是为了弥补客户端验证机制脆弱的安全性<br> （5）将用户登录名称、密码等数据加密保存。加密用户输入的数据，然后再将它与数据库中保存的数据比较，这相当于对用户输入的数据进行了“消毒”处理，用户输入的数据不再对数据库有任何特殊的意义，从而也就防止了攻击者注入SQL命令<br> （6） 检查提取数据的查询所返回的记录数量。如果程序只要求返回一个记录，但实际返回的记录却超过一行，那就当作出错处理</p><p> <a href="https://blog.csdn.net/myron_sqh/article/details/12975563" target="_blank" rel="noopener">如何防止SQL注入</a></p></li><li><p>Tomcat，Apache，JBoss的区别？<br> Apache：http服务器（web服务器），类似IIS可以用于建立虚拟站点，编译处理静态页面；可以支持SSL技术，支持多个虚拟主机等功能；</p><p> Tomcat：servlet容器，用于解析jsp，servlet的Servlet容器，是高效，轻量级的容器；缺点： 不支持EJB，只能用于java应用；</p><p> Jboss：应用服务器，运行EJB的J2EE应用服务器，遵循J2EE规范，能够提供更多平台的支持和更多集成功能，如数据库连接，JCA等；其对servlet的支持是通过集成其他servlet容器来实现的，如tomcat和jetty；</p><p> <a href="https://blog.csdn.net/mydriverc2/article/details/50129469" target="_blank" rel="noopener">Apache, jboss, tomcat区别</a></p></li></ol><h2 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h2><ol><li><p>混合开发，RN，weex，H5，小程序(做Android的了解一些前端js等还是很有好处的)<br> rexxar-android 是豆瓣的混合开发框架</p></li><li><p>有没有用过第三方WebView组件？讲一讲优势<br> Crosswalk：据说各种流畅、强大，且Cordova在新的版本当中也将默认支持Crosswalk。</p><p> TBS服务：由腾讯QQ浏览器团队出品。支持“共享X5内核模式”和“独立下载X5内核模式”<br> 1)速度快：相比系统WebView的网页加载速度有近30%的提升；<br> 2)省流量：云端优化技术使流量节省20%；<br> 3)更安全：24小时安全问题解决机制；<br> 4)更稳定：经过亿级用户的使用考验，CRASH率0.15%；<br> 5)集成强大的视频播放器，支持各种视频格式直接打开；<br> 6)适屏排版、字体设置等浏览增强功能的提供；<br> 7)HTML5更完整支持；<br> 8)无系统碎片化问题、更少的兼容性问题</p><p> <a href="https://www.jianshu.com/p/d3ef9c62b6c8" target="_blank" rel="noopener">还在用Android自带的WebView组件？太Out了！</a></p></li><li><p>WebView与js交互（调用哪些API）<br> 对于Android调用JS代码的方法有2种：<br> （1）通过WebView的loadUrl（）<br> （2）通过WebView的evaluateJavascript（）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">webview.evaluateJavascript(<span class="string">"javascript:sendMsg()"</span>, <span class="keyword">new</span> ValueCallback&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Toast.makeText(MainActivity.<span class="keyword">this</span>, value, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p> （3）webview提供的两个方法：setWebViewClient和setWebChromeClient解决进度条问题；前者主要用于处理webView的控制问题，如加载、关闭、错误处理等；后者主要处理js对话框、图标、页面标题等<br> （4）单独构建一个接口，作为处理js与java的数据交互的桥梁</p><p> 对于JS调用Android代码的方法有3种：<br> （1）通过WebView的addJavascriptInterface（）进行对象映射<br> （2）通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url<br> （3）通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息<br> （4）给JS可以调用的方法加上@JavascriptInterface的注解</p><p> <a href="https://www.jianshu.com/p/fd61e8f4049e" target="_blank" rel="noopener">Android WebView 全面干货指南</a></p></li><li><p>关于WebView的优化你知道哪些<br> （1）内核初始化：第一次打开 Web 页面 ， 使用 WebView 加载页面的时候特别慢 ，第二次打开就能明显的感觉到速度有提升 ，为什么 ？ 是因为在你第一次加载页面的时候 WebView 内核并没有初始化 ， 所以在第一次加载页面的时候需要耗时去初始化 WebView 内核 。提前初始化 WebView 内核<br> （2）复用 WebView<br> （3）验证复用 WebView 和提前初始化 WebView 必要性<br> （4）WebView 独立进程 ， 进程预加载<br> （5）提前显示进度条<br> （6）开启软硬件加速</p></li><li><p>描述一下WebView的缓存机制<br> WebView中存在着两种缓存：网页数据缓存（存储打开过的页面及资源）、H5缓存（即AppCache）<br> 网页缓存：<br> 浏览器缓存机制是通过HTTP协议Header里的Cache-Control（或Expires）和Last-Modified（或 Etag）等字段来控制文件缓存的机制。关于这几个字段的作用和浏览器的缓存更新机制</p><blockquote><p>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据<br>LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。<br>LOAD_CACHE_NORMAL: API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式<br>LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.<br>LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</p></blockquote><p> 建议缓存策略为，判断是否有网络，有的话，使用LOAD_DEFAULT，无网络时，使用LOAD_CACHE_ELSE_NETWORK。</p><p> H5缓存：<br> H5缓存主要包括了App Cache、DOM Storage、Local Storage、Web SQL Database 存储机制<br> 根据setAppCachePath(String appCachePath)提供的路径，在H5使用缓存过程中生成的缓存文件。<br> 无模式选择，通过setAppCacheEnabled(boolean flag)设置是否打开。默认关闭，即，H5的缓存无法使用。</p><p> AppCache工作的原理：当一个设置了manifest文件的html页面被加载时，CACHE MANIFEST指定的文件就会被缓存到浏览器的App Cache目录下面。当下次加载这个页面时，会首先应用通过manifest已经缓存过的文件，然后发起一个加载xxx.appcache文件的请求到服务器，如果xxx.appcache文件没有被修改过，那么服务器会返回304 Not Modified给到浏览器，如果xxx.appcache文件被修改过，那么服务器会返回200 OK，并返回新的xxx.appcache文件的内容给浏览器，浏览器收到之后，再把新的xxx.appcache文件中指定的内容加载过来进行缓存。</p><p> <a href="http://unclechen.github.io/2017/05/13/WebView缓存原理分析和应用/" target="_blank" rel="noopener">WebView缓存原理分析和应用</a></p></li><li><p>WebView的内核是什么<br> 在Android 4.4以下(不包含4.4)系统WebView底层实现是采用WebKit内核（一个开源的浏览器引擎），而在Android 4.4及其以上Google 采用了chromium（Chromium 是 Google 的chrome浏览器背后的引擎，其目的是为了创建一个安全、稳定和快速的通用浏览器）作为系统WebView的底层内核支持</p><p> <a href="https://www.jianshu.com/p/8826b65dd880" target="_blank" rel="noopener">关于Android WebView的那些事</a></p></li><li><p>描述一下Webview的作用<br> WebView 是一个用来显示 Web 网页的控件，继承自 AbsoluteLayout，和使用系统其他控件没什么区别，它是一个微型浏览器，包含一个浏览器该有的基本功能<br> （1）可以打开远程URL页面，也可以加载本地HTML数据<br> （2）可以无缝的在java和javascript之间进行交互操作<br> （3）高度的定制性，可根据开发者的需要进行多样性定制</p></li><li><p>Java和JS的相互调用怎么实现，有做过什么优化吗？<br> 对于Android调用JS代码的方法有2种：<br> （1）通过WebView的loadUrl（）<br> （2）通过WebView的evaluateJavascript（）</p><p> 对于JS调用Android代码的方法有3种：<br> （1）通过WebView的addJavascriptInterface（）进行对象映射<br> （2）通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url<br> （3）通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息</p></li></ol><h2 id="Application、AndroidManifest、Context"><a href="#Application、AndroidManifest、Context" class="headerlink" title="Application、AndroidManifest、Context"></a>Application、AndroidManifest、Context</h2><ol><li><p>Application 和 Activity 的 context 对象的区别<br> （1）生命周期不一样<br> （2）Application 不能showDialog<br> （3）Application startActivity时必须new一个Task<br> （4）Application layoutInflate直接使用默认主题，可能与当前主题不一样</p></li><li><p>AndroidManifest的作用与理解<br> 包括的信息：<br> （1）manifest：根节点，描述了包名，版本号等。<br> （2）application：包含package中application级别组件声明的根节点。<br> （3）activity：Activity是用来与用户交互的主要工具。<br> （4）receiver：IntentReceiver能使的application获得数据的改变或者发生的操作，即使它当前不在运行。<br> （5）service：Service是能在后台运行任意时间的组件。<br> （6）provider：ContentProvider是用来管理持久化数据并发布给其他应用程序使用的组件。<br> （7）uses-permission：请求你的package正常运作所需赋予的安全许可。<br> （8）permission： 声明了安全许可来限制哪些程序能你package中的组件和功能。<br> （9）uses-feature:使用到的硬件信息，如nfc<br> （10）upports-screens：支持的屏幕类型<br> （11）meta-data：data数据<br> （12）instrumentation：声明了用来测试此package或其他package指令组件的代码。</p></li><li><p>讲解一下Context<br> Context是一个抽象基类，我们通过它访问当前包的资源（getResources、getAssets）和启动其他组件（Activity、Service、Broadcast）以及得到各种服务（getSystemService），当然，通过Context能得到的不仅仅只有上述这些内容。对Context的理解可以来说：Context提供了一个应用的运行环境，在Context的大环境里，应用才可以访问资源，才能完成和其他组件、服务的交互，Context定义了一套基本的功能接口，我们可以理解为一套规范，而Activity和Service是实现这套规范的子类，这么说也许并不准确，因为这套规范实际是被ContextImpl类统一实现的，Activity和Service只是继承并有选择性地重写了某些规范的实现。</p><p> <a href="https://blog.csdn.net/guolin_blog/article/details/47028975" target="_blank" rel="noopener">Android Context完全解析，你所不知道的Context的各种细节</a></p></li><li><p>Application类的作用<br> （1）Application是一个基类，这个基类的作用是获取整个App的状态，我们需要自己定义一个类来继承这个基类。<br> （2）定义一些全局的和一些上下文都要用到的变量和方法<br> （3）数据传递、数据共享和数据缓存<br> （4）初始化一些资源</p><p> <a href="https://juejin.im/entry/59c30e0ff265da06611f7024" target="_blank" rel="noopener">Android：全面解析 Application类</a></p></li><li><p>Android应用里有几种Context对象，<br> Application、Activity、Service、ContentProvider、BroadcastReceiver这几种的Context，前三种是Context的实现类</p><p> <a href="https://blog.csdn.net/lmj623565791/article/details/40481055" target="_blank" rel="noopener">Android Context 上下文 你必须知道的一切 - CSDN博客</a></p></li><li><p>进程和 Application 的生命周期；<br> 大多数情况下，每个Android的Application都运行在它自己的Linux进程里。这个过程是为应用程序在某些代码需要运行时创建的，并且将一直运行，直到不再需要它，系统需要回收内存供其他应用程序使用为止<br> Android的一个不同寻常的基本特性是应用程序过程的生命周期不受应用程序本身的直接控制。<br> 相反，系统需要通过系统了解应用程序的运行部分的组合、这些东西对用户的重要性以及系统中可用的总内存数量</p></li></ol><h2 id="混淆、反编译、"><a href="#混淆、反编译、" class="headerlink" title="混淆、反编译、"></a>混淆、反编译、</h2><ol><li><p>Android反编译与混淆<br> 反编译：<br> （1）首先需要下载工具：dex2jar（这个工具用于将dex文件转换成jar文件）、jd-gui（这个工具用于将jar文件转换成java代码）、apktool（用于最大幅度地还原APK文件中的9-patch图片、布局、字符串等等一系列的资源，主要下载apktool.bat和apktool.jar文件）<br> （2）解压dex2jar，将apk解压手的classes.dex文件复制到dex2jar的解压目录下<br> （3）通过cmd命令进入到该目录，执行<code>d2j-dexjar classes.dex</code>，成功后就会转换出一个jar文件<br> （4）接着用jd-gui打开这个jar文件（此时代码的解析就成功了）<br> （5）接着反编译资源文件，将apk复制到与apktool相同的目录下<br> （6）然后通过cmd在该目录下执行<code>apktool d Demo.apk</code>，然后目录下就会出现项目工程文件夹</p><p> 混淆：<br> （1）使用AS自带的混淆：build.gradle中minifyEnabled的值设为true<br> （2）自己实现混淆规则：proguard-android.txt文件</p><p> <a href="https://blog.csdn.net/guolin_blog/article/details/49738023" target="_blank" rel="noopener">Android安全攻防战，反编译与混淆技术完全解析（上）</a><br> <a href="https://blog.csdn.net/guolin_blog/article/details/50451259" target="_blank" rel="noopener">Android安全攻防战，反编译与混淆技术完全解析（下）</a></p></li><li><p>代码混淆是干嘛的<br> 将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式<br> 代码混淆的主要目的是为了保护源代码，阻止反向工程。反向工程会带来许多问题，诸如知识产权泄露，程序弱点暴露易受攻击等。使用即时编译技术的语言，如Java、C#所编写的程序更容易受到反向工程的威胁</p></li></ol><h2 id="APP启动过程、apk安装过程、apk打包过程、系统启动过程"><a href="#APP启动过程、apk安装过程、apk打包过程、系统启动过程" class="headerlink" title="APP启动过程、apk安装过程、apk打包过程、系统启动过程"></a>APP启动过程、apk安装过程、apk打包过程、系统启动过程</h2><ol><li><p>App启动流程，从点击桌面开始<br> <a href="https://user-gold-cdn.xitu.io/2016/12/26/becea8f3d8c19efd04a53aed658d8e4b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2016/12/26/becea8f3d8c19efd04a53aed658d8e4b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="启动过程"></a>启动过程<br> ①点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；<br> ②system_server进程接收到请求后，向zygote进程发送创建进程的请求；<br> ③Zygote进程fork出新的子进程，即App进程；<br> ④App进程，通过Binder IPC向sytem_server进程发起attachApplication请求<br> ⑤system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；<br> ⑥App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；<br> ⑦主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。<br> ⑧到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。</p><p> <a href="https://www.jianshu.com/p/a72c5ccbd150" target="_blank" rel="noopener">一个APP从启动到主页面显示经历了哪些过程？</a></p></li><li><p>描述清点击 Android Studio 的 build 按钮后发生了什么<br> build过程即执行gradle task 打包生成apk的过程：<br> （1）通过appt工具，将资源文件生成R.java文件；将aild文件转换成对应的java文件<br> （2）编译java文件，生成.class文件<br> （3）将.class文件转换成Android虚拟机支持的.dex文件<br> （4）通过apkbuilder将dex文件和编译后的资源文件生成apk文件<br> （5）对apk进行签名和对齐</p></li><li><p>大体说清一个应用程序安装到手机上时发生了什么<br> （1） 拷贝apk文件到指定目录<br> 在Android系统中，apk安装文件是会被保存起来的，默认情况下，用户安装的apk首先会被拷贝到 /data/app 目录下。<br> /data/app目录是用户有权限访问的目录，在安装apk的时候会自动选择该目录存放用户安装的文件，而系统出厂的apk文件则被放到了 /system 分区下,包括 /system/app，/system/vendor/app，以及 /system/priv-app 等等，该分区只有Root权限的用户才能访问，这也就是为什么在没有Root手机之前，我们无法删除系统出厂的app的原因了。</p><p> （2） 解压apk，拷贝文件，创建应用的数据目录<br> 为了加快app的启动速度，apk在安装的时候，会首先将app的可执行文件（dex）拷贝到 /data/dalvik-cache 目录，缓存起来。<br> 然后，在/data/data/目录下创建应用程序的数据目录（以应用的包名命名），存放应用的相关数据，如数据库、xml文件、cache、二进制的so动态库等等。</p><p> （3） 解析apk的AndroidManifinest.xml文件<br> Android系统中，也有一个类似注册表的东西，用来记录当前所有安装的应用的基本信息，每次系统安装或者卸载了任何apk文件，都会更新这个文件。这个文件位于如下目录：<br> /data/system/packages.xml<br> 系统在安装apk的过程中，会解析apk的AndroidManifinest.xml文件，提取出这个apk的重要信息写入到packages.xml文件中，这些信息包括：权限、应用包名、APK的安装位置、版本、userID等等。<br> 由此，我们就知道了为啥一些应用市场和软件管理类的app能够很清楚地知道当前手机所安装的所有的app，以及这些app的详细信息了。<br> 另外一件事就是Linux的用户Id和用户组Id，以便他可以获得合适的运行权限。<br> 以上这些都是由PackageServiceManager完成的，下面我们会重点介绍PackageServiceManager。</p><p> （4） 显示快捷方式<br> 这些应用程序只是相当于在PackageManagerService服务注册好了，如果我们想要在Android桌面上看到这些应用程序，还需要有一个Home应用程序，负责从PackageManagerService服务中把这些安装好的应用程序取出来，并以友好的方式在桌面上展现出来，例如以快捷图标的形式。在Android系统中，负责把系统中已经安装的应用程序在桌面中展现出来的Home应用程序就是Launcher了</p><p> <a href="https://www.jianshu.com/p/953475cea991" target="_blank" rel="noopener">Android Apk安装过程分析</a><br> <a href="https://blog.csdn.net/hdhd588/article/details/6739281" target="_blank" rel="noopener">APK安装过程及原理详解</a></p></li><li><p>App 是如何沙箱化，为什么要这么做；<br> （1）沙箱化可以提升安全性和效率<br> （2）Android的底层内核为Linux，因此继承了Linux良好的安全性，并对其进行了优化。在Linux中，一个用户对应一个uid，而在Android中，（通常）一个APP对应一个uid，拥有独立的资源和空间，与其他APP互不干扰。如有两个APP A和B，A并不能访问B的资源，A的崩溃也不会对B造成影响，从而保证了安全性和效率</p></li><li><p>系统启动流程<br> Zygote进程 –&gt; SystemServer进程 –&gt; 各种系统服务 –&gt; 应用进程<br> <a href="https://upload-images.jianshu.io/upload_images/2848265-3a35e6d39a8a020b.png?imageMogr2/auto-orient/strip|imageView2/2/w/697" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2848265-3a35e6d39a8a020b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/697" alt="系统启动流程"></a>系统启动流程</p><p> （1）Bootloader引导：主要作用是启动Linux内核<br> （2）Linux kernel启动<br> （3）Init进程的启动：一个由内核启动的用户级进程，启动过程就是代码init.c中main函数执行过程：system\core\init\init.c，在函数中执行了：文件夹建立，挂载，rc文件解析，属性设置，启动服务，执行动作，socket监听……，在rc文件解析中会启动servicemanager服务和Zygote进程<br> （4）servicemanager服务：用来管理系统中所有的binder service，最主要的管理就是，注册添加服务，获取服务。所有的Service使用前都必须先在servicemanager中进行注册<br> （5）Zygote进程的启动：这个进程起来才会建立起真正的Android运行空间<br> （6）Android启动，Zygote启动<br> （7）SystemServer启动<br> （8）ActivityManagerService启动</p><p> 总结：<br> 当Android系统第一次启动时，和Windows系统一样都有一个类似于引导系统启动的程序，引导系统启动。Android系统第一个启动的进程是Zygote(孵化的意思)进程，由他负责再启动其他进程，随之而来的是创建各种需要的文件夹，初始化各种硬件设备和服务，硬件设备包括传感器，显示设备，声音设备等等，服务就是我们平时用的WindowServiceManager，ActivityServiceManager，他们都在SystemServer的一个内部类ServerThread（是一个线程）的run方法中被初始化，保存在Map中。之后调用ActivityManagerService的resumeTopActivityLocked方法打开第一个Activty应用，这个应用便是我们的桌面应用，至此Android系统启动完毕。</p><p> <a href="https://blog.csdn.net/singwhatiwanna/article/details/19302593" target="_blank" rel="noopener">Android内核解读-Android系统的开机启动过程</a><br> <a href="https://blog.csdn.net/itachi85/article/details/56669808" target="_blank" rel="noopener">Android系统启动流程（四）Launcher启动过程与系统启动流程</a></p></li><li><p>应用安装过程<br> <a href="https://user-gold-cdn.xitu.io/2018/5/4/16329f99d3a4b73a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2018/5/4/16329f99d3a4b73a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="APK的安装流程"></a>APK的安装流程<br> （1）解压文件到data/app目录下<br> （2）资源管理器加载资源文件<br> （3）解析解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。<br> （4）然后对dex文件进行优化，并保存在dalvik-cache目录下。<br> （5）将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。<br> （6）安装完成后，发送广播。</p></li><li><p>对于应用更新这块是如何做的？(灰度，强制更新，分区域更新)<br> 灰度：<br> (1)找单一渠道投放特别版本。<br> (2)做升级平台的改造，允许针对部分用户推送升级通知甚至版本强制升级。<br> (3)开放单独的下载入口。<br> (4)是两个版本的代码都打到app包里，然后在app端植入测试框架，用来控制显示哪个版本。测试框架负责与服务器端api通信，由服务器端控制app上A/B版本的分布，可以实现指定的一组用户看到A版本，其它用户看到B版本。服务端会有相应的报表来显示A/B版本的数量和效果对比。最后可以由服务端的后台来控制，全部用户在线切换到A或者B版本~</p><p> 无论哪种方法都需要做好版本管理工作，分配特别的版本号以示区别。灰度版最好有收回的能力，一般就是强制升级下一个正式版</p><p> 强制更新:<br> 一般的处理就是进入应用就弹窗通知用户有版本更新，弹窗可以没有取消按钮并不能取消。这样用户就只能选择更新或者关闭应用了，当然也可以添加取消按钮，但是如果用户选择取消则直接退出应用。</p><p> 增量更新：<br> bsdiff：二进制差分工具bspatch是相应的补丁合成工具,根据两个不同版本的二进制文件，生成补丁文件.patch文件。通过bspatch使旧的apk文件与不定文件合成新的apk。 不足：要区分版本，内置及版本相同破解版apk无法增量更新，最好进行sha1sum校验，保证基础包的一致性</p></li><li><p>Zygote和System进程的启动过程<br> Zygote：<br> （1）注册Zygote的socket监听端口，应用接收启动应用程序的消息<br> （2）调用preload()方法加载系统资源，包括预加载类，Framework资源等<br> （3）调用startSystemServer()方法启动SystemServer进程<br> （4）调用runSelectLoop()方法进入监听和接收消息循环</p></li><li><p>为什么Zygote死掉之后会重启呢？<br> init进程启动后将进入无限循环以监听init.rc中启动的service状态，如发现有service退出则会重新启动该service，在init解析init.rc时，Zygote进程作为一个服务被定义，且被声明为自动重启。因此一旦Zygote进程退出，则init会收到子进程退出信号从而重新启动zygote服务，进而Zygote启动System Server。同样，在System server被Zygote作为子进程启动后，Zygote通过信号监听该子进程状态，一旦退出Zygote将会杀死自身等待init再次运行。另外system server进程将监听service manager进程，如service manager退出则杀掉自身从而导致zygote被重启</p><p> <a href="https://blog.csdn.net/cloudwu007/article/details/6915222" target="_blank" rel="noopener">system_server crash现象研究</a></p></li><li><p>了解APK的打包流程吗，描述一下？<br><a href="https://user-gold-cdn.xitu.io/2017/3/2/0df527b98e5cde954fd8406e02bda3ed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2017/3/2/0df527b98e5cde954fd8406e02bda3ed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="官方网站"></a>官方网站<br>（1）编译器将您的源代码转换成 DEX（Dalvik Executable) 文件（其中包括运行在 Android 设备上的字节码），将所有其他内容转换成已编译资源<br>（2）APK 打包器将 DEX 文件和已编译资源合并成单个 APK。不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上<br>（3）APK 打包器使用调试或发布密钥库签署您的 APK<br>（4）在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，减少其在设备上运行时的内存占用。</p><p><a href="https://juejin.im/entry/58b78d1b61ff4b006cd47e5b" target="_blank" rel="noopener">Apk 打包流程梳理</a></p></li><li><p>Android的多渠道打包你了解吗<br>渠道包就是要在安装包中添加渠道信息，也就是channel,对应不同的渠道，例如:小米市场、360市场、应用宝市场等<br>产品在不同的应用市场可能有不同的统计需求，需要为每个应用市场的Android包设定一个可以区分应用市场的标识，这个为Android包设定应用市场标识的过程就是多渠道打包。</p><p><a href="https://www.jianshu.com/p/bfdee92ab355" target="_blank" rel="noopener">Android的多渠道打包|SquirrelNote</a><br><a href="https://segmentfault.com/a/1190000004132404" target="_blank" rel="noopener">Android 多渠道打包原理和使用</a></p></li><li><p>Android的apk加固你有了解吗<br>对源Apk进行加密，然后在套上一层壳：我们拿到需要加密的Apk和自己的壳程序Apk，然后用加密算法对源Apk进行加密在将壳Apk进行合并得到新的Dex文件，最后替换壳程序中的dex文件即可，得到新的Apk,那么这个新的Apk我们也叫作脱壳程序Apk.他已经不是一个完整意义上的Apk程序了，他的主要工作是：负责解密源Apk.然后加载Apk,让其正常运行起来。</p><p>加固方式：<br>（1）proguard混淆<br>（2）签名比对验证<br>（3）ndk编译.so动态库<br>（4）代码动态加载</p><p><a href="https://segmentfault.com/a/1190000007314624#articleHeader0" target="_blank" rel="noopener">APK反逆向之二：四种基本加固方式</a><br><a href="https://blog.csdn.net/jiangwei0910410003/article/details/48415225" target="_blank" rel="noopener">Android中的Apk的加固(加壳)原理解析和实现</a><br><a href="http://www.androidchina.net/8415.html" target="_blank" rel="noopener">Android APK加固完善篇</a></p></li><li><p>打包签名流程，keystore是用来干嘛的，二次打包。包名一样，签名不一样可以同时安装吗；<br>Keytool 是一个有效的安全钥匙和证书的管理工具.<br>Java 中的 keytool.exe （位于 JDK\Bin 目录下）可以用来创建数字证书，所有的数字证书是以一条一条(采用别名区别)的形式存入证书库的中，证书库中的一条证书包含该条证书的私钥，公钥和对应的数字证书的信息。证书库中的一条证书可以导出数字证书文件，数字证书文件只包括主体信息和对应的公钥。<br>Keytool 把钥匙和证书储存到一个keystore.默任的实现keystore的是一个文件.它用一个密码保护钥匙.Keystore可理解为一个容器，存放开发者信息、私钥、公钥的容器</p><p>不可以同时安装，包名一样代表同一个应用，签名不一样只是代表了不同的开发人员</p><p><a href="https://www.jianshu.com/p/644ddb6e3d9c" target="_blank" rel="noopener">Android Keystore漫谈</a><br><a href="https://blog.csdn.net/hpu_zyh/article/details/49885563" target="_blank" rel="noopener">校验数字签名防止 apk 被二次打包 - Java层校验（大众点评为例）</a></p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>Asset目录与res目录的区别<br> （1）res目录下的资源文件会在R文件中生成对应的id，asset不会<br> （2）res目录下的文件在生成apk时，除raw（即res/raw）目录下文件不进行编译外，都会被编译成二进制文件；asset目录下的文件不会进行编译<br> （3）asset目录允许有子目录</p></li><li><p>Android中assets文件夹与raw文件夹的区别<br> （1）两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制<br> （2）res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类<br> （3）res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹<br> （4）读取res/raw下的文件资源，通过<code>InputStream is = getResources().openRawResource(R.id.filename);</code>进行写操作<br> （5）读取assets下的文件资源，通过以下方式获取输入流来进行写操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetManager am = <span class="keyword">null</span>;  </span><br><span class="line">am = getAssets();  </span><br><span class="line">InputStream is = am.open(<span class="string">"filename"</span>);</span><br></pre></td></tr></table></figure></li><li><p>如何一键更换主题（答出两种）<br> （1）将主题包（图片与配置）存到SD卡上（可通过下载或手动放入指定目录），在代码里强制从本地文件创建图片与配置文字大小、颜色等信息<br> （2）Android平台独有的主题设置功能，在values文件夹中定义若干种style，在Activity的onCreate中使用setTheme方法设置主题<br> （3）将主题包做成APK的形式，使用远程Context的方式访问主题包中的资源<br> （4）类似小米的深度主题，修改framework中Resources类获取资源的流程，将资源重定向到主题包中</p><p> <a href="https://blog.csdn.net/xingfeng2010/article/details/22854977" target="_blank" rel="noopener">Android主题切换方案总结</a></p></li><li><p>Android中开启摄像头的主要步骤<br> 调用系统的摄像头：<br> （1）创建一个File对象用于存储拍照后的照片<br> （2）通过Intent，启动系统自带的相机</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.media.action.IMAGE_CAPTURE"</span>);</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);</span><br><span class="line">startActivityForResult(intent, <span class="number">11</span>);</span><br></pre></td></tr></table></figure><p> （3）onActivityResult中处理回调的结果</p><p> 自定义Camera：<br> （1）打开相机，即实例化Camera对象，Camera camera = Camera.open();<br> （2）设置Camera的相关参数，Camera.Parameters parameters = camera.getParameters();<br> （3）打开预览，camera.setPreviewDisplay(surfaceholder); camera.startPreview();<br> （4）获取图片，这里只是从预览中获取因此使用，camera.setPreviewCallback(new Camera.PreviewCallback(){……..});<br> （5）停止预览，释放相机，camera.stopPreview();camera.release();</p><p> <a href="https://blog.csdn.net/u013869488/article/details/49853217" target="_blank" rel="noopener">android 调用Camera，获取预览帧中的图像</a></p></li><li><p>统计启动时长,标准<br> （1）物理统计：通过高速相机，从点击launcher上面的图标开始，到MainActivity的第一个可见帧，算作启动时间。<br> （2）adb 统计：<code>adb shell am start -w pageage/activityname</code><br> （3）线上版本统计：applicaiton 创建，可以从attachBaseContext()开始，得到startTime。MainActivity的第一个可视画面，onResume其实还没有看到画面，最合适的回调是onWindowFocusChanged，也就是获得焦点。但是这个回调需要做适当的过滤，就能获得endTime。所以冷启动就是两个时间差。热启动的startTime 就是MainActivity的onRestart。</p></li><li><p>画出 Android 的大体架构图<br> <a href="https://user-gold-cdn.xitu.io/2018/2/26/161d0b2cc51eff90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2018/2/26/161d0b2cc51eff90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Android体系图"></a>Android体系图</p></li><li><p>MediaPlayer的生命周期图画一下<br> <a href="http://hi.csdn.net/attachment/201005/26/521376_1274912556IBBI.gif" target="_blank" rel="noopener"><img src="http://hi.csdn.net/attachment/201005/26/521376_1274912556IBBI.gif" alt="MediaPlayer"></a>MediaPlayer</p><ul><li>Idle 状态：当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，该MediaPlayer对象处于idle状态。这两种方法的一个重要差别就是：如果在这个状态下调用了getDuration()等方法（相当于调用时机不正确），通过reset()方法进入idle状态的话会触发OnErrorListener.onError()，并且MediaPlayer会进入Error状态；如果是新创建的MediaPlayer对象，则并不会触发onError(),也不会进入Error状态。</li><li>End 状态：通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，以释放相关的软硬件组件资源，这其中有些资源是只有一份的（相当于临界资源）。如果MediaPlayer对象进入了End状态，则不会在进入任何其他状态了。</li><li>Initialized 状态：这个状态比较简单，MediaPlayer调用setDataSource()方法就进入Initialized状态，表示此时要播放的文件已经设置好了。</li><li>Prepared 状态：初始化完成之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的，只有进入Prepared状态，才表明MediaPlayer到目前为止都没有错误，可以进行文件播放。</li><li>Preparing 状态：这个状态比较好理解，主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。</li><li>Started 状态：显然，MediaPlayer一旦准备好，就可以调用start()方法，这样MediaPlayer就处于Started状态，这表明MediaPlayer正在播放文件过程中。可以使用isPlaying()测试MediaPlayer是否处于了Started状态。如果播放完毕，而又设置了循环播放，则MediaPlayer仍然会处于Started状态，类似的，如果在该状态下MediaPlayer调用了seekTo()或者start()方法均可以让MediaPlayer停留在Started状态。</li><li>Paused 状态：Started状态下MediaPlayer调用pause()方法可以暂停MediaPlayer，从而进入Paused状态，MediaPlayer暂停后再次调用start()则可以继续MediaPlayer的播放，转到Started状态，暂停状态时可以调用seekTo()方法，这是不会改变状态的。</li><li>Stop 状态：Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，需要通过prepareAsync()和prepare()回到先前的Prepared状态重新开始才可以。</li><li>PlaybackCompleted状态：文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。</li><li>Error状态：如果由于某种原因MediaPlayer出现了错误，会触发OnErrorListener.onError()事件，此时MediaPlayer即进入Error状态，及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener)可以设置该监听器。如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。</li></ul></li><li><p>Android新特性有哪些（5.0 6.0 7.0）<br> 5.0：<br> （1）全新 Material Design 设计风格<br> （2）支持多种设备（手机、平板电脑、笔记本电脑、智能电视、汽车、智能手表甚至是各种家用电子产品）<br> （3）全新的通知中心设计（在锁屏界面也可以直接查看通知消息了，用户还可以直接在锁屏的情况下就行回复或进入应用。）<br> （4）支持 64 位 ART 虚拟机<br> （5）Project Volta 电池续航改进计划： 增加了 Battery Saver 模式，在低电量的时候系统会自动降低屏幕亮度、限制自动更换背景等功能<br> （6）全新的“最近应用程序”：除了界面风格设计的改变之外，新的最近应用界面还借鉴了 Chrome 浏览器的理念，采用单独的标签展示方式。更重要的是，谷歌已经向开发者开放了 API，所以第三方开发人员可以利用这个改进为特定的应用增加全新的功能<br> （7）新的 API 支持，蓝牙 4.1、USB Audio、多人分享等其它特性<br> （8）改进搜索</p><p> 6.0：<br> （1）大量漂亮流畅的动画：安卓6.0系统增加了大量漂亮的过度动画，可以从视觉上减少卡顿感，给用户带来流畅的体验<br> （2）动态权限管理<br> （3）指纹识别（Fingerprint Support）<br> （3）APP关联（App Links）<br> （4）Android pay<br> （5）电源管理、全新的电源键菜单：一般来说，安卓的电源键菜单都是关机/重启/飞行，安卓6.0变成了关机/重启/紧急，关机和重启就不用赘述了，这个紧急模式是为了手机快没电的时候设计的，相当于飞行模式的高级版，可以关闭一切耗电应用，尽最大可能节省电量。<br> （6）相机新增专业模式：一直以来，原生的安卓相机都长被吐槽太过简单甚至简陋了，在此次的安卓6.0中，相机中新增了Pro专业模式，增加了快门速度调节和曝光度调节等新功能<br> （7）可自定义锁界面样式：支持电话、信息、相机等快捷方式在锁屏界面的定制，用户可以根据自己的喜好调整这些图标的位置，或者开启或关闭这些快捷方式<br> （8）全新的快速设置风格：不但是锁屏界面可以定制，安卓6.0还采用了全新的快速面板的色彩方案，用户可以通过更换主题换颜色<br> （9）支持快速充电的切换<br> （10）支持文件夹拖拽应用<br> （11）Now on Tap功能：“Now on Tap ”功能，是指将Google Now(一种语音助手)作为底层植入到安卓6.0系统中，用户只要只要双击home键启动Google Now，“这意味着用户随时都能启动搜索功能，目前暂时不知道这个功能进入国内会不会阉割掉<br> （12）支持RAW格式照片</p><p> 7.0（N）：<br> （1）分屏多任务支持<br> （2）画中画<br> （3）通知栏快速回复<br> （4）OpenJDK替换Java API<br> （5）采用了一项具有实时代码剖析功能的ARI JIT编译器，它能够在安卓应用程序在运行时不断提高自身的性能<br> （6）夜间深色主题模式<br> （7）流量保护模式<br> （8）改进的Doze休眠机制<br> （9）改进的Doze休眠机制<br> （10）系统级电话黑名单功能：Android7.0将电话拦截功能变成了一个系统级功能。其它应用可以调用这个拦截名单，但只有个别应用可以写入，包括拨号应用、默认的短信应用等。被拦截号码将不会出现在来电记录中，也不会出现通知。另外用户也可以通过账户体系备份和恢复这个拦截名单，以便快速导入其它设备或账号<br> （11）菜单键快速应用切换</p><p> android 8.0 有哪些新特性：<br> （1）后台执行限制<br> （2）Android 后台位置限制<br> （3）Notification channels<br> （4）自适应icon<br> （5）键盘导航(Keyboard navigation)<br> （6）Java8语言API和运行时(runtime)优化<br> （7）WebView增强</p><p> android 9.0：<br> （1）WiFi RTT功能——复杂地形精确导航<br> （2）显示剪切——支持刘海屏<br> （3）通知优化——操作更多样，内容更丰富<br> （4）支持多摄像机和相机共享<br> （5）支持图像媒体后期处理<br> （6）支持HDR VP9和HEIF<br> （7）神经网络API 1.1<br> （8）改进表单自动填充<br> （9）安全增强：Android P引入了许多新的安全功能，包括统一的指纹验证对话框和敏感交易的高确信度的用户确认。应用程序内的指纹认证UI也将会更加一致<br> （10）支持客户端侧Android备份加密<br> （11）Accessibility优化<br> （12）新的Rotation方案</p><p> <a href="https://blog.csdn.net/haovip123/article/details/54618642" target="_blank" rel="noopener">Android5.0，6.0，7.0新特性整理</a></p></li><li><p>在你平时写 App 代码时有没有什么经验可以减少方法数？谈谈其原理？<br> （1）执行Proguard：可以从应用中剔除无用的代码，但通常只在发布构建时执行它来节省宝贵的构建时间。如果对你不是问题，你也可以在调试版本中启动Proguard<br> （2）选择合适的库<br> （3）替换已存在的库<br> （4）减少库大小：只使用需要部分的库<br> （5）避免在内部类中访问外部类的私有方法/变量：当在Java内部类（包括内部匿名类）中访问外部类的私有方法/变量时，编译器会生成额外的方法，这也会增加方法数，建议编码时尽量避免。<br> （6）避免调用派生类中的未被覆盖(override)的方法</p></li><li><p>有没有遇到64k问题，为什么会出现这个问题，如何解决？<br>随着功能的增加，方法数增多，就会出现所谓的64k方法数问题，Android APK文件本质上是一个压缩文件，它包含的classes.dex文件是Dalvik字节码文件，这个dex文件中存放的就是编译后的Java代码。Dalvik可执行文件规范限制了单个.dex文件最多引用的方法数是65536个。</p><p>解决：MultiDex解决方案解决方法数超限问题</p></li><li><p>如何提高代码质量？<br>（1）命名规范<br>（2）代码规范<br>（3）注释位置、内容规范<br>（4）break语句要有。覆写时添加@Override<br>（5）显式指明操作符的优先级</p></li><li><p>Android系统的有哪些安全机制<br>两种安全机制模型：<br>（1）使用显示定义，经用户授权的应用权限控制机制。系统规范并强制各类应用程序的行为准则与权限许可。<br>（2）提供了应用程序的签名机制，实现了应用程序之间的信息信任和资源共享。</p><ul><li>内存管理 – LMK(低内存清理)<br>  （1）Android内存管理机制基于Linux的OOM(out of memory killer)机制,实现了LMK(low memory killer)机制<br>  （2）引入Android独有的共享内存机制Ashmen,该机制具有清理不在使用的共享内存区域的能力</li><li>访问控制 – DAC(自主访问控制)<br>  （1）Linux系统默认采用ACM(访问控制机制）为DAC(自主访问控制)<br>  （2）Android直接继承了Linux的访问控制机制。确保系统同文件与用户数据不受非法访问</li><li>沙箱隔离</li><li>权限声明</li><li>进程通信机制</li></ul></li><li><p>Android 应用中验证码登陆都有哪些实现方案<br>从服务器端获取图片，<br>通过短信服务，将验证码发送给客户端这两种。</p></li><li><p>定位项目中，如何选取定位方案，如何平衡耗电与实时位置的精度<br>（1）初始定位，Application 持有一个全局的公共位置对象，然后隔一定时间自动刷新位置，每次刷新成功都把新的位置信息赋值到全局的位置对象， 然后每个需要使用位置请求的地方都使用全局的位置信息进行请求。<br>该方案好处：请求的时候无需再反复定位，每次请求都使用全局的位置对象，节省时间。<br>该方案弊端：耗电，每隔一定时间自动刷新位置，对电量的消耗比较大<br>（2）按需定位，每次请求前都进行定位。这样做的好处是比较省电，而且节省资源，但是请求时间会变得相对较长</p></li><li><p>andorid 应用第二次登录实现自动登录<br>（1）第一次登陆getUserInfo里带一个长效token，该长效token用来判断用户是否登录和换取短token<br>（2）通过sp存储将长效token保存起来。<br>（3）接口请求用长效的token换取短token，短token服务端可以根据你的接口最后一次请求作为指示，超时时间为一天。<br>（4）如果短小token失效在用长效token去替换<br>（5）长效Token失效，提示用户再次登录</p></li><li><p>一条最长的短信息约占多少byte?<br>手机短信的长度是由编码决定的，根据国际标准，每条短信最多发送1120位。<br>如果发送纯英文字符，由于英文ASCII采用7位编码，所以1120位的限额可以传送1120÷7=160个字符。</p><p>一旦传送的字符中包含中文、日文、韩文等双字节字符，不论中文还是西文，不论全角还是半角，都必须采用2个字节的8位编码，因此1120÷8÷2=70个字符，即最多传送70个字</p></li><li><p>即时通讯是是怎么做的?<br>在服务端与客户端之间建立一个长连接，使用心跳包</p></li><li><p>MD5是加密方法么，Base64呢<br>MD5：是一种不可逆的摘要算法，用于生成摘要，无法逆破解到原文。常用的是生成32位摘要，用于验证数据的有效性。比如，在网络请求接口中，通过将所有的参数生成摘要，客户端和服务端采用同样的规则生成摘要，这样可以防止篡改。又如，下载文件时，通过生成文件的摘要，用于验证文件是否损坏。</p><p>Base64：属于加密算法，是可逆的，经过encode后，可以将decode得到原文。在开发中，有的公司上传图片采用的是将图片转换成Base64字符串，再上传。在做加密相关的功能时，通常会将数据进行Base64加密/解密。</p></li><li><p>Android 桌面的小部件是什么<br>AppWidget，AppWidgetProvider是Android中提供的用于实现桌面小工具的类</p></li><li><p>两个应用能使用同一个任务栈么？<br>可以，相同包名，指定同一个进程，Activity指定用一个任务栈</p></li><li><p>子线程中更新UI的方式<br>（1）用Handler，子线程发消息，通知Handler完成UI更新<br>（2）用Activity对象的runOnUiThread方法更新<br>（3）View.post(Runnable r)</p></li><li><p>Toast 只能在主线程使用吗<br>并不一定在主线程，只要 Toast show 的线程有可用 Looper 对象即可（即 Hanlder 可用），主线程默认有 Looper，其他线程默认没有</p></li><li><p>音频合成的具体步骤，以及遇到的一些问题和细节处理。<br>将输入的每段音频的某个时间点的采样点数值进行相加，即可将声音信号加入到输出的音频中。<br><a href="https://img-blog.csdn.net/20170516104655747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGFsdFNvZnR3YXJl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener"><img src="https://img-blog.csdn.net/20170516104655747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGFsdFNvZnR3YXJl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="流程图"></a>流程图</p><p>注意事项：<br>（1）需要确保A音频和B音频的采样位数一致。<br>例如A音频是16位采样位数，B音频是8位采样位数，那么这时是不能直接拼接的，需要转换成相同的采样位数，才能做后续操作。</p><p>（2）需要确保A音频和B音频的采样率一致。<br>这个在录音和歌曲拼接时要特别注意，假如录音的音频频率是16000，歌曲的音频是44100，那么两者也是不能直接拼接的，需要转换成相同的采样率，转换采样率可以使用resample库。</p><p>（3）需要确保A音频和B音频的声道数一致。<br>当然这个并不是指单声道和双声道的音频不能合成了，事实上录音音频通常是单声道的，而歌曲通常是双声道的。单声道和双声道音频合成，一般是按双声道为基准，需要将单声道音频转换成双声道音频，转换原理也简单，将单声道的采样点数据多复制一份，比如将单声道的ABCD数据转换成双声道的AABBCCDD数据</p></li><li><p>Scroller用过吗，了解它的原理吗？</p></li><li><p>Scroller有什么方法，怎么使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scroller</span> <span class="params">(Context context)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scroller</span> <span class="params">(Context context, Interpolator interpolator)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//公共方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abortAnimation</span> <span class="params">()</span>  <span class="comment">//停止动画。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span> <span class="params">()</span>  <span class="comment">//当想要知道新的位置时，调用此函数。如果返回true，表示动画还没有结束。位置改变以提供一个新的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendDuration</span> <span class="params">(<span class="keyword">int</span> extend)</span>  <span class="comment">//长滚动动画时间。此函数允许当使用setFinalX(int) or setFinalY(int) 时，卷动动作持续更长时间并且卷动更长距离。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fling</span> <span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY, <span class="keyword">int</span> minX, <span class="keyword">int</span> maxX, <span class="keyword">int</span> minY, <span class="keyword">int</span> maxY)</span>  <span class="comment">//在fling（译者注：快滑，用户按下触摸屏、快速移动后松开）手势基础上开始滚动。滚动的距离取决于fling的初速度。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forceFinished</span> <span class="params">(<span class="keyword">boolean</span> finished)</span>  <span class="comment">//强制终止的字段到特定值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getCurrX</span> <span class="params">()</span>  <span class="comment">//返回当前滚动X方向的偏移</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getCurrY</span> <span class="params">()</span>  <span class="comment">//返回当前滚动Y方向的偏移</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getDuration</span> <span class="params">()</span>  <span class="comment">//返回滚动事件的持续时间，以毫秒计算。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getFinalX</span> <span class="params">()</span>  <span class="comment">//返回滚动结束位置。仅针对“fling”手势有效  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getFinalY</span> <span class="params">()</span>  <span class="comment">//返回滚动结束位置。仅针对“fling”操作有效</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getStartX</span> <span class="params">()</span>  <span class="comment">//返回滚动起始点的X方向的偏移</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getStartY</span> <span class="params">()</span>  <span class="comment">//返回滚动起始点的Y方向的偏移</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFinished</span> <span class="params">()</span>  <span class="comment">//返回scroller是否已完成滚动。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinalX</span> <span class="params">(<span class="keyword">int</span> newX)</span>  <span class="comment">//设置scroller的X方向终止位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinalY</span> <span class="params">(<span class="keyword">int</span> newY)</span>  <span class="comment">//设置scroller的Y方向终止位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span> <span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span>  <span class="comment">//以提供的起始点和将要滑动的距离开始滚动。滚动会使用缺省值250ms作为持续时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span> <span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span>   <span class="comment">//以提供的起始点和将要滑动的距离开始滚动。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">timePassed</span> <span class="params">()</span>  <span class="comment">//返回自滚动开始经过的时间</span></span></span><br></pre></td></tr></table></figure></li><li><p>聊一聊安卓中特有的集合<br>SparseArray：SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间</p><p>ArrayMap：是一个&lt; key,value &gt;映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%</p></li><li><p>如何将Activity设置为窗口模式<br>为窗口的activity中添加属性：android:theme=”@android:style/Theme.Dialog”</p></li><li><p>两个不同的 app 之间如何交互<br>（1）广播<br>（2）AIDL<br>（3）文件共享<br>（4）SharedPreference<br>（5）ContentProvider<br>（6）Messenger<br>（7）Socket<br>（8）Intent</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于如何利用Github Pages搭建个人博客</title>
      <link href="/2020/02/07/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Github%20Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/02/07/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Github%20Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在自己利用Github搭完博客后，决定还是写一篇博客。网上很多博客都是关于搭建的，但我还是决定写这篇博客。因为我在根据网上的教程搭建时，踩了好几个坑，为了避免其他人再一次重复跟我踩入相同的坑，我会在这篇博客写出踩的坑。也正是由于网上的教程都比较详细，所以我写的也许没有网上其他博客详细，但是我会把重要的过程都写出来，会特别注意那些坑的描述，所以欢迎大家查阅。但这篇博客若要转载，请注明出处。</p><hr><h4 id="一、-安装准备软件："><a href="#一、-安装准备软件：" class="headerlink" title="一、 安装准备软件："></a>一、 安装准备软件：</h4><ul><li><p><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></p></li><li><p><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p><p>  以上直接点击链接下载就行。<br>  Node.js下载后默认安装就行，关于Git的安装及使用，除了官方文档，本人更推荐<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">廖雪峰的Git教程</a>老师的教程，通俗易懂，并让你学会所有的Git基本操作，并配置好后面相关的Git使用，所以后面所有相关Github上的操作均以你学习完Git教程为基础。</p></li></ul><hr><h4 id="二、在Github上配置Github-Pages"><a href="#二、在Github上配置Github-Pages" class="headerlink" title="二、在Github上配置Github Pages"></a>二、在Github上配置Github Pages</h4><p><a href="https://link.zhihu.com/?target=https%3A//pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。</p><p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/<a href="http://username.github.io/" target="_blank" rel="noopener">username.github.io</a>，这是特殊的命名约定。你可以通过<a href="http://username.github.io/" target="_blank" rel="noopener">username.github.io</a> 来访问你的个人主页。</p><p>这里特别提醒一下，需要注意的个人主页的网站内容是在master分支下的。</p><p><strong>廖雪峰老师</strong>已经教会你如何在github上建立一个仓库了，所以这一步也就变得很简单，我们只需建立一个新的仓库，命名为形如username.github.io就可以了，这里需要注意的是，username是你的github的帐号，也就是你自己的用户名，后面的github.io保持一样就行了，建完仓库，通过访问<a href="http://username.github.io/" target="_blank" rel="noopener">username.github.io</a> ，你访问进入这个Pages的页面，能成功跳转页面，说明你的github上的配置也就基本完成了，当然，由于还没有推送博客上来，所以都还是空的。</p><hr><h4 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h4><p>在你的电脑中任何一个你觉得合适的位置，新建一个文件夹，文件夹的命名没有什么硬性要求，但一般我们都用Hexo来命名，因为在这个文件夹下，我们要安装Hexo，用于博客。</p><p>建立好文件夹后，在文件夹里右键打开Git Bash，相信这一点廖雪峰老师已经教会你了，打开Git Bash后，输入以下命令：</p><p>先安装Hexo：</p><blockquote><p>npm install -g hexo</p></blockquote><p>初始化Hexo文件夹：</p><blockquote><p>hexo init</p></blockquote><p>这步过后，你的文件夹里会生成相应的Hexo的相关文件<br><a href="http://jycloud.9uads.com/web/GetObject.aspx?filekey=b6f92cee3776a76d6d529a60df428026" target="_blank" rel="noopener"><img src="http://jycloud.9uads.com/web/GetObject.aspx?filekey=b6f92cee3776a76d6d529a60df428026" alt="img"></a><br>接下来，你可以先用命令hexo -v查询hexo是否安装好，出现如下的图片便表示安装好(<strong>注意</strong>：Hexo只需要安装一次就可以了)<br><a href="http://ojplrudb4.bkt.clouddn.com/QQ截图20170302215635.png" target="_blank" rel="noopener"><img src="http://ojplrudb4.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170302215635.png" alt="img"></a><br>接下来我们现在本地上查询，本地是否已经搭建好了博客<br>输入以下命令：</p><blockquote><p>hexo -g<br>hexo -s</p></blockquote><p>然后打开你的浏览器，输入<a href="localhost:4000/" target="_blank" rel="noopener">localhost:4000/</a>来查看你的博客，出现如下图中的样子说明你的本地博客就搭建好了。<br><a href="http://ojplrudb4.bkt.clouddn.com/QQ截图20170302220110.png" target="_blank" rel="noopener"><img src="http://ojplrudb4.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170302220110.png" alt="img"></a></p><p>一下是Hexo的几个常用命令：</p><blockquote><p>新建文章：hexo new<br>新建页面：hexo new page<br>生成静态页面至public：hexo generate<br>开启预览访问端口：hexo server<br>将。<br>deploy目录部署到github：hexo deploy<br>生成+部署：hexo d -g<br>预览+部署：hexo s -g</p></blockquote><p>更多详情可以访问官方文档<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></p><hr><h4 id="四、部署Hexo到Github-Pages"><a href="#四、部署Hexo到Github-Pages" class="headerlink" title="四、部署Hexo到Github Pages"></a><em>四、部署Hexo到Github Pages</em></h4><p><strong>这一步及其重要，很多人搭博客的时候就出现了本地博客搭好了，Github上的仓库这些也搭好了，但就是本地的博客无法推送到云端，这就是这一步出现了问题，然而很多博客都没有对这一点着重讲解，所以这一步一定要细心。</strong></p><p>首先进入你的Hexo文件夹(就是你搭博客所用的文件夹)，然后打开Git Bash，首先我们需要安装一个扩展，这个扩展用于Hexo与Github连接，前面所提到的问题也差不多是因为这个扩展没装。</p><p>输入命令：</p><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><p><strong>注意，这里一定要把这个扩展安装好，否则始终不能推到云端上去，重要的事说三遍。</strong></p><p>然后我们需要配置一下Hexo文件夹里的文件，修改项目目录的_config.yml，找到deploy，作如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:jiji262/jiji262.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><em>需要注意： <strong>repo:</strong>后面的是你建立博客的仓库名，在这里你只需要将用户名和仓库名改成你的就行了。</em></p><hr><h4 id="五、将本地博客推送到Github-Pages上，并在云端访问。"><a href="#五、将本地博客推送到Github-Pages上，并在云端访问。" class="headerlink" title="五、将本地博客推送到Github Pages上，并在云端访问。"></a>五、将本地博客推送到Github Pages上，并在云端访问。</h4><p>输入以下命令：</p><blockquote><p>hexo -g<br>hexo -d</p></blockquote><p>推送成功后，在Github上能查询你的推送记录，访问cnfeat.github.io就可以查看你的博客了。</p><hr><h4 id="六、进阶性的操作"><a href="#六、进阶性的操作" class="headerlink" title="六、进阶性的操作"></a>六、进阶性的操作</h4><p>关于将域名和自己的博客结合，如何购买域名这类问题，我想我不需要作太多的描述，网上的资源很多，在<a href="https://link.zhihu.com/?target=http%3A//www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">如何搭建一个独立博客——简明Github Pages与Hexo教程</a>这篇博客中已有一定的描述。<br>如果你想把你的博客修改得更好看一点，你可以克隆别人的主题，也可以自己修改成自己所喜欢的样子，在这里克隆主题这一块我就不详细讲解，我给你一些博客自己去查看。</p><blockquote><ul><li><a href="https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwj84NfB7rfSAhXo7YMKHV7zDfsQFggbMAA&url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F20760507&usg=AFQjCNHWtLDmniPQ_AOcJM-SnDlSzG_QxA" target="_blank" rel="noopener">手把手教你使用Hexo + Github Pages搭建个人独立博客</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li></ul></blockquote><p>这两篇博客也十分优秀，可以看一下，当然，里面肯定有主题的克隆。</p><hr><p>至于如何写博客，并将发表，在此我也不多言，很多优秀的博客都已明确写出，也可以看一下我给出的参考链接</p><h3 id="参考链接并致谢以下博主"><a href="#参考链接并致谢以下博主" class="headerlink" title="参考链接并致谢以下博主"></a>参考链接并致谢以下博主</h3><blockquote><ul><li><a href="https://link.zhihu.com/?target=https%3A//hexo.io/" target="_blank" rel="noopener">Hexo主页</a></li><li><a href="https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwj84NfB7rfSAhXo7YMKHV7zDfsQFggbMAA&url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F20760507&usg=AFQjCNHWtLDmniPQ_AOcJM-SnDlSzG_QxA" target="_blank" rel="noopener">手把手教你使用Hexo + Github Pages搭建个人独立博客</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li><li><a href="http://www.pchou.info/ssgithubPage/2013-01-03-build-github-blog-page-01.html" target="_blank" rel="noopener">Github建站系列教程</a></li></ul></blockquote><hr><p>若有什么不对之处，还请多多指教。</p><p><strong>希望大家多多支持！你的鼓励便是我的动力！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于滑动冲突踩的那些坑以及解决办法</title>
      <link href="/2020/02/07/%E5%85%B3%E4%BA%8E%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%B8%A9%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2020/02/07/%E5%85%B3%E4%BA%8E%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%B8%A9%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="关于滑动冲突踩的那些坑以及解决办法"><a href="#关于滑动冲突踩的那些坑以及解决办法" class="headerlink" title="关于滑动冲突踩的那些坑以及解决办法"></a>关于滑动冲突踩的那些坑以及解决办法</h1><p>这次博客讲的内容比较多，因为学习自定义View时踩的坑比较多，自定义View同时也自定义了ViewGroup，并踩了滑动冲突，所以一次性简单的说一下自定义，当然重点在冲突解决。</p><p>先给出<a href="https://github.com/PengHesheng/AndroidLearnDemo/tree/master/MyApplication" target="_blank" rel="noopener">Demo地址</a>，我的<a href="http://www.penghesheng.com/" target="_blank" rel="noopener">博客</a></p><blockquote><p>1、View<br>2、ViewGroup<br>3、自定义View和ViewGroup<br>4、冲突解决</p></blockquote><hr><h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><blockquote><p><strong>官方解释：</strong>　<em>public class View extends Object implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource</em><br><em>This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for drawing and event handling. View is the base class for widgets, which are used to create interactive UI components (buttons, text fields, etc.). The ViewGroup subclass is the base class for layouts, which are invisible containers that hold other Views (or other ViewGroups) and define their layout properties.</em><br>这个类代表了用户界面组件的基本构建块。视图在屏幕上占据一个矩形区域，负责绘图和事件处理。视图是小部件的基类，它用于创建交互式UI组件(按钮、文本字段等)。ViewGroup子类是布局的基类，它们是保存其他视图(或其他视图组)的无形容器，并定义它们的布局属性。（<strong>注：</strong> <em>此翻译根据有道词典参考，后续的翻译均是</em>）</p></blockquote><blockquote><p>说得通俗点，view就是我们的布局，view就是我们所看到的，而<strong>自定义view</strong>时，我们继承View类，实现其中的一些方法，比如官方解释：To implement a custom view, you will usually begin by providing overrides for some of the standard methods that the framework calls on all views. You do not need to override all of these methods. In fact, you can start by just overriding onDraw(android.graphics.Canvas).要实现自定义视图，通常首先要为框架调用所有视图的一些标准方法提供覆盖。您不需要覆盖所有这些方法。实际上，您可以从重写onDraw(android.graphics.Canvas)开始。</p></blockquote><h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><blockquote><p><strong>官方解释：</strong> <em>public abstract class ViewGroup extends View implements ViewParent, ViewManager.</em><br><em>A ViewGroup is a special view that can contain other views (called children.) The view group is the base class for layouts and views containers. This class also defines the ViewGroup.LayoutParams class which serves as the base class for layouts parameters.</em><br>ViewGroup是可以包含其他视图(称为children)的特殊视图。视图组是布局和视图容器的基类。这个类还定义了ViewGroup。LayoutParams类作为布局参数的基类。</p></blockquote><hr><blockquote><p><strong>简单了解一下view和viewGroup的区别：</strong><br><em>ViewGroup继承自View,是一种特殊的View，它可以装其他的Views(或其他的ViewGroup)。ViewGroup是布局(layouts)和views containers的父类。它的直接子类有： FrameLayout, GridLayout, LinearLayout等等。Example: LineraLayout</em><br><em>View类代表的是UI components的基本的构建块。a view 占据屏幕的一块方形区域，负责绘制和事件处理。View是用来创建交互性的UI组件(如：按钮，文本框等等)的 widgets的父类。Example:Button</em></p></blockquote><p><strong>说的通俗点就是一个布局可以包含其他的布局和一些widgets。</strong></p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>先看最终的效果图：<br><img src="https://img-blog.csdnimg.cn/20190513185053751.gif" alt="SwipeConflict2"></p><p>首先先明确一下我们要干什么，现在我们模仿一下QQ的抽屉式侧滑（此处就是根据鸿洋大神的仿QQ5.0侧滑来做的），这里我们因为要实现抽屉式的侧滑，我们就不能用官方的侧滑，因为那个没有抽屉式的动画。当然首先考虑到的就是HorizontalScrollView这个横向的滚动，毕竟我们的抽屉式就是横向滑动的，效果图如下<br><img src="https://img-blog.csdnimg.cn/20190513185202475.gif" alt="HorizontalScrollView"><br>，可以看到，虽然的却有横向的滑动，但是并没有想象中的那种抽屉式，就只有横向的滑动，这就需要用到我们的自定义ViewGroup了。为什么这里说是自定义ViewGroup呢？你可以再看一看之前简单的说了一下View和ViewGroup的区别，我们这次最外层的这个抽屉式滑动时最外层的布局，然后里面放了子布局，所以从这一方面来说，这个抽屉式的布局是一个ViewGroup，当然，你也可以从代码中看见，我们直接继承了HorizontalScrollView，虽然这里我们没有直接继承ViewGroup，但是HorizontalScrollView是继承了FrameLayout，而FrameLayout才是继承的ViewGroup，所以从根本上来将，我们的抽屉式布局就是继承的ViewGroup，所以它也算一个ViewGroup，至于为什么不直接继承ViewGroup呢？这个也是可以的，这里为了少写点代码量，我就直接继承了HorizontalScrollView，因为HorizontalScrollView中很多属性是我们直接需要的，所以可以不用去继承ViewGroup，那么我们接下来就先看一下自定义的ViewGroup吧，</p><p>下面直接看代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.a14512.swipeconflictdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.TypedArray;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.DisplayMetrics;</span><br><span class="line"><span class="keyword">import</span> android.util.TypedValue;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.HorizontalScrollView;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 14512 on 2017/9/5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHorizontalScrollView</span> <span class="keyword">extends</span> <span class="title">HorizontalScrollView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinearLayout mWapper;</span><br><span class="line">    <span class="keyword">private</span> ViewGroup mMenu;  <span class="comment">//菜单区</span></span><br><span class="line">    <span class="keyword">private</span> ViewGroup mContent;  <span class="comment">//内容区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mScreenWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMenuWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMenuRightPadding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> once = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isOpen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未使用自定义View时调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义View时才调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defStyleAttr</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setHorizontalScrollBarEnabled(<span class="keyword">false</span>);</span><br><span class="line">        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SlidingMenu, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> initSize = (<span class="keyword">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">50</span>, displayMetrics);</span><br><span class="line">        mMenuRightPadding = a.getDimensionPixelSize(R.styleable.SlidingMenu_rightPadding, initSize);</span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        mScreenWidth = displayMetrics.widthPixels;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置自己的宽和高</span></span><br><span class="line"><span class="comment">     * 设置子view的宽和高</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!once) &#123;</span><br><span class="line">            mWapper = (LinearLayout) getChildAt(<span class="number">0</span>);</span><br><span class="line">            mMenu = (ViewGroup) mWapper.getChildAt(<span class="number">0</span>);</span><br><span class="line">            mContent = (ViewGroup) mWapper.getChildAt(<span class="number">1</span>);</span><br><span class="line">            mMenuWidth = mMenu.getLayoutParams().width = mScreenWidth - mMenuRightPadding;</span><br><span class="line">            mContent.getLayoutParams().width = mScreenWidth;</span><br><span class="line">            once = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过设置偏移量来将menu隐藏</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scrollTo(mMenuWidth, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">//隐藏在左边的宽度</span></span><br><span class="line">                <span class="keyword">int</span> scrollX= getScrollX();</span><br><span class="line">                <span class="keyword">if</span> (scrollX &gt;= mMenuWidth / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.smoothScrollTo(mMenuWidth, <span class="number">0</span>);  <span class="comment">//隐藏时有动画</span></span><br><span class="line">                    isOpen = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.smoothScrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    isOpen = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滚动事调用</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> oldl, <span class="keyword">int</span> oldt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onScrollChanged(l, t, oldl, oldt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> scale = l * <span class="number">1.0f</span> / mMenuWidth;  <span class="comment">//1~0</span></span><br><span class="line">        <span class="keyword">float</span> leftAlpha = <span class="number">0.6f</span> + <span class="number">0.4f</span> * (<span class="number">1.0f</span> - scale);  <span class="comment">//透明度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//属性动画TranslationX，默认动画有时间限制，需要自己去设置时间</span></span><br><span class="line">        mMenu.animate().translationX(mMenuWidth * scale * <span class="number">0.8f</span>).alpha(leftAlpha).setDuration(<span class="number">0</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开菜单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.smoothScrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        isOpen = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭菜单</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.smoothScrollTo(mMenuWidth, <span class="number">0</span>);</span><br><span class="line">        isOpen = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换菜单</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">            closeMenu();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            openMenu();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信看过<strong>Android开发艺术探索</strong>的人都知道这些事怎么回事了，如果还有不太了解的人，就去看看<strong>Android开发艺术探索</strong>和<a href="http://www.imooc.com/learn/211" target="_blank" rel="noopener"><strong>鸿洋大神的视频</strong></a>，一些解释代码里面注释得也很清楚了，相信大家都看得懂，这些是自定义ViewGroup（简单说就是自定义View）的基本用法，一些最简单的用法。这个时候，在鸿洋大神的指导下，这个抽屉式的滑动我们基本就完成了，没错就是这么简单。</p><p>来看一下效果图：<br><img src="https://img-blog.csdnimg.cn/20190513185237898.gif" alt="MyHorizontalScrollView"></p><p>抽屉式完成</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>细心的人都应该会发现，我们右侧的主布局中添加了很多横向流的RecyclerView，但是会注意到一点，不管我在右侧主布局中哪里向右滑动，都会把侧滑拉出来，而且当我想去滑动RecyclerView时，却发现，这些Item都不能滑动，滑动的时候就只是把左侧的菜单拉出来了，这就是我们接下来要讲的滑动冲突了。</p><p>不管是<strong>Android开发艺术探索</strong>还是网上的各种博客，关于解决滑动冲突的不在少数，而滑动冲突常见的就那么几种：不同向的冲突、同向的冲突、两者的结合形成的复合型冲突，在<strong>Android开艺术探索</strong>中提供一些通用的解决方法，<em>外部拦截和内部拦截</em>，书中也比较详细的用例子说明了冲突的解决方法，当然，可以总结出，简单的是外部拦截，内部拦截比较复杂，书上的Demo是网上很多博客使用到的，但博客大多数都是关于垂直方向上的ListView和ScrollView的嵌套产生的滑动冲突，这就跟我们本次的很类似，但是具体情况又有所不同，下面我们开始解决滑动冲突。</p><p>首先我们尝试使用外部拦截，代码入下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.a14512.swipeconflictdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.TypedArray;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.DisplayMetrics;</span><br><span class="line"><span class="keyword">import</span> android.util.TypedValue;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.HorizontalScrollView;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 14512 on 2017/9/5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHorizontalScrollView</span> <span class="keyword">extends</span> <span class="title">HorizontalScrollView</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OnGiveUpTouchEventListener mGiveUpTouchEventListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinearLayout mWapper;</span><br><span class="line">    <span class="keyword">private</span> ViewGroup mMenu;  <span class="comment">//菜单区</span></span><br><span class="line">    <span class="keyword">private</span> ViewGroup mContent;  <span class="comment">//内容区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mScreenWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMenuWidth</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMenuRightPadding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> once = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isOpen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未使用自定义View时调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义View时才调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defStyleAttr</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setHorizontalScrollBarEnabled(<span class="keyword">false</span>);</span><br><span class="line">        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SlidingMenu, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> initSize = (<span class="keyword">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">50</span>, displayMetrics);</span><br><span class="line">        mMenuRightPadding = a.getDimensionPixelSize(R.styleable.SlidingMenu_rightPadding, initSize);</span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        mScreenWidth = displayMetrics.widthPixels;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置自己的宽和高</span></span><br><span class="line"><span class="comment">     * 设置子view的宽和高</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!once) &#123;</span><br><span class="line">            mWapper = (LinearLayout) getChildAt(<span class="number">0</span>);</span><br><span class="line">            mMenu = (ViewGroup) mWapper.getChildAt(<span class="number">0</span>);</span><br><span class="line">            mContent = (ViewGroup) mWapper.getChildAt(<span class="number">1</span>);</span><br><span class="line">            mMenuWidth = mMenu.getLayoutParams().width = mScreenWidth - mMenuRightPadding;</span><br><span class="line">            mContent.getLayoutParams().width = mScreenWidth;</span><br><span class="line">            once = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过设置偏移量来将menu隐藏</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scrollTo(mMenuWidth, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">//隐藏在左边的宽度</span></span><br><span class="line">                <span class="keyword">int</span> scrollX= getScrollX();</span><br><span class="line">                <span class="keyword">if</span> (scrollX &gt;= mMenuWidth / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.smoothScrollTo(mMenuWidth, <span class="number">0</span>);  <span class="comment">//隐藏时有动画</span></span><br><span class="line">                    isOpen = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.smoothScrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    isOpen = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnGiveUpTouchEventListener</span><span class="params">(OnGiveUpTouchEventListener l)</span> </span>&#123;</span><br><span class="line">        mGiveUpTouchEventListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件分发，冲突处理，外部拦截</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">//处理逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (mGiveUpTouchEventListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mGiveUpTouchEventListener.giveUpTouchEvent(ev)) &#123;</span><br><span class="line">                        intercepted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滚动事调用</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> oldl, <span class="keyword">int</span> oldt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onScrollChanged(l, t, oldl, oldt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> scale = l * <span class="number">1.0f</span> / mMenuWidth;  <span class="comment">//1~0</span></span><br><span class="line">        <span class="keyword">float</span> leftAlpha = <span class="number">0.6f</span> + <span class="number">0.4f</span> * (<span class="number">1.0f</span> - scale);  <span class="comment">//透明度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//属性动画TranslationX，默认动画有时间限制，需要自己去设置时间</span></span><br><span class="line">        mMenu.animate().translationX(mMenuWidth * scale * <span class="number">0.8f</span>).alpha(leftAlpha).setDuration(<span class="number">0</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开菜单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.smoothScrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        isOpen = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭菜单</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.smoothScrollTo(mMenuWidth, <span class="number">0</span>);</span><br><span class="line">        isOpen = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换菜单</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">            closeMenu();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            openMenu();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是为了使用外部拦截解决滑动冲突的接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnGiveUpTouchEventListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">giveUpTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外层的Activity去实现接口代码逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.a14512.swipeconflictdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.LinearLayoutManager;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">MyHorizontalScrollView</span>.<span class="title">OnGiveUpTouchEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RecyclerView in_theaters_recycler_view;</span><br><span class="line">    <span class="keyword">private</span> RecyclerView coming_soon_recycler_view;</span><br><span class="line">    <span class="keyword">private</span> RecyclerView us_box_recycler_view;</span><br><span class="line">    <span class="keyword">private</span> RecyclerView top250_recycler_view;</span><br><span class="line">    <span class="keyword">private</span> RecyclerView weekly_recycler_view;</span><br><span class="line">    <span class="keyword">private</span> RecyclerView new_movies_recycler_view;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> MyHorizontalScrollView myHorizontalScrollView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initView();</span><br><span class="line">        initData();</span><br><span class="line">        initRecyclerView();</span><br><span class="line">        setAdapter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.setStrings(strings);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">        in_theaters_recycler_view.setAdapter(adapter);</span><br><span class="line">        coming_soon_recycler_view.setAdapter(adapter);</span><br><span class="line">        us_box_recycler_view.setAdapter(adapter);</span><br><span class="line">        top250_recycler_view.setAdapter(adapter);</span><br><span class="line">        weekly_recycler_view.setAdapter(adapter);</span><br><span class="line">        new_movies_recycler_view.setAdapter(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">            strings.add(<span class="string">"I am a item"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in_theaters_recycler_view = (RecyclerView) findViewById(R.id.in_theaters_recycler_view);</span><br><span class="line">        coming_soon_recycler_view = (RecyclerView) findViewById(R.id.coming_soon_recycler_view);</span><br><span class="line">        us_box_recycler_view = (RecyclerView) findViewById(R.id.us_box_recycler_view);</span><br><span class="line">        top250_recycler_view = (RecyclerView) findViewById(R.id.top250_recycler_view);</span><br><span class="line">        weekly_recycler_view = (RecyclerView) findViewById(R.id.weekly_recycler_view);</span><br><span class="line">        new_movies_recycler_view = (RecyclerView) findViewById(R.id.new_movies_recycler_view);</span><br><span class="line">        myHorizontalScrollView.setOnGiveUpTouchEventListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRecyclerView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinearLayoutManager layoutManager1 = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">        layoutManager1.setOrientation(LinearLayoutManager.HORIZONTAL);</span><br><span class="line">        LinearLayoutManager layoutManager2 = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">        layoutManager2.setOrientation(LinearLayoutManager.HORIZONTAL);</span><br><span class="line">        LinearLayoutManager layoutManager3 = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">        layoutManager3.setOrientation(LinearLayoutManager.HORIZONTAL);</span><br><span class="line">        LinearLayoutManager layoutManager4 = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">        layoutManager4.setOrientation(LinearLayoutManager.HORIZONTAL);</span><br><span class="line">        LinearLayoutManager layoutManager5 = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">        layoutManager5.setOrientation(LinearLayoutManager.HORIZONTAL);</span><br><span class="line">        LinearLayoutManager layoutManager6 = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">        layoutManager6.setOrientation(LinearLayoutManager.HORIZONTAL);</span><br><span class="line">        new_movies_recycler_view.setLayoutManager(layoutManager1);</span><br><span class="line">        in_theaters_recycler_view.setLayoutManager(layoutManager2);</span><br><span class="line">        coming_soon_recycler_view.setLayoutManager(layoutManager3);</span><br><span class="line">        us_box_recycler_view.setLayoutManager(layoutManager4);</span><br><span class="line">        top250_recycler_view.setLayoutManager(layoutManager5);</span><br><span class="line">        weekly_recycler_view.setLayoutManager(layoutManager6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">giveUpTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (拦截事件)  <span class="comment">//此处为伪代码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以知道，当我们需要拦截的时候，我们就在接口中的方法giveUpTouchEvent去判断是否需要拦截，需要接返回true去拦截，这个时候我们要根据RecyclerView中的第一个Item是否在第一个，如果在，我们就拦截，此时的滑动处理就由外层MyHorizontalScrollView去处理，当到达了最后一个时，也交给MyHorizontalScrollView去处理。（<strong>注意：这里是我踩的一个很大的坑</strong>）在处理这个逻辑过程中，我们会很容易的发现，这个逻辑是很容易就写出来的，但是，运行过程中，会很轻易的发现程序崩溃了，因为我们去判断Item的位置时会用到RecyclerView，但是程序崩溃的原因就是RecyclerView为空，这也就导致了这里不太方便使用这种拦截方式，所以接下来我们试一下内部拦截。</p><p>内部拦截需要重写RecyclerView，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.example.a14512.swipeconflictdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 14512 on 2017/9/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecyclerView</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastX;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecyclerView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecyclerView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecyclerView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            getParent().getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">            <span class="keyword">if</span> (lastX &gt; x) &#123;</span><br><span class="line">                <span class="comment">// 如果是水平向左滑动，且不能滑动了，则返回给上一层view处理</span></span><br><span class="line">                <span class="keyword">if</span> (!canScrollHorizontally(<span class="number">1</span>)) &#123;</span><br><span class="line">                    getParent().getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; lastX) &#123;</span><br><span class="line">                <span class="comment">// 如果是水平向右滑动，且不能滑动了，则返回给上一层view处理</span></span><br><span class="line">                <span class="keyword">if</span> (!canScrollHorizontally(-<span class="number">1</span>)) &#123;</span><br><span class="line">                    getParent().getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastX = ev.getX();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着外层布局也有相应的一些改变，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.a14512.swipeconflictdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.TypedArray;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.DisplayMetrics;</span><br><span class="line"><span class="keyword">import</span> android.util.TypedValue;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.HorizontalScrollView;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 14512 on 2017/9/5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHorizontalScrollView</span> <span class="keyword">extends</span> <span class="title">HorizontalScrollView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinearLayout mWapper;</span><br><span class="line">    <span class="keyword">private</span> ViewGroup mMenu;  <span class="comment">//菜单区</span></span><br><span class="line">    <span class="keyword">private</span> ViewGroup mContent;  <span class="comment">//内容区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mScreenWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMenuWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMenuRightPadding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> once = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isOpen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未使用自定义View时调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义View时才调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defStyleAttr</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setHorizontalScrollBarEnabled(<span class="keyword">false</span>);</span><br><span class="line">        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SlidingMenu, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> initSize = (<span class="keyword">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">50</span>, displayMetrics);</span><br><span class="line">        mMenuRightPadding = a.getDimensionPixelSize(R.styleable.SlidingMenu_rightPadding, initSize);</span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        mScreenWidth = displayMetrics.widthPixels;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置自己的宽和高</span></span><br><span class="line"><span class="comment">     * 设置子view的宽和高</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!once) &#123;</span><br><span class="line">            mWapper = (LinearLayout) getChildAt(<span class="number">0</span>);</span><br><span class="line">            mMenu = (ViewGroup) mWapper.getChildAt(<span class="number">0</span>);</span><br><span class="line">            mContent = (ViewGroup) mWapper.getChildAt(<span class="number">1</span>);</span><br><span class="line">            mMenuWidth = mMenu.getLayoutParams().width = mScreenWidth - mMenuRightPadding;</span><br><span class="line">            mContent.getLayoutParams().width = mScreenWidth;</span><br><span class="line">            once = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过设置偏移量来将menu隐藏</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scrollTo(mMenuWidth, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">//隐藏在左边的宽度</span></span><br><span class="line">                <span class="keyword">int</span> scrollX= getScrollX();</span><br><span class="line">                <span class="keyword">if</span> (scrollX &gt;= mMenuWidth / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.smoothScrollTo(mMenuWidth, <span class="number">0</span>);  <span class="comment">//隐藏时有动画</span></span><br><span class="line">                    isOpen = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.smoothScrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    isOpen = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件分发，冲突处理，外部拦截</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//此处为内部拦截时需要</span></span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onTouchEvent(ev);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滚动事调用</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> oldl, <span class="keyword">int</span> oldt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onScrollChanged(l, t, oldl, oldt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> scale = l * <span class="number">1.0f</span> / mMenuWidth;  <span class="comment">//1~0</span></span><br><span class="line">        <span class="keyword">float</span> leftAlpha = <span class="number">0.6f</span> + <span class="number">0.4f</span> * (<span class="number">1.0f</span> - scale);  <span class="comment">//透明度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//属性动画TranslationX，默认动画有时间限制，需要自己去设置时间</span></span><br><span class="line">        mMenu.animate().translationX(mMenuWidth * scale * <span class="number">0.8f</span>).alpha(leftAlpha).setDuration(<span class="number">0</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开菜单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.smoothScrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        isOpen = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭菜单</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.smoothScrollTo(mMenuWidth, <span class="number">0</span>);</span><br><span class="line">        isOpen = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换菜单</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">            closeMenu();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            openMenu();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，内部拦截时，外层就只改变了几行代码，接下来我们看效果：<br><img src="https://img-blog.csdnimg.cn/20190513185350242.gif" alt="MyHorizontalScrollView2"></p><p>可以看到，RecyclerView的冲突解决了，从内部完美的解决了，但是又出现了一个新的问题，主布局的ScrollView好像不能滑动了，从截图中可以看出来，ScrollView的上下滑动完全失效了，这时候我们就得去分析了，我们先看MyRecyclerView这个自定义的View，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lastX &gt; x) &#123;</span><br><span class="line">               <span class="comment">// 如果是水平向左滑动，且不能滑动了，则返回给上一层view处理</span></span><br><span class="line">               <span class="keyword">if</span> (!canScrollHorizontally(<span class="number">1</span>)) &#123;</span><br><span class="line">                   getParent().getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; lastX) &#123;</span><br><span class="line">               <span class="comment">// 如果是水平向右滑动，且不能滑动了，则返回给上一层view处理</span></span><br><span class="line">               <span class="keyword">if</span> (!canScrollHorizontally(-<span class="number">1</span>)) &#123;</span><br><span class="line">                   getParent().getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里的判断逻辑没啥问题，达到了我们预期的效果，但是注意看这一行代码<br><code>getParent().getParent().requestDisallowInterceptTouchEvent(false);</code><br>这行代码表示的返回给自己的父布局View处理事件，那我们又去看看Layout的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginLeft</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:text</span>=<span class="string">"@string/in_theaters"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/more_in_theaters"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginRight</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:text</span>=<span class="string">"@string/tv_more"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.example.a14512.swipeconflictdemo.MyRecyclerView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/in_theaters_recycler_view"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"#f0f0f0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginLeft</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:text</span>=<span class="string">"@string/coming_soon"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/more_coming_soon"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginRight</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:text</span>=<span class="string">"@string/tv_more"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.example.a14512.swipeconflictdemo.MyRecyclerView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/coming_soon_recycler_view"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"#f0f0f0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginLeft</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:text</span>=<span class="string">"@string/us_box"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/more_us_box"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginRight</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:text</span>=<span class="string">"@string/tv_more"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.example.a14512.swipeconflictdemo.MyRecyclerView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/us_box_recycler_view"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"#f0f0f0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginLeft</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:text</span>=<span class="string">"@string/top250"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/more_top250"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginRight</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:text</span>=<span class="string">"@string/tv_more"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.example.a14512.swipeconflictdemo.MyRecyclerView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/top250_recycler_view"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"#f0f0f0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginLeft</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:text</span>=<span class="string">"@string/weekly"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/more_weekly"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginRight</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:text</span>=<span class="string">"@string/tv_more"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.example.a14512.swipeconflictdemo.MyRecyclerView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/weekly_recycler_view"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"#f0f0f0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginLeft</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:text</span>=<span class="string">"@string/new_movies"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:textSize</span>=<span class="string">"16sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/more_new_movies"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginRight</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:text</span>=<span class="string">"@string/tv_more"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">com.example.a14512.swipeconflictdemo.MyRecyclerView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/new_movies_recycler_view"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"#f0f0f0"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"I am is a text1"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textSize</span>=<span class="string">"24sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"I am is a text2"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textSize</span>=<span class="string">"24sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"I am is a text3"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textSize</span>=<span class="string">"24sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"I am is a text4"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:textSize</span>=<span class="string">"24sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现，MyRecyclerView的父布局是ScrollView，那么事件就返回给了ScrollView，而ScrollView我们并没有去处理这个事件，所以ScrollView又返回给了它的父布局，就这样一层一层的返回，最终到了MyHorizontalScrollView，然后事件被处理，这就解决了们可以侧滑 问题，但是为什么ScrollView失效了呢？其实仔细分析，这时候虽然内部拦截了，但外部的ScrollView与MyHorizontalScrollView由冲突了，这个冲突又是我们开头提到的I一种不同向的冲突，所以这个时候我们又需要解决这个。如果我们继续采用内部拦截去重写一个ScrollView，这无疑是增加代码量的。这时候我们可以考虑一下外部拦截，去直接处理外部的上下滑动，<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.example.a14512.swipeconflictdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.TypedArray;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.DisplayMetrics;</span><br><span class="line"><span class="keyword">import</span> android.util.TypedValue;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.HorizontalScrollView;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 14512 on 2017/9/5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHorizontalScrollView</span> <span class="keyword">extends</span> <span class="title">HorizontalScrollView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinearLayout mWapper;</span><br><span class="line">    <span class="keyword">private</span> ViewGroup mMenu;  <span class="comment">//菜单区</span></span><br><span class="line">    <span class="keyword">private</span> ViewGroup mContent;  <span class="comment">//内容区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mScreenWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMenuWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别记录上次滑动的坐标（onInterceptTouchEvent）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastXIntercept = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastYIntercept = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMenuRightPadding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> once = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isOpen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未使用自定义View时调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义View时才调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defStyleAttr</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHorizontalScrollView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setHorizontalScrollBarEnabled(<span class="keyword">false</span>);</span><br><span class="line">        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SlidingMenu, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> initSize = (<span class="keyword">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">50</span>, displayMetrics);</span><br><span class="line">        mMenuRightPadding = a.getDimensionPixelSize(R.styleable.SlidingMenu_rightPadding, initSize);</span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*   WindowManager windowManager = (WindowManager) context.getSystemServiceName(Class.forName(Context.WINDOW_SERVICE));</span></span><br><span class="line"><span class="comment">        DisplayMetrics outMetrics = new DisplayMetrics();</span></span><br><span class="line"><span class="comment">        windowManager.getDefaultDisplay().getMetrics(outMetrics);*/</span></span><br><span class="line"></span><br><span class="line">        mScreenWidth = displayMetrics.widthPixels;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置自己的宽和高</span></span><br><span class="line"><span class="comment">     * 设置子view的宽和高</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!once) &#123;</span><br><span class="line">            mWapper = (LinearLayout) getChildAt(<span class="number">0</span>);</span><br><span class="line">            mMenu = (ViewGroup) mWapper.getChildAt(<span class="number">0</span>);</span><br><span class="line">            mContent = (ViewGroup) mWapper.getChildAt(<span class="number">1</span>);</span><br><span class="line">            mMenuWidth = mMenu.getLayoutParams().width = mScreenWidth - mMenuRightPadding;</span><br><span class="line">            mContent.getLayoutParams().width = mScreenWidth;</span><br><span class="line">            once = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过设置偏移量来将menu隐藏</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scrollTo(mMenuWidth, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">//隐藏在左边的宽度</span></span><br><span class="line">                <span class="keyword">int</span> scrollX= getScrollX();</span><br><span class="line">                <span class="keyword">if</span> (scrollX &gt;= mMenuWidth / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.smoothScrollTo(mMenuWidth, <span class="number">0</span>);  <span class="comment">//隐藏时有动画</span></span><br><span class="line">                    isOpen = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.smoothScrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    isOpen = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件分发，冲突处理，外部拦截</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                onTouchEvent(ev);  <span class="comment">//处理内部拦截时</span></span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">//外部拦截ScrollView的上下滑动，当ScrollView上下滑动时，事件给ScrollView</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(x - lastXIntercept) &gt; Math.abs(y - lastYIntercept)) &#123;</span><br><span class="line">                    intercepted = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastXIntercept = x;</span><br><span class="line">        lastYIntercept = y;</span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滚动事调用</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> oldl, <span class="keyword">int</span> oldt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onScrollChanged(l, t, oldl, oldt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> scale = l * <span class="number">1.0f</span> / mMenuWidth;  <span class="comment">//1~0</span></span><br><span class="line">        <span class="keyword">float</span> leftAlpha = <span class="number">0.6f</span> + <span class="number">0.4f</span> * (<span class="number">1.0f</span> - scale);  <span class="comment">//透明度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//属性动画TranslationX，默认动画有时间限制，需要自己去设置时间</span></span><br><span class="line">        mMenu.animate().translationX(mMenuWidth * scale * <span class="number">0.8f</span>).alpha(leftAlpha).setDuration(<span class="number">0</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开菜单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.smoothScrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        isOpen = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭菜单</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.smoothScrollTo(mMenuWidth, <span class="number">0</span>);</span><br><span class="line">        isOpen = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换菜单</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">            closeMenu();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            openMenu();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样使用一个外部拦截，接下来看效果图<br><img src="https://img-blog.csdnimg.cn/20190513185053751.gif" alt="SwipeConflict2"></p><p>结果很明显，解决了滑动冲突，而且也实现了抽屉式的侧滑。</p><hr><p>最后，总结一下，这次的滑动冲突我们及使用了外部拦截又使用了内部拦截，而且处理的逻辑并不是很难，就那么I行代码，所以以后遇到滑动冲突千万别怕，仔细分析一下，使用外部拦截或者内部拦截去解决就是，顺便放上<a href="https://github.com/PengHesheng/AndroidLearnDemo/tree/master/MyApplication" target="_blank" rel="noopener">Demo地址</a></p><hr><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="http://blog.csdn.net/lmj623565791/article/details/39257409" target="_blank" rel="noopener">鸿洋</a><br><a href="https://juejin.im/entry/59c06ef8f265da065b66a4ac" target="_blank" rel="noopener">掘金</a><br><a href="http://blog.penghesheng.cn/2019/04/25/自定义View、ViewGroup以及如何解决滑动冲突/" target="_blank" rel="noopener">Android开发艺术探索</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/07/hello-world/"/>
      <url>/2020/02/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些常用命令汇总</title>
      <link href="/2020/02/07/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/2020/02/07/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="常用的命令总结"><a href="#常用的命令总结" class="headerlink" title="常用的命令总结"></a>常用的命令总结</h1><h2 id="git相关"><a href="#git相关" class="headerlink" title="git相关"></a>git相关</h2><ul><li><p>git host配置：</p><p>  <code>151.101.72.249 global-ssl.fastly.Net  192.30.253.112 github.com</code></p></li><li><p>创建库：<code>mkdir</code> 文件名</p></li><li><p>显示当前目录：<code>pwd</code></p></li><li><p>把该目录变成git可以管理的仓库：<code>git init</code></p></li><li><p>添加到工作区：<code>git add</code></p></li><li><p>添加到git历史，提交更改：<code>git commit -m “content”</code></p></li><li><p>修改最近一次提交：<code>git commit –-amend</code></p></li><li><p>修改最近3次提交：<code>git rebase -i HEAD~3</code></p></li><li><p>合并提交：</p><ul><li><code>git rebase -i HEAD~3</code></li><li>将<code>pick</code>改为<code>squash</code></li><li><code>git add .</code></li><li><code>git rebase –continue</code></li><li>修改提交信息</li><li>如果需要放弃合并commit，<code>git rebase –-abort</code></li></ul></li><li><p>查看不同：<code>git diff</code></p></li><li><p>查看提交历史：<code>git log</code></p></li><li><p>图形化查看提交：<code>git log --graph</code></p></li><li><p>图形化查看所有的提交：<code>git log --graph --decorate --all</code></p></li><li><p>返回上一个版本：<code>git reset --hard HEAD^ //HEAD表示当前版本</code></p></li><li><p>返回某个版本：<code>git reset --hard 地址</code></p></li><li><p>查看命令：<code>git reflog</code></p></li><li><p>撤销修改：<code>git checkout -- 文件名</code></p></li><li><p>删除文件：<code>rm 文件名加格式</code></p></li><li><p>丢弃本地所有提交与改动，到服务器上获取最新的版本并将本地分支指向它：</p><p>  <code>git fetch origin</code><br>  <code>git reset --hard origin/master</code></p></li><li><p>清空缓存：<code>git rm -r --cached . //使用.gitignore用到</code></p></li><li><p>新建文件：<code>touch .gitignore //新建一个.gitignore</code></p></li><li><p>查看分支：<code>git branch</code></p></li><li><p>查看远程分支：<code>git branch -r</code></p></li><li><p>查看所有分支：<code>git branch -a</code></p></li><li><p>创建分支：<code>git branch &lt;name&gt;</code></p></li><li><p>切换分支：<code>git checkout &lt;name&gt;</code></p></li><li><p>创建+切换：<code>git checkout -b &lt;name&gt;</code></p></li><li><p>合并到当前：<code>git merge &lt;name&gt;</code></p></li><li><p>删除分支：<code>git branch -d &lt;name&gt;</code></p></li><li><p>查看用户名和邮箱：<code>git config user.name/user.email</code></p></li><li><p>修改用户名和邮箱：<code>git config –-global user.name “username”</code></p></li><li><p>关联远程库：<code>git remote add origin git@github.com:用户名/库名.git</code></p></li><li><p>取消关联远程库：<code>git remote remove origin</code></p></li><li><p>将本地内容推送到远程库：<code>git push -u origin master //master表示分支，第一次推送需要加-u，表示新建一个</code></p></li><li><p>将本地最新修改推送到master：<code>git push origin master</code></p></li><li><p>将本地test分支推送到远程test分支，如果远程没有则新建test分支：<code>git push origin test:test</code></p></li><li><p>将远程test分支删除：<code>git push origin :test</code>（相当于推送了一个空的分支覆盖掉）</p></li><li><p>克隆远程库到本地：<code>git clone git@github.com:用户名/库名.git</code></p></li><li><p>更新git客户端：<code>git update</code></p></li><li><p>清除项目缓存和密码：<code>git credential-manager uninstall</code> （权限问题的时候）</p></li><li><p>查看分支的合并情况：<code>git log –graph –pretty=oneline –abbrev-commit</code></p></li><li><p>储藏工作区：<code>git stash</code></p></li><li><p>查看工作区、库的状态：<code>git status</code></p></li><li><p>查找之前隐藏的工作区：<code>git stash list</code></p></li><li><p>恢复工作区：<code>git stash apply</code></p></li><li><p>删除stash内容：<code>git stash drop</code></p><p>  两步一体：<code>git stash pop</code></p><p>  <strong>bug修复时，在新的分支上修复，合并到master，但不影响你之前的分支上的工作，最后合并时，修复bug</strong>:</p></li><li><p>强行删除未合并的分支：<code>git branch -D &lt; &gt;</code></p></li><li><p>查看远程库的信息：<code>git remote</code></p></li><li><p>查看详细的信息：<code>git remote -v</code><br>  <strong>做项目需要用到的</strong>:</p></li><li><p>创建远程origin的dev分支到本地：<code>git checkout -b dev origin/dev //本地分支最好与远程分支一致</code></p></li><li><p>抓取远程的新提交：<code>git pull</code></p></li><li><p>建立本地分支和远程分支的关联：<code>git branch –set-upstream-to=origin/branch-name branch-name</code></p></li><li><p>初始化子模块：<code>git submodule init</code></p></li><li><p>更新子模块：<code>git submodule update</code></p></li><li><p>同步子模块：<code>git submodule sync</code></p></li><li><p>标签分支：tag</p></li><li><p>打印一个新标签：<code>git tag &lt; &gt;</code></p></li><li><p>查看所有标签：<code>git tag</code></p></li><li><p>对以前的打上标签：<code>git tag &lt; &gt; 地址</code></p></li><li><p>查看标签信息：<code>git show &lt; &gt;</code></p></li><li><p>带有说明的标签：<code>git tag -a &lt; &gt; -m “说明内容” 地址</code></p></li><li><p>删除标签：<code>git tag -d &lt; &gt;</code></p></li><li><p>推送标签：<code>git push origin &lt; &gt;</code></p></li><li><p>一次推送所有的标签：<code>git push origin –tags</code></p></li><li><p>删除远程标签：先删除本地的标签<code>git tag -d &lt; &gt;</code>，再删除远程的<code>git push origin :refs/tags/&lt; &gt;</code></p></li></ul><h2 id="Hexo相关"><a href="#Hexo相关" class="headerlink" title="Hexo相关"></a>Hexo相关</h2><ul><li>新建文章：<code>hexo new</code></li><li>新建页面：<code>hexo new page</code></li><li>生成静态页面至public：<code>hexo generate</code></li><li>开启预览访问端口：<code>hexo server</code></li><li>将deploy目录部署到github：<code>hexo deploy</code></li><li>生成+部署：<code>hexo d -g</code></li><li>预览+部署：<code>hexo s -g</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架整理(六)——Vector和Stack源码分析</title>
      <link href="/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E5%85%AD)%E2%80%94%E2%80%94Vector%E5%92%8CStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E5%85%AD)%E2%80%94%E2%80%94Vector%E5%92%8CStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Vector和Stack源码分析"><a href="#Vector和Stack源码分析" class="headerlink" title="Vector和Stack源码分析"></a>Vector和Stack源码分析</h1><h2 id="Vector源码"><a href="#Vector源码" class="headerlink" title="Vector源码"></a>Vector源码</h2><blockquote><p>实现动态数组</p><p>支持同步访问</p><p>事先不知道数组大小，类似于ArrayList</p></blockquote><p>先看看类的继承关系吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//数据数组</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line">    <span class="comment">//容量增量因子</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2767605614048989439L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        elementCount = elementData.length;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector是通过继承AbstractList实现的，同时实现了List、RandomAccess、Cloneable、Serializable接口，AbstractList和List都在<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(六)——Vector和Stack源码分析/" target="_blank" rel="noopener"><strong>Java集合框架</strong></a>中讲到了，RandomAccess、Cloneable、Serializable分别表示支持随机访问、可拷贝、可序列化等。</p><p>Vector有三个全局变量elementData、elementCount、capacityIncrement，分别是数组、元素个数以及容量增量因子。通过Vector的几个构造器可以知道，Vector容量默认是10，增量因子为0，有了容量，最终会直接进行实例化。如果通过Collection来实例化一个Vector，需要注意的是要转为Object[]类型</p><p>接着看看几个操作方法吧</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在末尾插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);  <span class="comment">//保证容量足够</span></span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接插入，在末尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在指定位置插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                     + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">        elementData[index] = obj;</span><br><span class="line">        elementCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证有足够的容量，当最小需求容量大于当前数据个数的时候，需要进行扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;  <span class="comment">//最大数组容量</span></span><br><span class="line">    <span class="comment">//真正进行扩容的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//根据是否有增量因子进行扩容，没有的话增量因子为当前数据个数</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        <span class="comment">//增量扩容后是否满足最小需求容量，不满足则直接使用最小容量为新的容量</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//检查是否超出最大数组容量</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当超出最大数组容量后使用Integer.MAX_VALUE作为容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addElement方法是synchronized修饰的，是线程安全的，其实Vector的很多方法都是synchronized修饰的，所以Vector是一个线程安全的集合<br>add相关的方法跟ArrayList的差不多；在扩容的是否会检查是否设置了增量因子的，有增量因子就直接使用，没有则用当前数据个数作为增量因子进行扩容，然后得到的容量是当前数据个数+增量因子</p><p>addAll等方法的原理都是一样的，这里就不再一一看源码了</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            removeElementAt(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除某个位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount--;</span><br><span class="line">        elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除所有的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// Let gc do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementCount; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        elementCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除两个下标之前的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = elementCount - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved);</span><br><span class="line">        <span class="comment">//设为null方便GC</span></span><br><span class="line">        <span class="keyword">int</span> newElementCount = elementCount - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">while</span> (elementCount != newElementCount)</span><br><span class="line">            elementData[--elementCount] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">firstElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elementData(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">lastElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elementData(elementCount - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指定下标的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//既可以是插入也可以是更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[index] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//复制到anArray中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Object[] anArray)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//手动进行扩容或缩容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</span><br><span class="line">            ensureCapacityHelper(newSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到当前容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elementData.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到当前元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elementCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个枚举类型的Vector，Vector中所有的数组变成枚举类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count &lt; elementCount;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; elementCount) &#123;</span><br><span class="line">                        <span class="keyword">return</span> elementData(count++);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Vector Enumeration"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否包含集合c的元素，利用AbstractCollection的方法进行判断，removeAll、retainAll方法都是用的父类的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.containsAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//批量分割集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.synchronizedList(<span class="keyword">super</span>.subList(fromIndex, toIndex),</span><br><span class="line">                                            <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的这些方法除了一些个别的，大多数都和ArrayList中的一样，不同的是Vector的方法是用synchronized修饰的，是线程安全的。Vector的迭代器原理跟ArrayList的都差不多，准确的说跟AbstractList中的差不多</p><h2 id="Stack源码"><a href="#Stack源码" class="headerlink" title="Stack源码"></a>Stack源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        addElement(item);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1224463164541339165L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stack的源码就很简单了，继承自Vector，使用的就是Vector中的数组，只是改了一下符合栈的一些方法的名字，逻辑操作做了适当的处理，同时Stack也是线程安全的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Vector并没有啥新奇的东西，看来ArrayList源码的就知道，两者差不了太多，两者最大的区别就是Vector是线程安全的，ArrayList是不安全的，而Stack则是完全基于Vector实现的，所以也没啥特别的<br>需要注意的是Vector和ArrayList的扩容方法虽然都差不多（都是基于数组实现），但扩容的大小还是不一样的</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架整理(四)——PriorityQueue、DelayQueue源码分析</title>
      <link href="/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E5%9B%9B)%E2%80%94%E2%80%94PriorityQueue%E3%80%81DelayQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E5%9B%9B)%E2%80%94%E2%80%94PriorityQueue%E3%80%81DelayQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="PriorityQueue、DelayQueue源码分析"><a href="#PriorityQueue、DelayQueue源码分析" class="headerlink" title="PriorityQueue、DelayQueue源码分析"></a>PriorityQueue、DelayQueue源码分析</h1><p>本文将会讲解两个Queue的源码，分别是PriorityQueue和DelayQueue</p><h2 id="PriorityQueue源码分析"><a href="#PriorityQueue源码分析" class="headerlink" title="PriorityQueue源码分析"></a>PriorityQueue源码分析</h2><blockquote><p>具有优先级的Queue<br>利用数组实现的Queue</p></blockquote><p>直接进入正题吧，先看PriorityQueue的继承结构吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PriorityQueue是通过继承AbstractQueue实现的，并实现了Serializable，这都没啥好说的，关于AbstractQueue的源码，还请先看<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(四)——PriorityQueue、DelayQueue源码分析/" target="_blank" rel="noopener"><strong>Java集合框架整理</strong></a></p><p>接着看看变量和构造方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7720805057305804111L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;  <span class="comment">//默认初始化容量大小为11</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] queue;  <span class="comment">//通过数组实现的队列，元素存放的地方，不可序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;  <span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="comment">//默认实例化时容量为默认值值11，没有比较方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定容量大小实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定比较方式（如何判定优先级）实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后会重载到这个构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过instanceof来判断时SortedSet类型、PriorityQueue类型还是其他的Collection，后面两个就是分别对应参数的构造方法</span></span><br><span class="line">    <span class="comment">//这个方法相对于其他类的实现相对要多一点，因为涉及到comparator，SortedSet</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">            initElementsFromCollection(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">            PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">            initFromPriorityQueue(pq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接通过PriorityQueue实例化</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        initFromPriorityQueue(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接通过SortedSet实例化</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(SortedSet&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PriorityQueue有多个构造方法，默认就是使用默认的容量11和不指定comparator进行实例化，当然也可以指定优先级的判定。然后又有根据Collection、PriorityQueue、SortedSet进行实例化的，不过<code>public PriorityQueue(Collection&lt;? extends E&gt; c)</code>已经包括了后面两种，所以我们着重看一下这个吧。<br>这个构造方法会对Collection进行一个判别，如果是SortedSet类型的就采用对应的处理方式，因为我们知道SortedSet也是一个有序的集合，所以也有comparator；如果是PriorityQueue，那就不用说了，就是一个类型的；如果是其他的Collection，那就说明没有comparator，就是一个普通的集合，最后放到队列里，元素就没有优先级</p><p>接着看看这三种情况下，到底怎么处理元素的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//处理PriorityQueue类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromPriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == PriorityQueue.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = c.toArray();</span><br><span class="line">            <span class="keyword">this</span>.size = c.size();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理元素数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initElementsFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">        <span class="keyword">if</span> (a.getClass() != Object[].class)</span><br><span class="line">            a = Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="comment">//检验元素是否存在null</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.queue = a;</span><br><span class="line">        <span class="keyword">this</span>.size = a.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他Collection类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用堆排序进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行元素的调整，k是待插入的位置，x是插入的值，进行堆调整（下沉）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认的比较方式compareTo</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用comparator比较方式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对是不是SortedSet、PriorityQueue以及其他的Collection采取了不同的处理方式，因为SortedSet和PriorityQueue都是已经排好序了的，所以只需要检验一下元素，转为的数组是否符合Object[]和赋值comparator就可以了；而对于那些不是有序的Collection，在处理元素时就需要处理排序的问题，这里采用的就是堆排序（<strong>利用了二叉堆的性质进行实现的</strong>），然后根据是否指定了comparator来进行不同的排序，没有指定comparator时采用默认的比较方式（<code>compareTo</code>比较)，而指定了comparable就用指定的进行比较，进行堆调整</p><p>接着看看几种常用的操作吧</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用offer进行添加 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先对null进行检验，因为涉及排序所以不允许null的存在</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="comment">//是否不够容量，不够就要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUp(i, e);  <span class="comment">//假设插到最后，然后进行位置调整</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;  <span class="comment">//最大值</span></span><br><span class="line">    <span class="comment">//真正扩容的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大容量调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入并进行元素调整，从后向前遍历整个数组进行插入（上浮）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用compareTo</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有comparator</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要扩容的时候，根据原来的容量是否小于64来进行两种方式的扩容，旧容量小于64，则在原来的基础上扩容旧容量+2，新的容量也就是2<em>旧容量+2；如果旧容量不是小于64，则在原来的基础上扩容一半，新的容量也就是1.5</em>旧容量。最大容量的调整跟其他集合类似</p><p><code>siftUp(int k, E x)</code>在要插入的时候（这里的k就是队列中最后一个元素的位置），需要找到插入的位置，通过从后向前遍历数组，根据不同的比较方式，确定插入元素的位置，同时将比较过的元素向后移动，这样就顺利插入了。入队只能在队尾，出队只能第一个元素出队</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        modCount++;</span><br><span class="line">        E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">        E x = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果不是空队，需要调整队列，在下标为0待插入x（最后一个元素），然后进行堆调整</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>, x);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAt(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除某个位置的元素，然后进行堆调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">            queue[i] = <span class="keyword">null</span>;  <span class="comment">//最后一个被移除直接置空</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//不是最后一个的话</span></span><br><span class="line">            E moved = (E) queue[s];</span><br><span class="line">            queue[s] = <span class="keyword">null</span>;</span><br><span class="line">            siftDown(i, moved);  <span class="comment">//将最后一个元素插入到i的位置，进行堆调整（下沉）</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] == moved) &#123;  <span class="comment">//如果i的位置是moved要移动的元素（也就是前面说的最后一个元素，说明没有调整成功，换种方式调整）</span></span><br><span class="line">                siftUp(i, moved);  <span class="comment">//继续调整二叉堆（上浮）</span></span><br><span class="line">                <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                    <span class="keyword">return</span> moved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在删除某个元素的时候，可能会导致<code>siftDown()</code>调整二叉堆不成功，就需要换<code>siftUp()</code>进行调整，两者只会有一个执行，这两个函数是用来保证最大值或最小值处于顶端的</p><p>关于下沉、上浮的二叉堆调整参考<a href="https://blog.csdn.net/xidiancoder/article/details/77850535" target="_blank" rel="noopener">【Java源码】PriorityQueue源码剖析及其应用</a></p><h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(queue[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            queue[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法跟其他的集合逻辑都差不多，就不再多言</p><h2 id="DelayQueue源码分析"><a href="#DelayQueue源码分析" class="headerlink" title="DelayQueue源码分析"></a>DelayQueue源码分析</h2><blockquote><p>可重入锁ReentrantLock实现线程安全<br>用于根据delay时间排序的优先级队列<br>没有实现Serializable接口，不可序列化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//重入锁，实现同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//内部采用优先级队列实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">    <span class="comment">//优化阻塞通知的线程，就是一个标志</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//用于阻塞和通知的条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DelayQueue继承自AbstractQueue，实现BlockingQueue（有关BlockingQueue可见<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(四)——PriorityQueue、DelayQueue源码分析/" target="_blank" rel="noopener">PriorityBlockingQueue、ArrayBlockingQueue源码分析</a>），BlockingQueue就是一些api的定义</p><p>DelayQueue通过全局变量重入锁lock——ReetrantLock来实现上锁和同步，实现线程安全，同时，内部采用PriorityQueue来实现元素的存储。默认构造器没有什么参数</p><p>在看后面的方法之前，还需要看Delayed是什么，因为要使用DelayQueue的元素必须是实现Delayed的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Delayedpublic <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delayed是继承自Comparable的，这是为了方便内部使用PriorityQueue要用的，然后又定义的了getDelay方法获取delay，这两个方法是必须实现的</p><p>接着看常用的方法吧</p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//内部调用offer方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//获取锁，上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//添加到PriorityQueue中</span></span><br><span class="line">            q.offer(e);</span><br><span class="line">            <span class="comment">//如果刚放入的元素是第一个，之前是空队列，现在不是，则唤醒其他线程，当前没有线程占用</span></span><br><span class="line">            <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">                leader = <span class="keyword">null</span>;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        offer(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终都是通过offer来入队，并且通过PriorityQueue进行操作（具体方法在前面），然后多了获取锁这一步</p><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//获取锁，上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            E first = q.peek();  <span class="comment">//获取头</span></span><br><span class="line">            <span class="comment">//如果是空队或者延长还没到期，则返回null</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> q.poll();  <span class="comment">//否则，出队</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有一定时间的出队，也可能导致阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);  <span class="comment">//计算超时等待时间</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();  <span class="comment">//可中断获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                E first = q.peek();  <span class="comment">//获取队头元素</span></span><br><span class="line">                <span class="comment">//如果是空队</span></span><br><span class="line">                <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果是空队且超时等待时间已过（&lt;=0），返回null</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        nanos = available.awaitNanos(nanos);  <span class="comment">//超时等待时间还没有过，则继续等待 超时等待时间 这么长的时间</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//有元素，计算其delay时延</span></span><br><span class="line">                    <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    <span class="comment">//delay&lt;=0，到了时间，直接出队</span></span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> q.poll();</span><br><span class="line">                    <span class="comment">//超时等待时间到了，但元素的delay时延还没有到，则返回null</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                    <span class="comment">//如果超时等待时间没到，且小于delay时延，则继续等待 超时等待时间 这么长的时间，或者没有线程占用</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                        nanos = available.awaitNanos(nanos);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果超时等待时间没到，但大于delay时延，就获取当前线程，等待delay时间，获取元素</span></span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;  <span class="comment">//将leader标志量指定为当前线程，防止其他线程在抢断</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);  <span class="comment">//等待delay时间</span></span><br><span class="line">                            nanos -= delay - timeLeft;  <span class="comment">//剩余超时等待时间</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">                available.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接出队很简单，获取锁然后通过PriorityQueue直接出队就行。<br>稍微复杂一点的就是有一定等待时间的出队（超时等待时间），所以就会比直接出队多了几种情况（并且这个方法可能会阻塞）：当超时等待时间到了的话，就直接返回null；如果超时等待时间没到，就会与元素的delay时间进行比较，看是否等待多长时间，当超时等待时间小于delay时间时（超时等待时间到会比元素的delay时间先到），这时就只能等到超时等待时间的时长；如果超时等待时间大于元素的delay时间（delay时间先到，这时还在等待，可以获取元素），就等待delay长的时间，然后线程占用，获取元素；如果在此之前，已经有线程在占用了，那么不管超时等待时间与delay的时间如何，此时的线程只能等待</p><h3 id="获取队头"><a href="#获取队头" class="headerlink" title="获取队头"></a>获取队头</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取队头元素，可能会导致阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();  <span class="comment">//可中断获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//死循环，一直获取头元素</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                E first = q.peek();</span><br><span class="line">                <span class="comment">//空队，通知唤醒线程</span></span><br><span class="line">                <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不是空队就计算时延</span></span><br><span class="line">                    <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    <span class="comment">//已经过期，直接出队</span></span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> q.poll();</span><br><span class="line">                    <span class="comment">//不是空队（有元素）且还没有过期，则要阻塞</span></span><br><span class="line">                    first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                    <span class="comment">//如果有线程占有，通知其他线程等待</span></span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                        available.await();</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//没有线程占有，就当前线程占有，且等待delay的时间获取元素</span></span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            available.awaitNanos(delay);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                leader = <span class="keyword">null</span>;  <span class="comment">//获取完释放，不再占有</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">                available.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();  <span class="comment">//获取锁，通过优先级队列直接获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q.peek();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中take方法可能会引起阻塞，涉及等待，会有死循环一直获取，所以可能会导致阻塞。这个情况跟前面出队类似，重要区别就是take方法后面只有判断是否正有线程占用</p><h3 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取大小，得到锁后直接获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取过期的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">peekExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">        E first = q.peek();</span><br><span class="line">        <span class="keyword">return</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>) ?</span><br><span class="line">            <span class="keyword">null</span> : first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取所有过期的元素，放入集合c中，返回过期元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();  <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//通过peekExpired方法获取队头过期的元素，添加到集合c中，并移除，依次循环获取所有的队头过期元素</span></span><br><span class="line">            <span class="keyword">for</span> (E e; (e = peekExpired()) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">                c.add(e);       <span class="comment">// In this order, in case add() throws.</span></span><br><span class="line">                q.poll();</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比上一个方法多了一个条件，c有最大个数限制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (E e; n &lt; maxElements &amp;&amp; (e = peekExpired()) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">                c.add(e);       <span class="comment">// In this order, in case add() throws.</span></span><br><span class="line">                q.poll();</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            q.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//总是返回int的最大值，因为DelayQueue是无界的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取锁，通过PriorityQueue移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q.remove(o);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>PriorityQueue<ol><li>实现了Serialilzable，可序列化</li><li>默认容量是11，可指定Comparator，又默认的Comparable</li><li>数组实现，内部采用二叉堆的数据结构</li><li>可以SortedSet进行初始化，还可以PriorityQueue和其他Collection</li><li>每次添加、删除都会调整二叉堆的结构（上浮、下沉）</li><li>每次扩容先会针对64这个界值进行判断，旧容量小于64，会在原来的基础上扩容旧容量+2（新容量也就是2<em>旧容量+2）；如果不小于64，则在原来的基础上扩容一半（新容量也就是</em>旧容量）</li></ol></li><li>DelayQueue<ol><li>通过可重入锁ReentrantLock实现线程安全</li><li>内部采用优先级队列PriorityQueue实现</li><li>没有实现Serializable，不可序列化</li><li>采用一个Thread类型的leader对象用来标识是否被线程占用</li><li>DelayQueue的元素必须实现Delayed接口并实现其中的方法</li><li>DelayQueue是无界的，获取容量的时候总会返回Integer.MAX_VALUE</li><li>可以通过drainTo方法获取所有过期的元素</li><li>大部分操作都是通过获取锁然后再进行操作，但take方法和带有超时限制的poll方法是可中断的锁，也可能会导致阻塞</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架整理(八)——ArrayList源码分析</title>
      <link href="/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E5%85%AB)%E2%80%94%E2%80%94ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E5%85%AB)%E2%80%94%E2%80%94ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><p>ArrayList（动态数组）：</p><blockquote><p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。</p><p>默认第一次插入元素时创建大小为10的数组。</p><p>按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。</p><p>直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素 —add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p></blockquote><p>先看看它的类继承关系吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="comment">//默认容量大小为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//给空实例的共享的空数组实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//用于区分上边的EMPTY_ELEMENTDATA，有默认大小的空实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//不可序列化的元素数组，就是存放数据的地方</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//指定大小初始化数组，一般建议使用这个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//为0的时候使用空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有指定容量的时候，elementData指定为DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据Collection进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//必须为数组类型</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList是通过继承AbstractList并实现List、RandomAccess、Cloneable、Serializable等接口，关于AbstractList和List可以看总纲<a href="http://blog.penghesheng.cn/2019/05/06/Java集合框架整理(八)——ArrayList源码分析/" target="_blank" rel="noopener"><strong>Java集合框架整理</strong></a>，RandomAccess这个是表示支持随机访问，优化性能的</p><p>ArrayList中定义了几个全局变量，DEFAULT_CAPACITY是默认的容量大小，EMPTY_ELEMENTDATA、DEFAULTCAPACITY_EMPTY_ELEMENTDATA分别表示一个空数组实例和有默认容量的空数组实例，然后还有真正的数据存放的引用elementData和元素个数size。</p><p>通过几种构造器，可以知道，如果在没有指定容量的情况下，默认是一个由默认容量的空数组实例，指定为0的时候就是一个空数组实例，指定容量大小时就实例化一个相应大小的数组。所以不管怎样，只要实例化ArrayList后elementData就不是一个null，而是一个实例化过的对象。当根据Collection进行初始化的时候，一定要保证能够得到是Object[]，不是的话也会处理成Object[]。</p><p>接着看看常用的操作吧</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 检查容量是否足够，在保证足够的情况下进行插入</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);  <span class="comment">//检查是否越界</span></span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 检查容量是否足够</span></span><br><span class="line">        <span class="comment">//直接通过System.arraycopy函数进行数据的移动</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保容量足够，不够就进行扩容，先进行第一步检查</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果之前还是DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空数组实例，最小需求容量就是默认值10</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接着判断是否需要进行扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;  <span class="comment">//修改次数，在AbstractList中定义的</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;  <span class="comment">//数组最大容量</span></span><br><span class="line">    <span class="comment">//真正进行扩容的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//在原来的基础上进行一半扩容</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后判断是否满足最小需求容量</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//检查是否超出最大容量，以最大值进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在add的时候，必须确保容量是足够的，所以add之前都要先进行判断，不够就会进行扩容，每次扩容都会增加目前元素个数的<strong>一半</strong>（如果当前是10，扩容后就是10+10/2），如果到达的了最大容量Integer.MAX_VALUE - 8就不会再增加，以这个为最小需求容量进行数组移动（如果真到了这个地步也不应该采用ArrayList）</p><p><strong>addAll:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//添加一个集合的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);  <span class="comment">//检查是否越界</span></span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        <span class="comment">//判断插入的位置是否已经有元素了还是在后面的空白部分插入</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;  </span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//删除指定位置的元素并返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  <span class="comment">//是否是删除的最后一个元素，不是则需要进行数据前移</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除某个元素（集合中所有出现的）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过遍历整个数组进行删除</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除一个集合c中的所有元素，即保留不在集合c的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保留包含在集合c中的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接覆盖掉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//批量删除</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据标志量complement来决定是保留集合c中的元素还是保留不在c中的元素</span></span><br><span class="line">            <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">                <span class="comment">//剩下数据的移动</span></span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">                <span class="comment">// 清楚后面重复或无用的空间 clear to let GC do its work</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                size = w;</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove中removeAll()、retainAll()两个函数比较难一点，分别表示保留不在/在集合c中的元素</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法很简单，检查一下索引，直接获取</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set也没啥看的，跟get对应</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//去掉多余的空间（没有数据占用的空间）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否包含某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到第一次出现索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后依次出现的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据operator进行替换操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Arrays进行排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后关于ArrayList的迭代器其实跟AbstrList中的差不多，跟LinkedList也差不多，大致思想都是一样的，需要的可以自己去看看</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ArrayList通过增、删、改、查可以看出，增和删的时候很容易要移动元素，性能消耗比较大，改、查就十分简单，根据索引就可以了，但是不知道索引还是需要遍历整个数组才行。相对于LinkedList改、查比较方便，但LinkedList增、删都由于ArrayList。</p><p>ArrayList有默认的容量为10，但并没有在构造器中进行初始化（除非指定容量的时候会初始化数组）。每次扩容的时候，是在原来size的基础上增加1/2，然后去跟最小需求容量比较</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架整理(五)——LinkedList源码分析</title>
      <link href="/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%BA%94)%E2%80%94%E2%80%94LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%BA%94)%E2%80%94%E2%80%94LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h1><p>LinkedList：链表实现的集合</p><p>先看看类的继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//链表长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList是通过AbstractSequentialList来实现的，并且同时实现了List、Deque、Cloneable、Serialzable等接口。List前面<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(五)——LinkedList源码分析/" target="_blank" rel="noopener"><strong>Java集合框架整理</strong></a>已经看过了，Deque则在<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(五)——LinkedList源码分析/" target="_blank" rel="noopener"><strong>Queue</strong>中有讲到</a>，Cloneable和Serialzable表示可克隆和序列化，也没啥说的</p><p>接着可以看到有三个trasient修饰的全局变量表示不可序列化，然后是构造器。默认实现的是一个空链表，或者根据Collection生成的链表。然后我们看到链表结点定义的是一个私有静态内部类，只有一个构造方法，参数分别是元素，下一个结点和前一个结点（维护了双链表，既可前向遍历也可后向遍历），结点的引用可以让我们直接进行添加、删除操作而不用向数组一样需要进行其他元素的移动，但遍历就相对麻烦一些</p><p>接着看看常见的操作方法吧</p><hr><h2 id="添加add"><a href="#添加add" class="headerlink" title="添加add"></a>添加add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//使用尾插法添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到指定位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);  <span class="comment">//添加到链尾</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));  <span class="comment">//添加到某个结点前，通过node()获取改位置的结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将集合中的元素依次插入到指定位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="comment">//转为元素数组</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="comment">//整个集合插到链尾</span></span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//指定结点后面</span></span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历插入</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    <span class="comment">//获取尾结点，生成一个新结点，如果没有尾结点，链表为空链的情况，那就成为头结点；如果有，则调整链尾，修改结点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入，插入在某个结点前；通过节点的前指针pred来进行插入操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过比较size的一半，进行遍历查找，前向还是后向</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//减小遍历次数</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//来自Deque接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的add、addAll方法，通过链表的特性进行添加，由于也实现了Deque接口，所以一些方法逻辑就是基本一致</p><hr><h2 id="删除remove"><a href="#删除remove" class="headerlink" title="删除remove"></a>删除remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//删除指定元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过遍历查找删除</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认移除头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除第一次出现的某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除最后一次出现的元素，通过反响遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除尾结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除最后一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove也没啥难的，跟add基本对应类似</p><hr><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);  <span class="comment">//检查下标</span></span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> f.item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//修改指定位置的值，返回旧值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        E oldVal = x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取某个元素的位置。后向遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过比较是否下标判断是否存在某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空链表，遍历置null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = <span class="keyword">null</span>;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝。浅拷贝</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line">        clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">        clone.size = <span class="number">0</span>;</span><br><span class="line">        clone.modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize clone with our elements</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            clone.add(x.item);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转为元素数组</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LLSpliterator&lt;E&gt;(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过index获取普通的迭代器，分割迭代器也是重写了。descendingIterator()提供的是一个逆序的迭代器，看源码可以知道就是以size()来生成的ListItr，next是当前结点的前一个结点</p><p>先看ListItr</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">        unlink(lastReturned);</span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextIndex--;</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实ListItr跟AbstractList中的差不多，核心思想都是间接来操作集合，这里就是间接操作链表了</p><p>再看LLSpliterator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LLSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_UNIT = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;  <span class="comment">// 分批每一批的size的增量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BATCH = <span class="number">1</span> &lt;&lt; <span class="number">25</span>;  <span class="comment">// 每一批最大size</span></span><br><span class="line">    <span class="keyword">final</span> LinkedList&lt;E&gt; list;</span><br><span class="line">    Node&lt;E&gt; current;      <span class="comment">// 当前的结点</span></span><br><span class="line">    <span class="keyword">int</span> est;              <span class="comment">// size估计值</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount; <span class="comment">// est修改次数</span></span><br><span class="line">    <span class="keyword">int</span> batch;            <span class="comment">// 分割每一批的数量size</span></span><br><span class="line"></span><br><span class="line">    LLSpliterator(LinkedList&lt;E&gt; list, <span class="keyword">int</span> est, <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.est = est;</span><br><span class="line">        <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getEst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="comment">// force initialization</span></span><br><span class="line">        <span class="keyword">final</span> LinkedList&lt;E&gt; lst;</span><br><span class="line">        <span class="keyword">if</span> ((s = est) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lst = list) == <span class="keyword">null</span>)</span><br><span class="line">                s = est = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                expectedModCount = lst.modCount;</span><br><span class="line">                current = lst.first;</span><br><span class="line">                s = est = lst.size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//估计当前Spliterator实例中将要迭代的元素的数量，如果数量是无限的、未知的或者计算数量的花销太大，则返回Long.MAX_VALUE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">long</span>) getEst(); &#125;</span><br><span class="line">    <span class="comment">//分割迭代器，没调用一次，将原来的迭代器等分为两份，并返回索引靠前的那一个子迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; p;</span><br><span class="line">        <span class="keyword">int</span> s = getEst();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">1</span> &amp;&amp; (p = current) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = batch + BATCH_UNIT;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; s)</span><br><span class="line">                n = s;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; MAX_BATCH)</span><br><span class="line">                n = MAX_BATCH;</span><br><span class="line">            Object[] a = <span class="keyword">new</span> Object[n];</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123; a[j++] = p.item; &#125; <span class="keyword">while</span> ((p = p.next) != <span class="keyword">null</span> &amp;&amp; j &lt; n);</span><br><span class="line">            current = p;</span><br><span class="line">            batch = j;</span><br><span class="line">            est = s - j;</span><br><span class="line">            <span class="keyword">return</span> Spliterators.spliterator(a, <span class="number">0</span>, j, Spliterator.ORDERED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过action批量消费所有的未迭代的数据。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; p; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> ((n = getEst()) &gt; <span class="number">0</span> &amp;&amp; (p = current) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            est = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                E e = p.item;</span><br><span class="line">                p = p.next;</span><br><span class="line">                action.accept(e);</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; --n &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单个对元素执行给定的动作，如果有剩下元素未处理返回true，否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; p;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (getEst() &gt; <span class="number">0</span> &amp;&amp; (p = current) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            --est;</span><br><span class="line">            E e = p.item;</span><br><span class="line">            current = p.next;</span><br><span class="line">            action.accept(e);</span><br><span class="line">            <span class="keyword">if</span> (list.modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前对象有哪些特征值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就简单看看Spliterator，具体的请自行查看有关Spliterator的知识<br><a href="https://blog.csdn.net/jiangmingzhi23/article/details/78927552" target="_blank" rel="noopener">java源码阅读之Spliterator</a><br><a href="https://blog.csdn.net/lh513828570/article/details/56673804" target="_blank" rel="noopener">JDK8源码之Spliterator并行遍历迭代器</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LinkedList就是充分利用链表这个数据结构的特定，实现的集合，在1.8加入了分割迭代器用于并发处理和遍历，优化性能。同时在查找某个结点的时候，也是优化算法为O(n/2)的时间复杂度；链表的空间复杂度并不复杂，唯一的缺点就是遍历的问题比较麻烦；LinkedList采用的是双链表的形式，在遍历上比单链表效率又要高许多。还有点需要注意的是LinkedList并没有实现List接口中的replaceAll()和sort()方法，而ArrayList实现了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析</title>
      <link href="/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%B8%83)%E2%80%94%E2%80%94TreeSet%E3%80%81HashSet%E3%80%81LinkedHashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%B8%83)%E2%80%94%E2%80%94TreeSet%E3%80%81HashSet%E3%80%81LinkedHashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="TreeSet、HashSet、LinkedHashSet源码分析"><a href="#TreeSet、HashSet、LinkedHashSet源码分析" class="headerlink" title="TreeSet、HashSet、LinkedHashSet源码分析"></a>TreeSet、HashSet、LinkedHashSet源码分析</h1><p>TreeSet是基于TreeMap实现的有序的集合，HashSet是基于HashMap实现的，而LinkedHashSet更是继承自HashSet，所以他们的源码都不会太复杂，所以在看这篇文章之前需要先看<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析/" target="_blank" rel="noopener"><strong>TreeMap源码分析</strong></a>、<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析/" target="_blank" rel="noopener"><strong>HashMap的源码分析</strong></a></p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><blockquote><p>有序的Set集合</p><p>基于TreeMap实现</p></blockquote><p>TreeSet的继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(s.comparator());</span><br><span class="line">        addAll(s);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeSet继承自AbstractSet，这是之前<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析/" target="_blank" rel="noopener"><strong>Java集合框架整理</strong></a>看过了。然后还实现了NavigableSet、Cloneable、Serializable接口，重点看看NavigableSet（另外两个就没啥说的了）</p><p>在看NavigableSet接口之前，先看看TreeSet中的全局变量和构造器吧。<br>m是一个NavigableMap，也是一个接口，具体实现是TreeMap（详见<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析/" target="_blank" rel="noopener">TreeMap源码分析</a>），TreeSet很多方法最后都是调用TreeMap来实现的，TreeSet就是一个壳子。PRESENT就是一个假想值。通过观看几个重载的构造方法，最终是以一个TreeMap来初始化的，所以才说TreeSet是基于TreeMap实现的；Set是继承Collection的，所以也可以通过它来初始化，Collection衍生的类（如ArrayList、LinkedList等都有类似的构造方法）；TreeSet还可以通过SortSet来构造，SortSet也是一个接口，它是下一步要看的NavigableSet的父接口</p><p>接着看NavigableSet接口吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回Set中小于e的最大元素</span></span><br><span class="line">    <span class="function">E <span class="title">lower</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//返回Set中小于等于e的最大元素</span></span><br><span class="line">    <span class="function">E <span class="title">floor</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//返回Set中大于等于e的最小元素</span></span><br><span class="line">    <span class="function">E <span class="title">ceiling</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//返回Set中大于e的最小元素</span></span><br><span class="line">    <span class="function">E <span class="title">higher</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//检索并移除Set中最小的元素（第一个）</span></span><br><span class="line">    <span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检索并移除Set中最大的元素（最后一个)</span></span><br><span class="line">    <span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//逆序的Set结合</span></span><br><span class="line">    <span class="function">NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//逆序的迭代器</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//批量处理，并发执行</span></span><br><span class="line">    <span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">                           E toElement,   <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line">    <span class="comment">//返回小于toElement的Set结合</span></span><br><span class="line">    <span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span></span>;</span><br><span class="line">    <span class="comment">//返回大于fromElement的Set集合</span></span><br><span class="line">    <span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span></span>;</span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span>;</span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span>;</span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NavigableSet又是继承自SortedSet，NavigableSet中定义了一些操作方法，具体实现则在TreeSet中</p><p>接着看看SortedSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//排序方式</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> E&gt; comparator();</span><br><span class="line"></span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span>;</span><br><span class="line">    <span class="comment">//获取排序后的Set中的第一个</span></span><br><span class="line">    <span class="function">E <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取排序后的Set中的最后一个</span></span><br><span class="line">    <span class="function">E <span class="title">last</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Spliterators.IteratorSpliterator&lt;E&gt;(</span><br><span class="line">                <span class="keyword">this</span>, Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; getComparator() &#123;</span><br><span class="line">                <span class="keyword">return</span> SortedSet.<span class="keyword">this</span>.comparator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SortedSet名如其意，就是排序的Set，是直接继承的Set接口，前面我们能知道Set基本跟Collection差不多，就是多了默认的分割迭代器。在SortedSet中添加了几个方法，便于一些常用的操作，如first()、last()分别得到当前Set中的第一个和最后一个元素；同时SortedSet中重写了spliterator()，修改了默认分割迭代器，得到的是可比较的分割迭代器，这个迭代器又是根据comparator()生成的，所以comparator()就需要看具体实现了；subSet()和subList()是一样的，集合操作，返回两个集合的交；headSet()返回小于toElement集合的所有元素组成的集合；同理，tailSet()返回大于等于fromElement；comparator()是定义排序方式的,这个接口中也没多少方法，提供了一些排序后获取元素的方法</p><p>所以不管是NavigableSet还是SortedSet，代码不是很多，都是定义了一些有序的操作方法，接着继续看TreeSet中的具体实现吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//迭代器，返回的就是TreeMap的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.descendingMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use linear-time version if applicable</span></span><br><span class="line">        <span class="keyword">if</span> (m.size()==<span class="number">0</span> &amp;&amp; c.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            c <span class="keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">            m <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">            Comparator&lt;?&gt; cc = set.comparator();</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; mc = map.comparator();</span><br><span class="line">            <span class="keyword">if</span> (cc==mc || (cc != <span class="keyword">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">                map.addAllForTreeSet(set, PRESENT);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  E toElement,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive,</span><br><span class="line">                                       toElement,   toInclusive));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subSet(fromElement, <span class="keyword">true</span>, toElement, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> headSet(toElement, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tailSet(fromElement, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">        <span class="keyword">return</span> m.comparator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.firstKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.lastKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NavigableSet API methods</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;E&gt; clone;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone = (TreeSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clone.m = <span class="keyword">new</span> TreeMap&lt;&gt;(m);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回TreeMap的分割迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TreeMap.keySpliteratorFor(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着代码很多，其实仔细看看，很多方法都是基于TreeMap的，根本就没啥实际性的逻辑，所以一定要看完TreeMap的源码</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet是基于HashMap实现的，所以也不用多说什么，直接看看源码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            <span class="keyword">return</span> newSet;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap.KeySpliterator&lt;E,Object&gt;(map, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以知道，大多数api的调用都是交给了内部的HashMap去处理了，所以原理需要看看<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析/" target="_blank" rel="noopener"><strong>HashMap源码分析</strong></a></p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet是继承自HashSet的，而它本身也没有很多方法，所以依然是内部使用HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.DISTINCT | Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看到，没有多少方法，基本上就是HashSet，不同的就是实例化的时候，参数不同得到了LinkedHashSet，准确来说，LinkedHashSet就是HashSet的一种特殊情况</p><p>默认容量是16，加载因子是0.75，依然要满足HashMap的2次幂的要求</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TreeSet、HashSet分别基于TreeMap、HashMap实现，而LinkedHashMap是继承自HashSet，算是HashSet的一种特殊情况。看完源码，其实他们之间没有什么大的区别，最大的区别就是基于不同的map来实现的，他们本事实现了不同的接口也是因为特性提供了不同的api，更通俗一点，他们就是一个空壳，所以要知道原理还得看<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析/" target="_blank" rel="noopener"><strong>TreeMap源码分析</strong></a>、<a href="http://blog.penghesheng.cn/2019/04/25/Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析/" target="_blank" rel="noopener"><strong>HashMap源码分析</strong></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架整理(一)——PriorityBlockingQueue、ArrayBlockingQueue源码分析</title>
      <link href="/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%B8%89)%E2%80%94%E2%80%94PriorityBlockingQueue%E3%80%81ArrayBlockingQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%B8%89)%E2%80%94%E2%80%94PriorityBlockingQueue%E3%80%81ArrayBlockingQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="PriorityBlockingQueue、ArrayBlockingQueue源码分析"><a href="#PriorityBlockingQueue、ArrayBlockingQueue源码分析" class="headerlink" title="PriorityBlockingQueue、ArrayBlockingQueue源码分析"></a>PriorityBlockingQueue、ArrayBlockingQueue源码分析</h1><h2 id="PriorityBlockingQueue源码分析"><a href="#PriorityBlockingQueue源码分析" class="headerlink" title="PriorityBlockingQueue源码分析"></a>PriorityBlockingQueue源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5595510919245408276L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">        <span class="keyword">boolean</span> heapify = <span class="keyword">true</span>; <span class="comment">// true if not known to be in heap order</span></span><br><span class="line">        <span class="keyword">boolean</span> screen = <span class="keyword">true</span>;  <span class="comment">// true if must screen for nulls</span></span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">            heapify = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityBlockingQueue&lt;?&gt;) &#123;</span><br><span class="line">            PriorityBlockingQueue&lt;? extends E&gt; pq =</span><br><span class="line">                (PriorityBlockingQueue&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">            screen = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (pq.getClass() == PriorityBlockingQueue.class) <span class="comment">// exact match</span></span><br><span class="line">                heapify = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">        <span class="keyword">if</span> (a.getClass() != Object[].class)</span><br><span class="line">            a = Arrays.copyOf(a, n, Object[].class);</span><br><span class="line">        <span class="keyword">if</span> (screen &amp;&amp; (n == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue = a;</span><br><span class="line">        <span class="keyword">this</span>.size = n;</span><br><span class="line">        <span class="keyword">if</span> (heapify)</span><br><span class="line">            heapify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="ArrayBlockingQueue源码分析"><a href="#ArrayBlockingQueue源码分析" class="headerlink" title="ArrayBlockingQueue源码分析"></a>ArrayBlockingQueue源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">817911632652898426L</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(capacity, fair);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                    checkNotNull(e);</span><br><span class="line">                    items[i++] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">            count = i;</span><br><span class="line">            putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == items.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                enqueue(e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">                <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                        removeAt(i);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> items.length - count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">                <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i]))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = count;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">'['</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = takeIndex; ; ) &#123;</span><br><span class="line">                Object e = items[i];</span><br><span class="line">                sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);</span><br><span class="line">                <span class="keyword">if</span> (--k == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">                sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = count;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">                <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    items[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">                takeIndex = putIndex;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                    itrs.queueIsEmpty();</span><br><span class="line">                <span class="keyword">for</span> (; k &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); k--)</span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">        checkNotNull(c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = Math.min(maxElements, count);</span><br><span class="line">            <span class="keyword">int</span> take = takeIndex;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    E x = (E) items[take];</span><br><span class="line">                    c.add(x);</span><br><span class="line">                    items[take] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (++take == items.length)</span><br><span class="line">                        take = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Restore invariants even if c.add() threw</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    count -= i;</span><br><span class="line">                    takeIndex = take;</span><br><span class="line">                    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                            itrs.queueIsEmpty();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; take)</span><br><span class="line">                            itrs.takeIndexWrapped();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); i--)</span><br><span class="line">                        notFull.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架整理(一)</title>
      <link href="/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%B8%80)/"/>
      <url>/2020/02/07/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Java-Map、List、Vector源码分析"><a href="#Java-Map、List、Vector源码分析" class="headerlink" title="Java Map、List、Vector源码分析"></a>Java Map、List、Vector源码分析</h1><p><a href="http://naotu.baidu.com/file/195a5d4c7010b778a85631f5f61ab92c?token=f5c0ec8bbaa0f24e" target="_blank" rel="noopener">脑图</a></p><p><a href="https://upload-images.jianshu.io/upload_images/4061843-77301c3b14d67330.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-77301c3b14d67330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java集合框架脑图"></a>Java集合框架脑图</p><p>Java集合大致分为Set、List、Queue、Map四类。</p><blockquote><p>Set：无序、不可重复的集合<br>List：有序、可重复的集合<br>Queue：队列集合<br>Map：有映射关系的集合</p></blockquote><p>而Java集合最根本的接口主要是<strong>Collection</strong>和<strong>Map</strong>，前三个都是通过Collection接口实现</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><a href="https://img-blog.csdnimg.cn/20190116164907870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener"><img src="https://img-blog.csdnimg.cn/20190116164907870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="Collection"></a>Collection</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//元素数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否包含某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//该Collection的迭代器</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//是否包含某个元素集合Collection</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">        <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">                each.remove();</span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保留当前Collection和c两个的交（共有的元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collection首先继承了Iterable，看Iterable的源码中注释:这个接口是提供了”for-each loop”类似的迭代功能，得到迭代器（Iterator）实现迭代遍历，而Iterator是一种统一遍历集合元素的方式，所以所有实现了Collection的都会默认有一个迭代器，Iterable是为了得到相应的迭代器（每个集合最后迭代的方式可能不一样），接着，Collection中定义了一些常用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回该Collection上的Iterator</span></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证通过指定的action（应该是迭代方式）进行遍历完全</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分割迭代器，用于并行处理的</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是Iterator的代码，相当简单了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collection的代码看完了，接着看看它的实现和相关的接口吧。<br>从脑图中可以看到，继承于Collection的接口有List、Set、Queue，这三个是直接继承的，然后还有一个抽象类AbstractCollection实现了Collection。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过迭代器，遍历判断是否包含</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">                <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">                <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        Object[] r = <span class="keyword">new</span> Object[size()];</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! it.hasNext()) <span class="comment">// fewer elements than expected</span></span><br><span class="line">                <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">            r[i] = it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = size();</span><br><span class="line">        T[] r = a.length &gt;= size ? a :</span><br><span class="line">                  (T[])java.lang.reflect.Array</span><br><span class="line">                  .newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! it.hasNext()) &#123; <span class="comment">// fewer elements than expected</span></span><br><span class="line">                <span class="keyword">if</span> (a == r) &#123;</span><br><span class="line">                    r[i] = <span class="keyword">null</span>; <span class="comment">// null-terminate</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.length &lt; i) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.arraycopy(r, <span class="number">0</span>, a, <span class="number">0</span>, i);</span><br><span class="line">                    <span class="keyword">if</span> (a.length &gt; i) &#123;</span><br><span class="line">                        a[i] = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            r[i] = (T)it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// more elements than expected</span></span><br><span class="line">        <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(it.next())) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E e = it.next();</span><br><span class="line">            sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);</span><br><span class="line">            <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">                <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">            sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个抽象类中，对之前定义的方法进行了处理和实现，添加了逻辑处理。<br>通过迭代器遍历，判断是否包含某个元素（contains）；转换为array（toArray）和指定的数组（toArray(T[] a)），定义了最大容量为Integer.MAX_VALUE - 8；删除处理（remove）；清空集合处理（clear）；toString重写。</p><p>AbstractCollection这个抽象类的子类又根据实现不同的接口（List、Set、Queue）得到AbstractList、AbstractSet、AbstractQueue这几个分别对应的抽象类，然后常用的ArrayList、Vector、HashSet、PriorityQueue、DelayQueue等都是直接或间接继承这几个对应的抽象类来实现的。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        <span class="keyword">final</span> ListIterator&lt;E&gt; li = <span class="keyword">this</span>.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">            li.set(operator.apply(li.next()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List直接继承自Collection，然后定义了很多方法，其中有一部分跟父接口Collecion中是一样的；然后List有定义了一些适合自己的方法（如get、set等），还添加了一个Sort方法用于排序，比Collection多了一种为List定制的ListIterator</p><p>总之，List的源码也没啥看的，也很简单；看了List的源码，后面看Set、Queue的源码都差不多，因为都是继承自Collection，然后根据自己的特性，添加了属于自己的方法和迭代器。这些特性呢，其实就跟学的数据结构一个道理，只不过Java封装的更好、更完善</p><p>看看AbstractList吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        add(size(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总是会抛出这个异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过迭代遍历，找到下标，从0开始</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ListIterator&lt;E&gt; it = listIterator();</span><br><span class="line">        <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">                <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">                <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                    <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一次出现的下标，从最后一个开始，向前遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过迭代器remove</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ListIterator，默认0开始迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从某个下标开始的迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ListIterator实现类，nextIndex就是当前cursor，previousIndex，就是cursor-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            cursor = index;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取集合中的某一部分子集来进行操作，是直接在原数据上进行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个AbstractListd的比较，同时迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">        ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">        <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">            E o1 = e1.next();</span><br><span class="line">            Object o2 = e2.next();</span><br><span class="line">            <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : <span class="keyword">this</span>)</span><br><span class="line">            hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//subList实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; l;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SubList(AbstractList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机访问，通过它可以间接操控父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomAccessSubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码好像有点多，怎么说呢，AbstractList基本囊括了所有的List操作，基本上平时用到的大多数都在这个源码里面，当然get方法还待实现，后面的ArrayList、Vector、Stack就是根据相应的进行特殊的操作了</p><p>下面看看常用的List吧，都继承于AbstractList这个抽象类：</p><ul><li><p>LinkedList<br>  LinkedList是继承自AbstractSequenceList这个抽象类，而AbstractSequenceList又是继承自AbstractList的</p><p>  <a href="./Java集合框架整理(五)——LinkedList源码分析.md">Java集合框架整理(五)——LinkedList源码分析</a></p></li><li><p>ArrayList</p><ol><li><p>动态数组，线程非安全，允许null</p></li><li><p>可以手动调用扩容</p></li><li><p>默认是空数组构造，默认容量是10</p></li><li><p>扩容默认扩容1.5倍</p></li><li><p>add通过移动数组，remove也是移动数组进行覆盖，数组的拷贝是通过native方法（System.arraycopy）</p></li><li><p>clear操作就是置为null</p><p><a href="./Java集合框架整理(八)——ArrayList源码分析.md">Java集合框架整理(八)——ArrayList源码分析</a></p></li></ol></li><li><p>SparseArray</p><ol><li>int型的key，Object型的value，HashMap则是任意类型</li><li>一个数组存放key，一个数组存放value；key是有序的</li><li>不再使用像HashMap的Entry</li><li>只实现了Cloneable接口，默认容量是10</li><li>通过二分查找法来查找插入的下标index，如果返回的是负值表明该位置没有被占用，可以直接取反获取下标</li><li>删除数据后不会直接移动数据进行覆盖，而是将删除的位置标记为DELETE，标明当前位置没有数据，那么在put时，有原值直接覆盖且不会返回，HashMap会返回原值，发现要插入的位置是DELETE，就直接插入，但是如果发现该位置已经有值了（key值不一样），那么触发gc，调整其他位置的DELETE并删除无用的key，重新计算下标再进行插入；如果容量已经满了，则扩容后插入</li><li>扩容时，当前容量小于等于4，则扩容后容量为8.否则为当前容量的两倍</li></ol></li><li><p>Vector</p><ol><li><p>默认容量10，增长系数0，扩容翻倍</p></li><li><p>通过synchronized 来保证线程安全</p></li><li><p>允许元素为null</p><p><a href="./Java集合框架整理(六)——Vector和Stack源码分析.md">Java集合框架整理(六)——Vector和Stack源码分析</a></p></li></ol></li><li><p>Stack<br>  继承自Vector</p></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咋一看，好像跟Collection没啥区别，就是多了默认的分割迭代器。因为特性的原因，方法比List少了一部分（如sort、get、set、listIterator、subList等等）</p><p>看看AbstractSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span><br><span class="line">        <span class="keyword">if</span> (c.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> containsAll(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        Iterator&lt;E&gt; i = iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            E obj = i.next();</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="keyword">null</span>)</span><br><span class="line">                h += obj.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//以少的为循环条件</span></span><br><span class="line">        <span class="keyword">if</span> (size() &gt; c.size()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); )</span><br><span class="line">                modified |= remove(i.next());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                    i.remove();</span><br><span class="line">                    modified = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码好像也没啥，就对equals、hashCode进行实现，removeAll修改了一下，以元素少的为遍历条件进行删除</p><ul><li>HashSet<ol><li>基于HashMap实现，底层保存数据使用HashMap</li><li>有内部排序，当重复的时候不会放入内部的HashMap</li></ol></li><li>LinkedHashSet</li><li>TreeSet</li></ul><p><a href="./Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析.md">Java集合框架整理(七)——TreeSet、HashSet、LinkedHashSet源码分析</a></p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没看错，Queue的代码就这么点；没有去再给自己一个迭代器，用的就是Collection的，多了offer、poll、element、peek等方法</p><p>就直接看看AbstractQueue这个抽象类吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (offer(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E x = poll();</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E x = peek();</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (poll() != <span class="keyword">null</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)</span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也是很少，add方法最终是通过offer来处理的，remove就是通过poll来处理的，element是通过peek方法来处理的，clear也是通过poll来处理的，这些方法都是需要后面实现的。</p><p>接着看看几种Queue和Deque常用类吧</p><ul><li>线程安全的Queue<br>  ConcurrentLinkedDeque、ConcurrentLinkedQueue、LinkedBlockingQueue、LinkedBlockingDeque、<a href="./Java集合框架整理(一)——PriorityBlockingQueue、ArrayBlockingQueue源码分析.md">Java集合框架整理(一)——PriorityBlockingQueue、ArrayBlockingQueue源码分析</a></li><li>线程非安全的Queue<br>  <a href="./Java集合框架整理(四)——PriorityQueue、DelayQueue源码分析.md">Java集合框架整理(四)——PriorityQueue、DelayQueue源码分析</a>、LinkedTransferQueue</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://img-blog.csdnimg.cn/20190116165243432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener"><img src="https://img-blog.csdnimg.cn/20190116165243432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="Map"></a>Map</p><blockquote><p>Map作为另一个大类的集合，我们用的也不算少<br>Map是一种数据映射关系的集合，是以键值对的形式存储（key-value），其中key不可重复</p></blockquote><p>首先看看Map这个根接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;  <span class="comment">//元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  <span class="comment">//是否为空集合</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;  <span class="comment">//是否包含某个键key</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;  <span class="comment">//是否包含某个值</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;  <span class="comment">//获取</span></span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;  <span class="comment">//存入一个元素</span></span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;  <span class="comment">//根据键删除某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;  <span class="comment">//添加一个map集合</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;  <span class="comment">//清空</span></span><br><span class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;  <span class="comment">//返回key的Set集合</span></span><br><span class="line">    <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;  <span class="comment">//返回value的Collection集合</span></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();  <span class="comment">//返回Entry（具有键值对）的Set集合</span></span><br><span class="line">    <span class="comment">//Map内部的一个接口，同时存有key和value，用于entrySet返回</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K extends Comparable&lt;? <span class="keyword">super</span> K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V extends Comparable&lt;? <span class="keyword">super</span> V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? <span class="keyword">super</span> K&gt; cmp) &#123;</span><br><span class="line">            Objects.requireNonNull(cmp);</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? <span class="keyword">super</span> V&gt; cmp) &#123;</span><br><span class="line">            Objects.requireNonNull(cmp);</span><br><span class="line">            <span class="keyword">return</span> (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">                (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;  <span class="comment">//hash值</span></span><br><span class="line">    <span class="comment">//根据key获取value默认要指定一个默认值，防止获取不存在的值（不存在的key）。貌似是后来加上的</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key))</span><br><span class="line">            ? v</span><br><span class="line">            : defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据action默认的foreach，key和value都会参与</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                k = entry.getKey();</span><br><span class="line">                v = entry.getValue();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalStateException ise) &#123;</span><br><span class="line">                <span class="comment">// this usually means the entry is no longer in the map.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException(ise);</span><br><span class="line">            &#125;</span><br><span class="line">            action.accept(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过遍历，然后根据function来替换原有的值</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(function);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                k = entry.getKey();</span><br><span class="line">                v = entry.getValue();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalStateException ise) &#123;</span><br><span class="line">                <span class="comment">// this usually means the entry is no longer in the map.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException(ise);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ise thrown from function is not a cme.</span></span><br><span class="line">            v = function.apply(k, v);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                entry.setValue(v);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IllegalStateException ise) &#123;</span><br><span class="line">                <span class="comment">// this usually means the entry is no longer in the map.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException(ise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        V v = get(key);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            v = put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据键值对删除指定的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        Object curValue = get(key);</span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(curValue, value) ||</span><br><span class="line">            (curValue == <span class="keyword">null</span> &amp;&amp; !containsKey(key))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        remove(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//替换，最终是通过put实现</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">        Object curValue = get(key);</span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(curValue, oldValue) ||</span><br><span class="line">            (curValue == <span class="keyword">null</span> &amp;&amp; !containsKey(key))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        V curValue;</span><br><span class="line">        <span class="keyword">if</span> (((curValue = get(key)) != <span class="keyword">null</span>) || containsKey(key)) &#123;</span><br><span class="line">            curValue = put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">            Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(mappingFunction);</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> ((v = get(key)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V newValue;</span><br><span class="line">            <span class="keyword">if</span> ((newValue = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                put(key, newValue);</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">computeIfPresent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">            BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">if</span> ((oldValue = get(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">            <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                put(key, newValue);</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                remove(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">compute</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">            BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line">        V oldValue = get(key);</span><br><span class="line"></span><br><span class="line">        V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// delete mapping</span></span><br><span class="line">            <span class="keyword">if</span> (oldValue != <span class="keyword">null</span> || containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// something to remove</span></span><br><span class="line">                remove(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// nothing to do. Leave things as they were.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// add or replace old mapping</span></span><br><span class="line">            put(key, newValue);</span><br><span class="line">            <span class="keyword">return</span> newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">            BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(remappingFunction);</span><br><span class="line">        Objects.requireNonNull(value);</span><br><span class="line">        V oldValue = get(key);</span><br><span class="line">        V newValue = (oldValue == <span class="keyword">null</span>) ? value :</span><br><span class="line">                   remappingFunction.apply(oldValue, value);</span><br><span class="line">        <span class="keyword">if</span>(newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            put(key, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><a href="./Java集合框架整理(二)——HashMap源码分析.md">Java集合框架整理(二)——HashMap源码分析</a></p><h4 id="1-7和1-8的区别"><a href="#1-7和1-8的区别" class="headerlink" title="1.7和1.8的区别"></a>1.7和1.8的区别</h4><ol><li>1.7的一些运算赋值在1.8中变为了位运算，一些判断也从Math变为了if else</li><li>JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算。1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</li><li>1.7扩容函数是在确定要扩容进行，1.8的扩容函数可能是初始化；1.7更新阈值在扩容后，1.8在扩容前，很多判断、阈值更新都是在扩容前</li><li>1.8扩容后进行复制时，会先进行链表的一个判断（当前链表只有一个元素时），1.7没有；1.8有链表高低位的处理，是将整个旧链表复制到新的中，低位链表的索引跟原来的一样，高位的则放在新的索引处（尾插法），1.7则是遍历旧链表，头插法插入新链表（可能导致逆序）</li><li>1.8中加入了红黑树，当链表长度到8时链表转化为红黑树，扩容时，重新计算存储位置，红黑树内数量&lt;6又会转化为链表</li><li>key和value都允许为null（key只能有一个为null，而value则可以有多个为null）</li></ol><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ol><li>1.6使用ReentrantLock保证并发安全，1.8使用CAS（Compare and Swipe）和synchronized 来保证并发安全</li><li>1.8有红黑树的概念，使用红黑树，这些跟1.8的HashMap一样</li><li>由于并发的问题，在扩容的时候是采用单线程初始化大小，多个线程共同进行值的复制</li><li>1.6头插法，1.8逆序插入链表</li><li>1.6删除操作要重新复制一次链表，所以1.7并不绝对并发安全（删除没有完全的时候旧链表存在）</li><li>1.6next是final修饰，1.8不用</li></ol><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ol><li>数组+哈希表，非线程安全</li><li>key、value允许为null</li><li>继承自HashMap，有一个双向链表</li><li>相比HashMap，增加了accessOrder参数控制迭代时的结点顺序</li><li>增删数据，都是调用的HashMap的函数，只是修改了一些链头链尾指向的结点</li><li>accessOrder=true的模式下,在afterNodeAccess()函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。值得注意的是，afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变</li></ol><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><ol><li>默认容量是11，不要求底层数组的容量一定要为2的整数次幂</li><li>扩容后重新计算index 求余（%），扩容是2倍+1</li><li>clear操作仅仅是将table（数组）设为null</li><li>每一个方法都是用synchronized 修饰来保证线程安全</li><li>Hashtable中key和value都不允许为null</li><li>计算hash值，直接用key的hashCode()</li><li>拉链法，hashSeed ^ k.hashCode()解决Hash冲突</li><li>所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException 异常，而不是等到迭代完成之后才告诉你（你已经出错了）。</li></ol><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ol><li>TreeMap是根据key进行排序的，它的排序和定位需要依赖比较器或覆写Comparable接口</li><li>key不能为null</li><li>就是红黑树实现</li><li>非线程同步</li></ol><h3 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h3><ol><li>两个数组，int型存放hashcod，Object型保存键值对，int型的2倍容量</li><li>扩容时只拷贝数组，不重建hash表</li><li>删除时，如果集合剩余元素少于一定阈值，数组会收缩（容量减小）</li><li>对key从小到大排序，二分法查询key的下标</li><li>默认扩容size是4，默认容量为0</li><li>put操作出来计算hashcode外，其余跟SparseArray基本类似，也类似于ArrayList</li><li>扩容规则：如果容量大于8，则扩容一半。</li><li>mHashes长度大于8，且 集合长度 小于当前空间的 1/3,则执行一个 shrunk，收缩操作</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 泛型总结</title>
      <link href="/2020/02/07/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="泛型总结"><a href="#泛型总结" class="headerlink" title="泛型总结"></a>泛型总结</h1><p><strong>声明</strong>：部分面试题来自微信公众号<strong>码农每日一题</strong></p><p>Java 5开始引进，实现<strong>参数化类型</strong>的概念，是Java中的一种语法糖</p><h2 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h2><ul><li><p>创建</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder&lt;String&gt; holder = <span class="keyword">new</span> Holder&lt;String&gt;(<span class="string">"abc"</span>);</span><br><span class="line">        String str = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元组<br>  将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中的元素，但是不允许存放新的对象（这个概念也称为数据传递对象或信使）</p><p>  创建一个二维元组：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line">    <span class="comment">//有次序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = a;</span><br><span class="line">        <span class="keyword">this</span>.second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + first + <span class="string">", "</span> + second + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在之前的基础上创建一个三维元组：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a, b);</span><br><span class="line">        third = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + first + <span class="string">", "</span> + second + <span class="string">", "</span> + third + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型实现堆栈</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line"></span><br><span class="line">        Node() &#123;</span><br><span class="line">            item = <span class="keyword">null</span>;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(U item, Node&lt;u&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;T&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span> (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>generator，生成器，专门负责创建对象的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ul><li><p>参数固定</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变参数类型</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T item : args) &#123;</span><br><span class="line">            result.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化元组的使用<br>  通过重载static方法创建元组</p></li></ul><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。原始类型的名字就是删除类型参数后的泛型类型名。擦除类型变量，并替换为限定类型（无限定时用Object）</p><p>引例：C#中泛型在所有过程（程序源码、编译后的IL、运行期的CLR）中都切实存在，List&lt;int&gt;和List&lt;String&gt;就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，属于真泛型<br>java中的泛型只在源码中存在，在编译后的字节码文件中，会替换为原来的原生类型（裸类型），并且在相应的地方插入强制类型转换。所以ArrayList&lt;int&gt;和ArrayList&lt;String&gt;就是同一个类，这种实现称为类型擦除，属于伪泛型</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型擦除前</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">map.put(<span class="string">"How are you"</span>, <span class="string">"最近怎么样"</span>);</span><br><span class="line">System.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">System.out.println(map.get(<span class="string">"How are you"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后。类型擦除后</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">map.put(<span class="string">"How are you"</span>, <span class="string">"最近怎么样"</span>);</span><br><span class="line">System.out.println((String) map.get(<span class="string">"hello"</span>));</span><br><span class="line">System.out.println((String) map.get(<span class="string">"How are you"</span>));</span><br></pre></td></tr></table></figure><p>在map根据键获取值的时候，编译后会自动加上String进行强转，也就是底层的Java并没有实现真正的泛型</p><p>再比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法重载是错的，不能被编译，通过Idea，你会发现会提示你List&lt;String&gt;和List&lt;Integer&gt;两个参数是一个类，所以不能进行重载。在JVM中说到当两个方法拥有不同的返回值后，便是可以编译的（java 6），但是我在Java 8中还是不能编译。</p><ul><li><p>迁移兼容性<br>  在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型。只有在静态类型检查期间才会出现，在此之后，所有的泛型类型都会被擦除，替换为它们的非泛型上界。</p></li><li><p>擦除的问题<br>  泛型不能用于显示地引用运行时类型的操作中，例如转型、instanceof操作、new表达式。因为所有关于参数的类型信息都丢失了。</p><ol><li><p>泛型类并没有自己独有的Class类对象。<br> 比如并不存在List&lt;String&gt;.class或是List&lt;Integer&gt;.class，而只有List.class。</p></li><li><p>静态变量是被泛型类的所有实例所共享的。<br> 对于声明为MyClass&lt;T&gt;的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。&gt;不管是通过new MyClass&lt;String&gt;还是new MyClass&lt;Intege\r&gt;创建的对象，都是共享一个静态变量。</p></li><li><p>泛型的类型参数不能用在Java异常处理的catch语句中。（不能抛出或捕获泛型类的实例）<br> 因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException&lt;String&gt;和MyException&lt;Integer&gt;的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能扩展Throwable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="title">entends</span> <span class="title">Exception</span> </span>&#123;&#125;  <span class="comment">//Error: can't extend Throwable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//catch语句不能使用类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(T e) &#123;</span><br><span class="line">        <span class="comment">//Error: can't catch type variable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 但是在异常规范中使用类型变量是允许的 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do work</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable realCause) &#123;</span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="4"><li><p>泛型不能用于显示地引用运行时类型的操作之中，例如转型、instanceof操作、new表达式  </p></li><li><p>不能用基本类型实例化类型参数<br> 没有Pair&lt;double&gt;，只有Pair&lt;Double&gt;，因为擦除后，Pair类含有Object类型的域，而Object不能存储double值  </p></li><li><p>运行时类型查询只适用于原始类型<br> Java虚拟机中总有一个特定的非泛型类型  </p></li><li><p>不能创建参数化类型的数组（但是可以声明参数化类型的数组）<br> 因为擦除后，类型进行了强转<br> <code>Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10];</code><br> 擦除后，table的类型是Pair[]，可以把它转为Object[]，<br> <code>Object[] objarray = table;</code><br> 数组会记住它的元素类型，如果试图存储其他类型，就会抛出一个ArrayStoreException异常<br> <code>objarray[0] = &quot;hello&quot;;  //Error</code></p></li><li><p>不能实例化类型变量<br> Java 8之后，最好的方法是让调用者提供一个构造器表达式<br> Pair<string> p = Pair.makePair(String::new);</string></p></li></ol><p>//makePair方法接收一个Supplier<t>，这是一个函数式接口<br>public static <t> Pair<t> makePair(Supplier<t> constr) {<br>    return new Pair&lt;&gt;(constr.get(), constr.get());<br>}</t></t></t></t></p><p>​    或者传统的方法通过反射调用</p><ol start="9"><li>不能构造泛型数组<br> 数组会填充null值，构造时看上去时安全的。但是数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被擦除。<br> 例如：<br> public static <t extends comparable> T[] minmax(T[] a) {<br> T[] mm = new T[2];  //Error<br>}</t></li></ol><p>​    类型擦除会让这个方法永远构造Comparable[2]数组  </p><ol start="10"><li><p>类型擦除与多态的冲突  </p></li><li><p>类型擦除后的冲突<br>无法创建引发冲突的条件 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value);</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>​    擦除后，boolean equals(T)就是boolean equals(Object)，与Object.equals方法冲突</p><ol start="12"><li>泛型中参数化类型无法支持继承关系（但可以扩展或实现其他的泛型类）<br>ArrayList&lt;T&gt;类实现List&lt;T&gt;接口</li></ol><ul><li>泛型其他注意事项</li></ul><ol><li><p>泛型类的静态上下文中类型变量无效</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T singleInstance;  <span class="comment">//Error</span></span><br><span class="line">    <span class="comment">//Error</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getSingleInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//constuct new instance of T</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 禁止使用带有类型变量的静态域和方法</p></li><li><p>可以消除对受查异常的检查</p></li></ol><h2 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> T) &#123;&#125;  <span class="comment">//报错，泛型不能使用instanceof操作</span></span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T();  <span class="comment">//报错，泛型不能new操作</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];  <span class="comment">//报错，不能创建泛型数组</span></span><br><span class="line">        T[] array1 = (T) <span class="keyword">new</span> Object[SIZE];  <span class="comment">//警告，泛型可以通过引入类型标签来对擦除进行补偿</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于new T()，泛型的实例化无法实现的原因，一部分因为擦除，另一部分是因为编译器不能验证T具有默认（无参）构造器。</p><p><strong>注意</strong>：在C++中，泛型是可以进行实例化的，并且是安全的，也就是可以T var = new T()这个操作的。</p><ul><li><p>如何创建类型实例</p><p>  传递一个工厂对象</p><ol><li>使用显示的工厂对象</li><li>模板方法设计模式</li></ol></li></ul><h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><ul><li><p>如何创建一个泛型数组？</p><ol><li><p>使用ArrayList（类型安全）</p></li><li><p>按照编译器喜欢的方式定义一个引用（可以编译但是不能运行）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenericReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过类型强转，需要注意的是运行时仍然会产生异常</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> Object[sz];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> T[] rep() &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) array;  <span class="comment">//Waring: unchecked cast</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray&lt;Integer&gt; gai = <span class="keyword">new</span> GenericArray&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            gai.put(i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(gai.get(i)+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer[] ia = gai.rep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果</span></span><br><span class="line"><span class="comment"> * 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment"> * java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to              [Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>提供一个数组构造表达式</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器表达式指示一个函数，给定所需的长度，会构造一个指定长度的String数组</span></span><br><span class="line">String[] ss = ArrayAlg.minmax(String[]::<span class="keyword">new</span>, <span class="string">"Tom"</span>, <span class="string">"Dark"</span>, <span class="string">"Hary"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(IntFunction&lt;T[]&gt; constr, T... a) &#123;</span><br><span class="line">    T[] mm = constr.apply(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>老式的方法：通过反射</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T... a) &#123;</span><br><span class="line">    T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul><li><p>上边界限定通配符：&lt;? extends Fruit&gt;<br>  先了解一些数组的一种特殊行为：可以向导出类型的数组赋予基类型的数组引用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = <span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">        fruit[<span class="number">0</span>] = <span class="keyword">new</span> Apple();  <span class="comment">//OK</span></span><br><span class="line">        fruit[<span class="number">2</span>] = <span class="keyword">new</span> Jonathan();  <span class="comment">//OK</span></span><br><span class="line">        <span class="comment">//Runtime type is Apple[], not fruit[] or Orange[]:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Complier allows you to add Fruit</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Fruit[];  <span class="comment">//ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Complier allows you to add Oranges</span></span><br><span class="line">            fruit[<span class="number">0</span>] = <span class="keyword">new</span> Orange();  <span class="comment">//ArrayStoreException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * java.lang.ArrayStoreException: Fruit</span></span><br><span class="line"><span class="comment"> * java.lang.ArrayStoreException: Orange</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>  mian()中创建了一个<strong>Apple</strong>数组，并将其赋值给一个<strong>Fruit</strong>数组引用，这是有意义的，因为<strong>Apple</strong>也是一种<strong>Fruit</strong>，因此<strong>Apple</strong>数组也应该是一种<strong>Fruit</strong>数组。<br>  编译器允许你将<strong>Fruit</strong>放置到这个<strong>Apple</strong>数组（放入Fruit和Orange，向上转型），因为对编译器来说时有意义的，但是运行时的数组机制知道处理的实际上时<strong>Apple[]</strong>（所以只能在其中放置Apple或Apple的子类），因此会在向数组中放置异构类型时抛出异常</p><p>  泛型的目的之一就是将这种错误检测移入到编译期，看看使用泛型容器会怎么样？</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCovariantGenerics</span> </span>&#123;</span><br><span class="line">    List&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  无法编译，实际上这不是向上转型——<strong>Apple</strong>的<strong>List</strong>不是<strong>Fruit</strong>的<strong>List</strong>，<strong>Apple</strong>的<strong>List</strong>持有Apple和Apple的子类，<strong>Fruit</strong>的<strong>List</strong>持有Fruit和Fruit的子类，尽管包含了Apple，但它终究不是<strong>Apple</strong>的<strong>List</strong>，它仍旧是<strong>Fruit</strong>的<strong>List</strong>。类型上两者并不等价，尽管Apple是Fruit的子类。</p><p>  <strong>接下来进入正题，使用通配符</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? entends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        <span class="comment">// Compile Error: can’t add any type of object:</span></span><br><span class="line">        <span class="comment">// flist.add(new Apple());  //这种向上转型，会丢失向其中传递任何对象的能力（包括Object）</span></span><br><span class="line">        <span class="comment">// flist.add(new Fruit());</span></span><br><span class="line">        <span class="comment">// flist.add(new Object());</span></span><br><span class="line">        flist.add(<span class="keyword">null</span>); <span class="comment">// Legal but uninteresting  没有意义</span></span><br><span class="line">        <span class="comment">// We know that it returns at least Fruit:</span></span><br><span class="line">        Fruit f = flist.get(<span class="number">0</span>);  <span class="comment">//在这个 List 中，不管它实际的类型到底是什么，但肯定能转型为 Fruit，所以编译器允许返回 Fruit。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  flist现在的类型是List&lt;? extends Fruit&gt;，可以理解为继承Fruit的类型的列表（通俗点就是继承了Fruit的类的List），但实际上并不意味着这个List将持有任何类型的Fruit。通配符引用的是明确的类型，因此它意味着“某种flist引用没有指定的具体类型”。因此这个被赋值的List必须持有Fruit或Apple这样的某种指定类型。</p><p>  了解了通配符的作用和限制后，好像任何接受参数的方法我们都不能调用了。其实倒也不是，看下面的例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerIntelligence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist =</span><br><span class="line">        Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple a = (Apple)flist.get(<span class="number">0</span>); <span class="comment">// No warning</span></span><br><span class="line">        flist.contains(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is ‘Object’</span></span><br><span class="line">        flist.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is ‘Object’</span></span><br><span class="line">        <span class="comment">//flist.add(new Apple());   无法编译</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  contains 和 indexOf 方法正常执行，add方法无法编译。通过ArrayList的源码发现，add()接收的是一个泛型类作为参数，contains 和 indexOf 方法接收的是一个Object类型的参数。因此当你指定一个ArrayList&lt;? extends Fruit&gt;时，add()的参数就变成了“? extends Fruit”，而contains 和 indexOf 方法两个的参数仍是Object类型，不涉及任何通配符。</p><p>  为了在类型中使用了通配符的情况下禁止这类的调用，需要在类型参数列表中使用类型参数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder&lt;Apple&gt; Apple = <span class="keyword">new</span> Holder&lt;Apple&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple d = Apple.get();</span><br><span class="line">        Apple.set(d);</span><br><span class="line">        <span class="comment">// Holder&lt;Fruit&gt; Fruit = Apple; // Cannot upcast 有了边界，无法向上转型</span></span><br><span class="line">        Holder&lt;? extends Fruit&gt; fruit = Apple; <span class="comment">// OK</span></span><br><span class="line">        Fruit p = fruit.get();</span><br><span class="line">        d = (Apple) fruit.get(); <span class="comment">// Returns ‘Object’</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Orange c = (Orange) fruit.get(); <span class="comment">// No warning</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fruit.set(new Apple()); // Cannot call set()  编译器无法验证其类型安全</span></span><br><span class="line">        <span class="comment">// fruit.set(new Fruit()); // Cannot call set()</span></span><br><span class="line">        System.out.println(fruit.equals(d)); <span class="comment">// OK  接受的参数时Object类型，编译器可以识别</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Output: (Sample)</span></span><br><span class="line"><span class="comment"> *java.lang.ClassCastException: Apple cannot be cast to Orange</span></span><br><span class="line"><span class="comment"> *true</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>超类型通配符：&lt;? super MyClass&gt;<br>  使用超类通配符就可以安全的传递类型对象，声明通配符是由某个特定类的任何基类来界定</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">// apples.add(new Fruit()); // Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  writeTo 方法的参数 apples 的类型是 List&lt;? super Apple&gt;，它表示某种类型的 List，这个类型是 Apple 的基类型。也就是说，我们不知道实际类型是什么，但是这个类型肯定是 Apple 的父类型。因此，我们可以知道向这个 List 添加一个 Apple 或者其子类型的对象是安全的，这些对象都可以向上转型为 Apple。Apple是下届，不能添加Fruit（违反静态类型安全）。</p></li><li><p>无界通配符：&lt;?&gt;<br>  意味着“任何事物”，很多情况可以认为是一种装饰。</p></li></ul><p><strong>总结</strong>：写入类型参数，使用超类型通配符，读取类型参数，使用上边界限定通配符</p><h2 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h2><ul><li><p>泛型Class类<br>  现在Class类是泛型的，例如String.class实际上是一个Class&lt;String&gt;类的对象（唯一的对象）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个无参数构造器构造的一个新实例。它的返回类型被声明为T，其类型与Class&lt;T&gt;描述的类相同，这样避免了类型转换</span></span><br><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如果obj为null或有可能转换成类型T，则返回obj，否则抛出BadCastException异常</span></span></span><br><span class="line"><span class="function">T <span class="title">cast</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如果T是枚举类型，则返回所有值组成的数组，否则返回null</span></span></span><br><span class="line"><span class="function">T[] <span class="title">getEnumConstants</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回这个类的超类，如果T不是一个类或Object类，则返回null</span></span></span><br><span class="line"><span class="function">Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获得公有的构造器或带有给定参数类型的构造器</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回用指定类型构造的新实例</span></span></span><br><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">(Object... parameters)</span></span></span><br></pre></td></tr></table></figure></li><li><p>虚拟机中的泛型类型信息<br>  擦除的类型仍然保留了一些泛型祖先的微弱记忆。<br>  <code>public static Comparable min(Comparable[] a)</code>是<code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] a)</code>的泛型方法擦除后。但是可以使用反射API来知道以下信息：</p><ol><li><p>这个泛型方法有一个叫做T的类型参数</p></li><li><p>这个类型参数有一个子类型限定，其自身又是一个泛型类型</p></li><li><p>这个限定类型有一个通配符参数</p></li><li><p>这个通配符参数有一个超类型限定</p></li><li><p>这个泛型方法有一个泛型数组参数</p><p> 换句话说，知道需要重新构造实现者声明的泛型类型以及方法中的所有内容，只是不知道对于特定的对象或方法调用，以及如何解释类型参数</p></li></ol></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li><p>泛型原理，举例说明；</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder&lt;String&gt; holder = <span class="keyword">new</span> Holder&lt;String&gt;(<span class="string">"abc"</span>);</span><br><span class="line">        String str = holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 创建的时候指明Holder持有什么类型的对象，置于&lt;&gt;中，获取的时候会自动的就是正确的类型</p></li><li><p>什么是泛型中的限定通配符和非限定通配符<br> 限定通配符有上界限定通配符&lt;? entends T&gt;和超类型限定通配符（下届限定通配符）&lt;? super T&gt;<br> 非限定通配符是指&lt;T&gt;，表示可以用任意泛型类型来替代，可以在某种意义上来说是泛型向上转型的语法格式</p></li><li><p>简单讲一下泛型、泛型有什么作用、运行期可以确定类型吗？<br> Java 5开始，“泛型” 意味着编写的代码可以被不同类型的对象所重用。<br> 作用：类型的参数化，就是可以把类型像方法的参数那样传递，实现了参数化类型的概念，使代码可以应用与多种类型</p><p> 运行期可以确定类型，因为Java中的泛型只存在在源代码中，在编译后，类型都会强转为相应的类型</p></li><li><p>Java泛型了解吗，知道它的运行机制吗？<br> 通过类型擦除实现，Java中的泛型基本上都是在编译器这个层次来实现的，在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉，这个过程就称为类型擦除。如在代码中定义的List’<object>和List&lt;String&gt;等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</object></p></li><li><p>泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt;<br> E - Element (在集合中使用，因为集合中存放的是元素)<br> T - Type（Java 类）<br> K - Key（键）<br> V - Value（值）<br> N - Number（数值类型）<br> ？ - 表示不确定的java类型</p><p> 一个方法如果接收List&lt;Object&gt;作为形式参数，那么如果尝试将一个List&lt;String&gt;的对象作为实际参数传进去，却发现无法通过编译。虽然从直觉上来说，Object是String的父类，这种类型转换应该是合理的。但是实际上这会产生隐含的类型转换问题，因此编译器直接就禁止这样的行为。</p></li><li><p>需要泛型之间的类型转换怎么做？通配符？与PECS<br> （1）如果你是想遍历collection，并对每一项元素操作时，此时这个集合时生产者（生产元素），应该使用 Collection&lt;? extends E&gt;，因为相对于你泛型E，能放进E中的（把Collection中的元素放入E类型中） ，应该是E的子类型。</p><p> （2）如果你是想添加元素到collection中去，那么此时集合时消费者（消费元素）应该使用Collection&lt;? super E&gt;，同理，你要将E类的元素放入Collection中去，那么Collection应该存放的是E的父类型。</p></li><li><p>泛型的检测：不符合泛型T的检测<br> 在进行编译之前就对所有泛型进行检测，加入类型检测和转换的指令，比如返回泛型的结果实际上返回的是擦出后的类型，而虚拟机会多加一个类型转换的指令</p></li><li><p>Java 如何优雅的实现元组？<br> 创建一个二维元组：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line">    <span class="comment">//有次序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = a;</span><br><span class="line">        <span class="keyword">this</span>.second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + first + <span class="string">", "</span> + second + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么 Java 泛型要通过擦除来实现？擦除有什么坏处或者说代价？<br> 擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言，为了兼容性考虑（废话一大堆，就是为了能使泛型封号的融入Java，不能影响以前的代码）</p><p> （1）泛型不能用于显示地引用运行时类型的操作之中，例如转型、instanceof操作、new表达式<br> （2）擦除和兼容性导致了使用泛型并不是强制的（如 List&lt;String&gt; list = new ArrayList(); 等写法）<br> （3）导致编码谨慎，考虑边界操作</p></li><li><p>请比较深入的谈谈你对 Java 泛型擦除的理解和带来的问题认识？<br>参考<a href="https://www.cnblogs.com/huansky/p/8043149.html" target="_blank" rel="noopener">java 泛型基础问题汇总</a><br>类型擦除的基本过程也比较简单，在编译成字节码时，首先是进行类型检查，然后找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉&lt;&gt;的内容。比如T get()方法声明就变成了Object get()；List&lt;String&gt;就变成了List。接下来就可能需要生成一些桥接方法（bridge method）。这是由于擦除了类型之后的类可能缺少某些必须的方法。<br>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyString</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类型信息被擦除之后，上述类的声明变成了class MyString implements Comparable。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的int compareTo(Object)方法。这个时候就由编译器来动态生成这个方法</p><p>问题：<br>（1）泛型类并没有自己独有的Class类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如并不存在List\&lt;String\&gt;.class或是List\&lt;Integer\&gt;.class，而只有List.class。</span><br></pre></td></tr></table></figure><p>（2）静态变量是被泛型类的所有实例所共享的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于声明为MyClass\&lt;T\&gt;的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过<span class="keyword">new</span> MyClass\&lt;String\&gt;还是<span class="keyword">new</span> MyClass\&lt;Intege\r&gt;创建的对象，都是共享一个静态变量。</span><br></pre></td></tr></table></figure><p>（3）泛型的类型参数不能用在Java异常处理的catch语句中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException\&lt;String\&gt;和MyException\&lt;Integer\&gt;的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的<span class="keyword">catch</span>语句。</span><br></pre></td></tr></table></figure><p>（4）泛型不能用于显示地引用运行时类型的操作之中，例如转型、instanceof操作、new表达式<br>（5）不能用基本类型实例化类型参数<br>（6）运行时类型查询只适用于原始类型<br>（7）不能创建参数化类型的数组<br>（8）不能实例化类型变量<br>（9）不能构造泛型数组<br>（10）类型擦除与多态的冲突<br>（11）类型擦除后的冲突<br>（12）泛型中参数化类型无法支持继承关系<br>（13）为兼容性带来了问题</p></li><li><p>为什么 Java 的泛型数组不能采用具体的泛型类型进行初始化？<br>因为泛型只存在源代码中，编译后，泛型擦除，就会被强转为Object[]，数组会记住它的元素类型，试图存储其他类型就会抛出ArraySotreException异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.</span></span><br><span class="line">Object o = lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check</span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br></pre></td></tr></table></figure><p>由于 JVM 泛型的擦除机制，所以上面代码可以给 oa[1] 赋值为 ArrayList 也不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现 ClassCastException，如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误，只有在运行时才会出错，但是泛型的出现就是为了消灭 ClassCastException，所以如果 Java 支持泛型数组初始化操作就是搬起石头砸自己的脚。</p></li><li><p>如何正确的初始化泛型数组实例？<br>（1）通过声明通配类型的数组，然后进行类型转换（不是很安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenricArray&lt;String&gt;[] array = (GenericArray&lt;String&gt;[]) <span class="keyword">new</span> GenericArray&lt;?&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>（2）通过ArrayList来初始化，这是最安全的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br></pre></td></tr></table></figure><p>（3）通过反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T... a) &#123;</span><br><span class="line">    T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）提供一个数组构造器表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(IntFunction&lt;T[]&gt; constr, T... a) &#123;</span><br><span class="line">    T[] mm = constr.apply(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java 泛型对象能实例化 T t = new T() 吗，为什么？<br>不能，无法编译，一部分因为擦除，另一部分是因为编译器不能验证T具有默认（无参）构造器。擦除的原因是编译器在编译的时候需要获得T类型，但是泛型只存在源代码中，编译时就会被擦除，而此时编译器又无法将之转换为一个确定的类型，所以无法编译。</p><p>Java 8之后，最好的方法是让调用者提供一个构造器表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//makePair方法接收一个Supplier&lt;T&gt;，这是一个函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者传统的方法通过反射调用</p></li><li><p>泛型中extends和super的区别<br>&lt;? extends T&gt;上边界限定通配符，一般用于读取类型参数<br>&lt;? super T&gt;超类型通配符，一般用于写入类型参数</p></li></ol><p>参考<a href="https://segmentfault.com/a/1190000005337789" target="_blank" rel="noopener">Java 泛型总结（三）：通配符的使用</a><br><a href="https://segmentfault.com/a/1190000005179147" target="_blank" rel="noopener">Java 泛型总结（二）：泛型与数组</a><br><a href="https://segmentfault.com/a/1190000005179142" target="_blank" rel="noopener">Java 泛型总结（一）：基本用法与类型擦除</a><br><a href="https://blog.csdn.net/lonelyroamer/article/details/7868820" target="_blank" rel="noopener">java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java操作符总结</title>
      <link href="/2020/02/07/Java%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Java%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Java-操作符"><a href="#Java-操作符" class="headerlink" title="Java 操作符"></a>Java 操作符</h1><p>几乎所有的操作符都只能操作基本类型，但“=”、“==”、“!=”可以操作所有的对象（String类支持“+”、“+=”）</p><h2 id="赋值（-）"><a href="#赋值（-）" class="headerlink" title="赋值（=）"></a>赋值（=）</h2><p>取右边的值，<strong>复制</strong>给左边。右值可以是任何常数、变量或表达式，左边却必须是一个已命名的变量（有一个物理空间用来存储右边的值）<br>比如<code>a = 4;</code>将4赋值给a变量，但是不能<code>4 = a;</code>，因为4是一个常数，不是变量就没有指向一块空间。基本类型的赋值操作，就是将一个地方的内容复制到另一个地方，比如基本数据类型<code>a = b;</code>就是将b指向的内容复制到a指向的地址，两个地址不同。<br>对象的赋值操作就有些不同了，比如对象类型操作<code>a = b;</code>，是将b的引用复制给a，两个同时指向一个地址。<br><a href="https://upload-images.jianshu.io/upload_images/4061843-0673971e98e68759.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-0673971e98e68759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>别名现象：如果a原本指向了一块地址，b指向的另一个地址，在执行<code>a=b;</code>后，a就会指向b的地址，a原来指向的地址就没有引用了，也就是丢失了（GC会自动清理这块地址），这种现象就叫别名现象</p><h2 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h2><p>a=10， b=20<br>| 操作符 | 描述 | 例子 |<br>| :-: | :-: | :-: |<br>| + | 加法 | a + b = 30 |<br>| - | 减法 | a - b = -10 |<br>| | 乘法 | a b = 200 |<br>| / | 除法 | b / a = 2 |<br>| % | 取余 | b % a = 0 |<br>| ++ | 自增 | a++或++a结果都为11（但是有区别） |<br>| – | 自减 | a–或–a结果都为9（有区别） |<br>| | | |</p><ul><li>自增自减<br>  a++和a–是后缀自增自减：先进行表达式运算，再进行自增自减<br>  ++a和–a是前缀自增自减：先进行自增自减，再进行表达式运算</li></ul><h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><p>关系操作符的结果是一个boolean值，计算的是操作数的值之间的关系</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">检查如果两个操作数的值是否相等，如果相等则条件为真</td><td align="center">20 == 20（结果true）</td></tr><tr><td align="center">!=</td><td align="center">检查如果两个操作数的值是否相等，如果值不相等则条件为真</td><td align="center">20 != 30（结果true）</td></tr><tr><td align="center">&gt;</td><td align="center">检查左操作数的值是否大于右操作数的值，如果是那么条件为真</td><td align="center">20 &gt; 30（结果false）</td></tr><tr><td align="center">&lt;</td><td align="center">检查左操作数的值是否小于右操作数的值，如果是那么条件为真</td><td align="center">20 &lt; 30（结果true）</td></tr><tr><td align="center">&gt;=</td><td align="center">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真</td><td align="center">20 &gt;= 20（结果true）</td></tr><tr><td align="center">&lt;=</td><td align="center">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真</td><td align="center">20 &lt;= 20（结果true）</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>==和!=适用于所有对象<br>  基本类型判断值，引用类型判断内存地址是否相等</li></ul><h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><p>假设布尔变量A为真，变量B为假<br>| 操作符 | 描述 | 例子 |<br>| :-: | :-: | :-: |<br>| &amp;&amp; | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真 | (A &amp;&amp; B)为假 |<br>| || | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真 | (A || B)为真 |<br>| ! | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false | !(A &amp;&amp; B)为真 |<br>| | | |</p><ul><li>短路<br>  一旦能够明确无误地确定整个表达式的值，就不会计算后面的部分<br>  比如<code>boolean a = (20 &gt; 30) &amp;&amp; (20 &gt; 10);</code>当发现前面20&gt;30已经是false时，又是&amp;&amp;运算符，所以直接判定整个表达式为false，不会去计算20还是否大于10了</li></ul><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>假设整数变量A的值为60和变量B的值为13<br>| 操作符 | 描述 | 例子 |<br>| :-: | :-: | :-: |<br>| ＆ | 如果相对应位都是1，则结果为1，否则为0 | (A＆B)，得到12，即0000 1100 |<br>| | | 如果相对应位都是0，则结果为0，否则为1 | (A | B)得到61，即 0011 1101 |<br>| ^ | 如果相对应位值相同，则结果为0，否则为1 | (A ^ B)得到49，即 0011 0001 |<br>| 〜 | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0 | (〜A)得到-61，即1100 0011 |<br>| &lt;&lt; | 按位左移运算符。左操作数按位左移右操作数指定的位数 | A &lt;&lt; 2得到240，即 1111 0000 |<br>| &gt;&gt; | 有符号按位右移运算符。左操作数按位右移右操作数指定的位数 | A &gt;&gt; 2得到15即 1111 |<br>| &gt;&gt;&gt; | 无符号按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 | A&gt;&gt;&gt;2得到15即0000 1111 |<br>| | | |</p><p>按位操作符&amp;、|、^可以与=联合使用，以便合并运算和赋值（~说一元操作符，不可以和=联用）<br>左移操作符（&lt;&lt;）：在低位补0（数学上相当于乘以2的n次方，移n位）<br>有符号右移操作符（&gt;&gt;）：若符号为正，则在高位插0（数学上相当于移n位，除以2的n次方）；若符号为-，则在高位插1<br>无符号右移操作符（&gt;&gt;&gt;）：使用“零扩展”，无论正负，都在高位插0<br>对char、byte、short类型的数值进行移位处理，会先转换为int型，得到的结果也是int型<br>long移位后仍是long<br>移位操作符可以与=联合使用</p><h2 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0x2f</span>;</span><br><span class="line">        System.out.println(<span class="string">"i1:"</span>+Integer.toBinaryString(i1));</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0X2F</span>;</span><br><span class="line">        System.out.println(<span class="string">"i2:"</span>+Integer.toBinaryString(i2));</span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">0177</span>;</span><br><span class="line">        System.out.println(<span class="string">"i3:"</span>+Integer.toBinaryString(i3));</span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0xffff</span>;</span><br><span class="line">        System.out.println(<span class="string">"c:"</span>+Integer.toBinaryString(c));</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">0x7f</span>;</span><br><span class="line">        System.out.println(<span class="string">"b:"</span>+Integer.toBinaryString(b));</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">0x7fff</span>;</span><br><span class="line">        System.out.println(<span class="string">"s:"</span>+Integer.toBinaryString(s));</span><br><span class="line">        <span class="keyword">long</span> n1 = <span class="number">200L</span>;</span><br><span class="line">        System.out.println(<span class="string">"n1:"</span>+Long.toBinaryString(n1));</span><br><span class="line">        <span class="keyword">long</span> n2 = <span class="number">200l</span>;</span><br><span class="line">        System.out.println(<span class="string">"n2:"</span>+Long.toBinaryString(n2));</span><br><span class="line">        <span class="keyword">long</span> n3 = <span class="number">200</span>;</span><br><span class="line">        System.out.println(<span class="string">"n3:"</span>+Long.toBinaryString(n3));</span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">float</span> f2 = <span class="number">1F</span>;</span><br><span class="line">        <span class="keyword">float</span> f3 = <span class="number">1f</span>;</span><br><span class="line">        <span class="keyword">double</span> d1 = <span class="number">1</span>d;</span><br><span class="line">        <span class="keyword">double</span> d2 = <span class="number">1</span>D;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>i1:101111<br>i2:101111<br>i3:1111111<br>c:1111111111111111<br>b:1111111<br>s:111111111111111<br>n1:11001000<br>n2:11001000<br>n3:11001000</p></blockquote><p>小写l容易造成混淆，所以long一般用大写的L。大写（小写）F都表示float，大写（小写）D都代表double</p><ul><li>指数记数法<br>  1.39E-43f，表示e为自然数对数的基数，-43表示幂次，1.39表示系数</li></ul><h2 id="条件运算符-（-）"><a href="#条件运算符-（-）" class="headerlink" title="条件运算符 （? :）"></a>条件运算符 （? :）</h2><blockquote><p>boolean-exp ? value0 : value1</p></blockquote><p>如果boolean-exp（布尔表达式）的结果为true，就计算value0，否则计算value1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a , b;</span><br><span class="line">      a = <span class="number">10</span>;</span><br><span class="line">      <span class="comment">// 如果 a 等于 1 成立，则设置 b 为 20，否则为 30</span></span><br><span class="line">      b = (a == <span class="number">1</span>) ? <span class="number">20</span> : <span class="number">30</span>;</span><br><span class="line">      System.out.println( <span class="string">"Value of b is : "</span> +  b );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 a 等于 10 成立，则设置 b 为 20，否则为 30</span></span><br><span class="line">      b = (a == <span class="number">10</span>) ? <span class="number">20</span> : <span class="number">30</span>;</span><br><span class="line">      System.out.println( <span class="string">"Value of b is : "</span> + b );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>Value of b is : 30<br>Value of b is : 20</p></blockquote><h2 id="字符串操作符-和"><a href="#字符串操作符-和" class="headerlink" title="字符串操作符 +和+="></a>字符串操作符 +和+=</h2><p>用于连接字符串，如果一个表达式以一个字符串起头，那么后续的所有操作数都必须是字符串型（编译器会自动转为字符串）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOperators</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">1</span>, z = <span class="number">2</span>;</span><br><span class="line">        String s = <span class="string">"\tx,y,z\t"</span>;</span><br><span class="line">        System.out.println(s + x + y + z);</span><br><span class="line">        System.out.println(x + s);</span><br><span class="line">        s += <span class="string">"summed = "</span>;</span><br><span class="line">        System.out.println(s + (x + y + z));</span><br><span class="line">        System.out.println(<span class="string">" "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> *    x,y,z    012</span></span><br><span class="line"><span class="comment"> * 0  x,y,z  </span></span><br><span class="line"><span class="comment"> *    x,y,z    summed = 3</span></span><br><span class="line"><span class="comment"> *  0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="类型转化操作符"><a href="#类型转化操作符" class="headerlink" title="类型转化操作符"></a>类型转化操作符</h2><p>类型转化原意是”模型铸造“，在适当的时候将一种数据类型自动转换为另一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Casting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">long</span> lng = (<span class="keyword">long</span>) i;  <span class="comment">//对变量进行类型转换 int向long转换，可以不用声明</span></span><br><span class="line">        lng = i;  <span class="comment">//"Wideing" so cast not really required</span></span><br><span class="line">        <span class="keyword">long</span> lng2 = (<span class="keyword">long</span>) <span class="number">200</span>;  <span class="comment">//对数值进行类型转换</span></span><br><span class="line">        lng2 = <span class="number">200</span>;</span><br><span class="line">        <span class="comment">//A "narrowing conversion"</span></span><br><span class="line">        i = (<span class="keyword">int</span>) lng2;  <span class="comment">//cast required  long向int转换需要声明，强制转换，int范围比long小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>窄化转换<br>  将能容纳更多信息的数据转换成无法容纳更多信息的类型，可能对导致信息丢失<br>  例如long向int转换</li><li>扩展转换<br>  与窄化转换相反<br>  例如int向long转化</li><li>截尾和舍入<br>  将float或double转型为int型时，总是对数字执行截尾（29.7转int是29，不会保留小数位），如果想要得到舍入的结果就要使用Math.round()方法</li></ul><h2 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h2><p>用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）<br>使用格式如下：<br><code>( Object reference variable ) instanceof (class/interface type)</code></p><p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"James"</span>;</span><br><span class="line"><span class="keyword">boolean</span> result = name <span class="keyword">instanceof</span> String; <span class="comment">// 由于 name 是 String 类型，所以返回真</span></span><br></pre></td></tr></table></figure><p>如果被比较的对象兼容于右侧类型,该运算符仍然返回true<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Vehicle a = <span class="keyword">new</span> Car();</span><br><span class="line">      <span class="keyword">boolean</span> result =  a <span class="keyword">instanceof</span> Car;</span><br><span class="line">      System.out.println( result);  <span class="comment">//返回true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h2><p>优先级从高到低<br>| 类别 | 操作符 | 关联性 |<br>| :-: | :-: | :-: |<br>| 后缀 | () [] . (点操作符) | 左到右 |<br>| 一元 | + + - ！〜 | 从右到左 |<br>| 乘性 | / %| 左到右 |<br>| 加性 | + - | 左到右 |<br>| 移位 | &gt;&gt; &gt;&gt;&gt; &lt;&lt; | 左到右 |<br>| 关系 | &gt;&gt; = &lt;&lt; = | 左到右 |<br>| 相等 | == != | 左到右 |<br>| 按位与 | &amp; | 左到右 |<br>| 按位异或 | ^ | 左到右 |<br>| 按位或 | | | 左到右 |<br>| 逻辑与 | &amp;&amp; | 左到右 |<br>| 逻辑或 | || | 左到右 |<br>| 条件 | ? : | 从右到左 |<br>| 赋值 | = += -= = /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= |= | 从右到左 |<br>| 逗号 | ，| 左到右 |</p><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li>如何比较两个对象的大小.或者换句话说,如何让对象之间有可比性<br> 实现Comparable接口</li><li>定简单说说 Java 中 &amp; 与 &amp;&amp; 有什么区别？| 与 || 呢？<br> &amp;是按位与，是位运算，&amp;&amp;是逻辑与，是逻辑运算<br> |是按位或，是位运算，||是逻辑或，是逻辑运算<br> 在进行逻辑判断时，&amp;和|判断的是左右两边参与位运算的结果是否为true，而&amp;&amp;左边为false就不会处理右边的内容，||左边为true也不处理右边，&amp;&amp;、||是逻辑短路运算符<br> 优先级高到低：&amp;、|、&amp;&amp;、||</li><li>Java 或者 Android 开发中可以通过哪些方式来保证并发安全的自增自减操作？<br> java默认的自增自减是非并发安全<br> 通过synchronized代码块或方法保证并发安全<br> 通过组活动使用Lock锁<br> 通过JADK提供的AtomicInteger类</li></ol><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p><strong>Java 核心编程思想</strong><br><a href="http://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener">Java 运算符</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化总结</title>
      <link href="/2020/02/07/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Java%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h1><p>对象的序列化可以实现轻量级持久性</p><h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>简单序列化到文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String passwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String userName, String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = <span class="string">"no transient "</span> + userName;</span><br><span class="line">        <span class="keyword">this</span>.passwd = <span class="string">"transient "</span> + passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login info:\nusername:"</span> + userName + <span class="string">"\npasswd:"</span> + passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Login login = <span class="keyword">new</span> Login(<span class="string">"Tom"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        System.out.println(login);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        oos.writeObject(login);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Serializable"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        Login login1 = (Login) ois.readObject();</span><br><span class="line">        System.out.println(login1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h2><p>Externalizable是用来实现序列化的控制</p><ul><li><p>简单用法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String passwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String userName, String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = <span class="string">"no transient "</span> + userName;</span><br><span class="line">        <span class="keyword">this</span>.passwd = <span class="string">"transient "</span> + passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//readExternal会自动调用默认的构造方法（所有的默认构造方法都会被调用）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login info:\nusername:"</span> + userName + <span class="string">"\npasswd:"</span> + passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeObject(passwd);</span><br><span class="line">        out.writeObject(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        userName = (String) in.readObject();</span><br><span class="line">        passwd = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Login login = <span class="keyword">new</span> Login(<span class="string">"Tom"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        System.out.println(login);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        oos.writeObject(login);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Externalizable"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        Login login1 = (Login) ois.readObject();</span><br><span class="line">        System.out.println(login1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> * login info:</span></span><br><span class="line"><span class="comment"> * username:no transient Tom</span></span><br><span class="line"><span class="comment"> * passwd:transient 123456</span></span><br><span class="line"><span class="comment"> * Externalizable</span></span><br><span class="line"><span class="comment"> * login info:</span></span><br><span class="line"><span class="comment"> * username:transient 123456</span></span><br><span class="line"><span class="comment"> * passwd:no transient Tom</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>  从结果发现一点，username和passwd的值，序列化前后的值好像并不一样，看代码，发现，我们在writeExternal的时候passwd在前，而readExternal的时候又在后，说明手动实现的时候还得注意顺序，特别是同类型的。</p></li><li><p>Externalizable的替代方法<br>  实现Serialiable接口，<strong>添加（不是覆盖或实现）</strong>writeObject()和readObject()方法，这样一旦对象被序列化，就会自动地调用这两个方法（不会使用默认地方法）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须具有准确地方法特征签名</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br></pre></td></tr></table></figure><p>  实现：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String userName, String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = <span class="string">"no transient "</span> + userName;</span><br><span class="line">        <span class="keyword">this</span>.passwd = <span class="string">"transient "</span> + passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//调用默认的readObject</span></span><br><span class="line">        stream.defaultReadObject();</span><br><span class="line">        passwd = (String) stream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//调用默认地writeObject</span></span><br><span class="line">        stream.defaultWriteObject();</span><br><span class="line">        <span class="comment">//手动实现transient修饰的类的序列化</span></span><br><span class="line">        stream.writeObject(passwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login info:\nusername:"</span> + userName + <span class="string">"\npasswd:"</span> + passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Login login = <span class="keyword">new</span> Login(<span class="string">"Tom"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        System.out.println(login);</span><br><span class="line">        ByteArrayOutputStream buf = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(buf);</span><br><span class="line">        oos.writeObject(login);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream  (buf.toByteArray()));</span><br><span class="line">        Login login1 = (Login) ois.readObject();</span><br><span class="line">        System.out.println(login1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> * login info:</span></span><br><span class="line"><span class="comment"> * username:no transient Tom</span></span><br><span class="line"><span class="comment"> * passwd:transient 123456</span></span><br><span class="line"><span class="comment"> * login info:</span></span><br><span class="line"><span class="comment"> * username:no transient Tom</span></span><br><span class="line"><span class="comment"> * passwd:transient 123456</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>用于控制Serializable对象的序列化操作。transient可以逐个字段的关闭序列化</p><p>例子：假设某个Login对象保存某个特定的登陆会话信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String userName, String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login info:\nusername:"</span> + userName + <span class="string">"\npasswd:"</span> + passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Login login = <span class="keyword">new</span> Login(<span class="string">"Tom"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        System.out.println(login);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        oos.writeObject(login);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Serializable"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"login.out"</span>));</span><br><span class="line">        Login login1 = (Login) ois.readObject();</span><br><span class="line">        System.out.println(login1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果：<br>login info:<br>username:Tom<br>passwd:123456<br>Serializable<br>login info:<br>username:Tom<br>passwd:null</p></blockquote><h2 id="深入理解序列化"><a href="#深入理解序列化" class="headerlink" title="深入理解序列化"></a>深入理解序列化</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener">Java 序列化的高级认识</a><br><a href="http://beautyboss.farbox.com/post/study/shen-ru-xue-xi-javaxu-lie-hua" target="_blank" rel="noopener">深入学习Java序列化</a></p><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li><p>transient关键字<br> 用于控制Serializable对象的序列化操作。transient可以逐个字段的关闭序列化</p></li><li><p>说说你对 Java 的 transient 关键字理解<br> 对于不需要被序列化的属性就可以通过加上 transient 关键字来处理。一旦属性被 transient 修饰就不再是对象持久化的一部分(一个静态变量不管是否被transient修饰，均不能被序列化)，该属性的内容在序列化后将无法获得访问，transient 关键字只能修饰属性变量成员而不能修饰方法和类（注意局部变量是不能被 transient 关键字修饰的），属性成员如果是引用类型也需要保证实现 Serializable 接口；此外在 Java 中对象的序列化可以通过实现两种接口来实现，若实现的是 Serializable 接口则所有的序列化将会自动进行，若实现的是 Externalizable 接口则没有任何东西可以自动序列化，需要在 writeExternal 方法中进行手工指定所要序列化的变量，这与是否被 transient 修饰无关。</p></li><li><p>如何将一个Java对象序列化到文件里<br> 通过Serializable自动序列化或通过Externalizable手动序列化</p></li><li><p>Java 序列化中 writeReplace() 方法有什么作用？</p></li><li><p>Java 序列化中 readResolve() 方法有什么作用？</p></li><li><p>Java 序列化存储传输为什么不安全？怎么解决？<br> <a href="https://mp.weixin.qq.com/s/LaASpNkXl_1Gljc1wl5fIA" target="_blank" rel="noopener">【码农每日一题】Java 自定义序列化(Part 2)相关问题</a></p></li><li><p>简单说说 Externalizable 与 Serializable 有什么区别？<br> 使用 transient 还是用 writeObject() 和 readObject() 方法都是基于 Serializable 接口的序列化；JDK 提供的另一个序列化接口 Externalizable 继承自 Serializable，使用该接口后基于 Serializable 接口的序列化机制就会失效（包括 transient，因为 Externalizable 不会主动序列化），当使用该接口时序列化的细节需要由我们自己去实现，另外使用 Externalizable 主动进行序列化时当读取对象时会调用被序列化类的无参构方法去创建一个新的对象，然后再将被保存对象的字段值分别填充到新对象中，所以实现 Externalizable 接口的类必须提供一个无参 public 的构造方法。</p></li><li><p>对于transient修饰的属性如何在不删除修饰符的情况下让其可以序列化？</p></li><li><p>Serializable 序列化中自定义 readObjectNoData() 方法有什么作用？<br> 这个方法主要用来保证通过继承扩容后对老版本的兼容性，适用场景如下：比如类 Persion 被序列化到硬盘后存储为文件 old.txt，接着 Person 被修改继承自 Animal，为了保证用新的 Person 反序列化老版本 old.txt 文件且 Animal 类的成员有默认值则可以在 Animal 类中定义 readObjectNoData 方法返回成员的默认值，具体可以参见 ObjectInputStream 类中的 readSerialData 方法判断</p><p> 参考<a href="https://mp.weixin.qq.com/s/dOTws5ZeFDDW_mOBVPpB4g" target="_blank" rel="noopener">Java 自定义序列化(Part 1)相关问题</a></p></li><li><p>父类实现了 Serializable 接口后如何不修改父类的情况下让子类不可序列化</p></li><li><p>子类实现序列化接口与父类实现序列化接口有什么区别吗</p></li><li><p>父类实现了 Serializable 接口后如何不修改父类的情况下让子类不可序列化<br>参考<a href="https://mp.weixin.qq.com/s/MxW4JlbUZwG7YIsmlMIKvQ" target="_blank" rel="noopener">Java 序列化与继承相关面试题</a></p></li></ol><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><h3 id="Java-编程思想"><a href="#Java-编程思想" class="headerlink" title="Java 编程思想"></a>Java 编程思想</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java拷贝总结</title>
      <link href="/2020/02/07/Java%E6%8B%B7%E8%B4%9D%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Java%E6%8B%B7%E8%B4%9D%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Java拷贝相关知识"><a href="#Java拷贝相关知识" class="headerlink" title="Java拷贝相关知识"></a>Java拷贝相关知识</h1><p>clone顾名思义就是复制， 在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象</p><h2 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h2><p>clone是Object这个超类的一个Protect方法。<br><code>protected native Object clone() throws CloneNotSupportedException;</code></p><p>通过源码，我们可以知道以下几点：</p><ol><li>clone是一个受保护的native方法（native方法是非Java语言实现的代码，仅供Java程序调用），因为受保护，所以不能直接从类外进行访问</li><li>x.clone() != x 必须为真，克隆对象将有单独的内存分配</li><li>x.clone().getClass() == x.getClass()，原始和克隆的对象应该具有同样的类型，但不是强制性的</li><li>x.clone().equals(x) 应该为true，所比较的对象内容应该相同，但不强制性</li><li>被复制的类需要实现Clonenable接口</li><li>覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象</li></ol><h2 id="浅拷贝-Shallow-Copy"><a href="#浅拷贝-Shallow-Copy" class="headerlink" title="浅拷贝(Shallow Copy)"></a>浅拷贝(Shallow Copy)</h2><p>引例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String addressStr, <span class="keyword">int</span> addressCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address.setAddress(addressStr);</span><br><span class="line">        <span class="keyword">this</span>.address.setAddressCode(addressCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span> + name + <span class="string">"\tage:"</span> + age + <span class="string">"\taddress:"</span>+address.getAddress()+address.getAddressCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/27.</span></span><br><span class="line"><span class="comment"> * Person的成员属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addressCode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String address, <span class="keyword">int</span> addressCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.addressCode = addressCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAddressCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addressCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddressCode</span><span class="params">(<span class="keyword">int</span> addressCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addressCode = addressCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/25.</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Person person = <span class="keyword">new</span> Person();</span><br><span class="line">       person.setName(<span class="string">"person"</span>);</span><br><span class="line">       person.setAge(<span class="number">20</span>);</span><br><span class="line">       person.setAddress(<span class="keyword">new</span> Address(<span class="string">"person address"</span>, <span class="number">100</span>));</span><br><span class="line">       System.out.println(<span class="string">"person "</span> + person.toString());</span><br><span class="line">       Person person1 = (Person) person.clone();</span><br><span class="line">       System.out.println(<span class="string">"clone person "</span> + person1.toString());</span><br><span class="line">       System.out.println(person.getName() == person1.getName());</span><br><span class="line">       System.out.println(<span class="string">"修改clone person的属性值"</span>);</span><br><span class="line">       person1.setAge(<span class="number">21</span>);</span><br><span class="line">       person1.setName(<span class="string">"clone person"</span>);</span><br><span class="line">       person1.setAddress(<span class="string">"clone address"</span>, <span class="number">200</span>);</span><br><span class="line">       System.out.println(person.getName() == person1.getName());</span><br><span class="line">       System.out.println(<span class="string">"person "</span> + person.toString());</span><br><span class="line">       System.out.println(<span class="string">"clone person"</span> + person1.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> * person name:person   age:20  address:person address100</span></span><br><span class="line"><span class="comment"> * clone person name:person age:20  address:person address100</span></span><br><span class="line"><span class="comment"> * true</span></span><br><span class="line"><span class="comment"> * 修改clone person的属性值</span></span><br><span class="line"><span class="comment"> * false</span></span><br><span class="line"><span class="comment"> * person name:person   age:20  address:clone address200</span></span><br><span class="line"><span class="comment"> * clone personname:clone person    age:21  address:clone address200</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从结果中可以看出，基本类型的属性age，在clone后person1修改为21，并不会修改person的age；但是当你修改person1的address时，person的address也被修改了，这就意味着，clone后，基本类型的属性时真正clone了，但是引用类的address属性并没有真正的clone，它们指向的地址还是一个地址（尽管引用也变了，只是进行了引用的传递，而没有真实的创建一个新的对象）。这个就是浅拷贝和深拷贝的区别所在了。浅拷贝只能拷贝基本类型（基本变量引用和地址都变），无法真正拷贝引用属性（因为引用变量clone了，但是指向的地址并没有改变）</p><p><strong>注意</strong>：例子中同样使用了String的引用，可以看到，在setName之前，两个name的地址是一样的，但是setName之后，两个name的地址就不一样了，所以操作person1的name并没有影响person的name。这并不是说String这个引用例外了，而是String是不可变的（final类），所以赋值后会分配一个新的内存来存储，新的引用就指向了新的地址，所以才会出现这种情况。</p><h2 id="深拷贝-Deep-Copy"><a href="#深拷贝-Deep-Copy" class="headerlink" title="深拷贝(Deep Copy)"></a>深拷贝(Deep Copy)</h2><p>引例：在上面的例子中，修改一下Person的clone（自定义clone）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.setName(name);</span><br><span class="line">    person.setAge(age);</span><br><span class="line">    person.setAddress(<span class="keyword">new</span> Address(address.getAddress(), address.getAddressCode()));</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> * person name:personage:20address:person address100</span></span><br><span class="line"><span class="comment"> * clone person name:personage:20address:person address100</span></span><br><span class="line"><span class="comment"> * true</span></span><br><span class="line"><span class="comment"> * 修改clone person的属性值</span></span><br><span class="line"><span class="comment"> * false</span></span><br><span class="line"><span class="comment"> * person name:personage:20address:person address100</span></span><br><span class="line"><span class="comment"> * clone personname:clone personage:21address:clone address200</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从结果中可以看到，不管是age还是address，person1的修改并没有影响person的值，这就意味着person1是person的克隆（两者完全独立）</p><p><strong>注意</strong>：在clone后，person1.setName之前，我们比较了一次两个name的地址，为什么还是指向同一个呢？再看一下我们自定义的clone方法，我们并没有操作String的clone，并且String这个类并没有复写clone这个方法。setNeme之后，地址就不一样了还是String的不可变性</p><ul><li>利用成员类实现Clonenable，来实现深拷贝</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">            person.address = (Address) address.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> *person name:personage:20address:person address100</span></span><br><span class="line"><span class="comment"> * clone person name:personage:20address:person address100</span></span><br><span class="line"><span class="comment"> * true</span></span><br><span class="line"><span class="comment"> * 修改clone person的属性值</span></span><br><span class="line"><span class="comment"> * false</span></span><br><span class="line"><span class="comment"> * person name:personage:20address:person address100</span></span><br><span class="line"><span class="comment"> * clone personname:clone personage:21address:clone address200</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>利用Address实现Clonenable接口，然后在Person中调用Address的clone方法，从而实现深拷贝。结果同上面一个一样。其实这也算自定义clone。</p><ul><li>通过序列化来实现深拷贝</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/25.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> Person();</span><br><span class="line">            person.setName(<span class="string">"person"</span>);</span><br><span class="line">            person.setAge(<span class="number">20</span>);</span><br><span class="line">            person.setAddress(<span class="keyword">new</span> Address(<span class="string">"person address"</span>, <span class="number">100</span>));</span><br><span class="line">            System.out.println(<span class="string">"person "</span> + person.toString());</span><br><span class="line"></span><br><span class="line">            Person person1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过序列化实现深拷贝</span></span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            <span class="comment">// 序列化以及传递这个对象 </span></span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.flush();</span><br><span class="line"></span><br><span class="line">            ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">            <span class="comment">// 返回新的对象</span></span><br><span class="line">            person1 = (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"clone person "</span> + person1.toString());</span><br><span class="line">            System.out.println(person.getName() == person1.getName());</span><br><span class="line">            System.out.println(<span class="string">"修改clone person的属性值"</span>);</span><br><span class="line">            person1.setAge(<span class="number">21</span>);</span><br><span class="line">            person1.setName(<span class="string">"clone person"</span>);</span><br><span class="line">            person1.setAddress(<span class="string">"clone address"</span>, <span class="number">200</span>);</span><br><span class="line">            System.out.println(person.getName() == person1.getName());</span><br><span class="line">            System.out.println(<span class="string">"person "</span> + person.toString());</span><br><span class="line">            System.out.println(<span class="string">"clone person"</span> + person1.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> *person name:personage:20address:person address100</span></span><br><span class="line"><span class="comment"> * clone person name:personage:20address:person address100</span></span><br><span class="line"><span class="comment"> * false</span></span><br><span class="line"><span class="comment"> * 修改clone person的属性值</span></span><br><span class="line"><span class="comment"> * false</span></span><br><span class="line"><span class="comment"> * person name:personage:20address:person address100</span></span><br><span class="line"><span class="comment"> * clone personname:clone personage:21address:clone address200</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>先都实现Serializable（这是序列化的前提），然后通过序列化，传递后获取。结果跟之前差不多。唯一的差别就是前后name的比较，通过序列化的深拷贝，name并没有像之前的那样，先是指向了同一个地址，而是一开始就是两个地址了。</p><h2 id="延迟拷贝-Lazy-Copy-。"><a href="#延迟拷贝-Lazy-Copy-。" class="headerlink" title="延迟拷贝(Lazy Copy)。"></a>延迟拷贝(Lazy Copy)。</h2><p>延迟拷贝是浅拷贝和深拷贝的一个组合，实际上很少会使用。 当最开始拷贝一个对象时，会使用速度较快的浅拷贝，还会使用一个计数器来记录有多少对象共享这个数据。当程序想要修改原始的对象时，它会决定数据是否被共享（通过检查计数器）并根据需要进行深拷贝。</p><p>延迟拷贝从外面看起来就是深拷贝，但是只要有可能它就会利用浅拷贝的速度。当原始对象中的引用不经常改变的时候可以使用延迟拷贝。由于存在计数器，效率下降很高，但只是常量级的开销。而且, 在某些情况下, 循环引用会导致一些问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>克隆方法用于创建对象的拷贝，为了使用clone方法，类必须实现java.lang.Cloneable接口重写protected方法clone，如果没有实现Clonebale接口会抛出CloneNotSupportedException.</li><li>在克隆java对象的时候不会调用构造器</li><li>java提供一种叫浅拷贝（shallow copy）的默认方式实现clone，创建好对象的副本后然后通过赋值拷贝内容，意味着如果你的类包含引用类型，那么原始对象和克隆都将指向相同的引用内容，这是很危险的，因为发生在可变的字段上任何改变将反应到他们所引用的共同内容上。为了避免这种情况，需要对引用的内容进行深度克隆。</li><li>按照约定，实例的克隆应该通过调用super.clone()获取，这样有助克隆对象的不变性。如：clone!=original和clone.getClass()==original.getClass()，尽管这些不是必须的</li></ol><p><strong>浅拷贝</strong><br><a href="https://images2015.cnblogs.com/blog/690102/201607/690102-20160727132640216-1387063948.png" target="_blank" rel="noopener"><img src="https://images2015.cnblogs.com/blog/690102/201607/690102-20160727132640216-1387063948.png" alt="网上盗的图，浅拷贝"></a>网上盗的图，浅拷贝<br><strong>深拷贝</strong><br><a href="https://images2015.cnblogs.com/blog/690102/201607/690102-20160727132838528-120069275.png" target="_blank" rel="noopener"><img src="https://images2015.cnblogs.com/blog/690102/201607/690102-20160727132838528-120069275.png" alt="网上盗的图，深拷贝"></a>网上盗的图，深拷贝</p><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li>String 克隆的特殊性在哪里？StringBuffer 和 StringBuilder 呢？<br> String克隆仍然是复制引用，并不会修改地址，但是String在内存中是不可修改的对象（被声明为final类，String是不可变的），所以修改值后，新的引用会指向一个新的内存。<br> StringBuffer和StringBuilder的内部实现方式与String不同，StringBuffer和StringBuilder都是在自身上修改的，所以它们的克隆也只是复制引用，但是引用不会指向新的地址，仍是原来的地址（针对浅拷贝）</li><li>什么是深拷贝和浅拷贝<br> 深拷贝就是一个拷贝出来的对象，不管是基本类型还是引用类型的属性，都与原来的对象没有关联，是独立的内存空间<br> 浅拷贝不同的地方就是，基本类型的属性是独立的空间，而引用类型的属性仅仅是引用拷贝了，但都还是指向同一个地址的</li><li>为什么需要克隆<br> 主要是为了在新的上下文环境中复用对象的部分或全部数据。避免操作修改了原数据</li><li>浅度克隆（浅拷贝）和深度克隆（深拷贝）的区别是什么？<br> 克隆的程度，浅拷贝无法真正实现引用型的克隆，深度拷贝就必须要实现这个</li><li>实现对象克隆常见的方式有哪些，具体怎么做<br> 浅拷贝：实现Clonenable，复写clone方法，不做多余的操作<br> 深拷贝：引用类型的属性、本身都要实现Clonenable接口，引用类复写原生的clone方法（可以什么都不用改变），本身类实现clone的时候可以根据自己的逻辑实现，也可以调用引用类的clone方法从而使引用类型的属性实现克隆。还可以通过序列化来实现深拷贝</li></ol><h2 id="参考相关链接"><a href="#参考相关链接" class="headerlink" title="参考相关链接"></a>参考相关链接</h2><p><a href="https://lrh1993.gitbooks.io/android_interview_guide/content/java/basis/copy.html" target="_blank" rel="noopener">Java深拷贝和浅拷贝</a><br><a href="https://www.cnblogs.com/Qian123/p/5710533.html#_labelTop" target="_blank" rel="noopener">Java提高篇——对象克隆（复制）</a><br><a href="https://blog.csdn.net/zhangjg_blog/article/details/18369201" target="_blank" rel="noopener">详解Java中的clone方法 – 原型模式</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础总结</title>
      <link href="/2020/02/07/Java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Java基础总结"><a href="#Java基础总结" class="headerlink" title="Java基础总结"></a>Java基础总结</h1><p><strong>声明</strong>：部分面试题来自微信公众号<strong>码农每日一题</strong></p><h2 id="基本数据类型、String"><a href="#基本数据类型、String" class="headerlink" title="基本数据类型、String"></a>基本数据类型、String</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><a href="./Java泛型总结.md">泛型相关总结</a></p><h2 id="封装、多态、继承、接口"><a href="#封装、多态、继承、接口" class="headerlink" title="封装、多态、继承、接口"></a>封装、多态、继承、接口</h2><p><a href="./Java三大特性、抽象类以及接口相关.md">Java三大特性、抽象类以及接口相关</a></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><a href="./Java内部类.md">内部类</a></p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>参考<a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">深入理解Java枚举类型(enum)</a></p><ul><li><p>简单定义<br>  <code>public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };</code></p></li><li><p>定义一个有构造器、方法和域的枚举类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size &#123;</span><br><span class="line">    SMALL(<span class="string">"S"</span>), MEDOIM(<span class="string">"M"</span>), LARGE(<span class="string">"L"</span>), EXTRA_LARGE(<span class="string">"XL"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreviation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  所有的枚举类型都是Enum的子类，枚举类除了不能继承自一个enum以外，基本跟普通的类没有区别</p></li><li><p>枚举类中的方法</p></li></ul><ol><li>valueOf 返回指定名字、给定类的枚举常量<br> <code>static Enum valueOf(Class enumClass, String name)</code></li><li>toString 返回枚举常量名<br> <code>String toString()</code></li><li>ordinal 返回枚举常量在enum声明中的位置（位置从0开始）<br> <code>int ordinal()</code></li><li>compareTo 如果枚举常量出现在other之前，返回true；如果this==other，返回0，否则返回正值<br> <code>int compareTo(E other)</code></li></ol><p>Java 枚举类比较用 == 还是 equals，有啥区别？<br>ordinal方法返回的是int值，这是每个enum实例在声明时的次序，从0开始，所以可以直接用==来比较enum实例，编译器会自动提供equals和hashCode方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==在枚举类就是比较的基本类型<span class="keyword">int</span>值，equals在<span class="keyword">enum</span>中重写后，就是使用的==   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">this</span> == other;&#125;</span><br></pre></td></tr></table></figure><ul><li>面试问题</li></ul><ol><li><p>简单谈谈你理解的 Java 枚举本质原理？<br> 枚举的本质是编译器处理成了类，枚举值为类的静态常量属性，其属性在类加载时的静态代码块中被初始化实例赋值。枚举可以有修饰符不大于默认修饰符的构造方法（修饰符可为 private，不可为 public 等）等，枚举只是一种语法糖，被编译器生成了最终的类而已。<br> <a href="https://juejin.im/entry/5a03ac77f265da432240a351" target="_blank" rel="noopener">简单谈谈你理解的 Java 枚举本质原理？</a></p></li><li><p>Java 枚举类与常量的区别有哪些，有啥优缺点？<br> 枚举相对于常量类来说定义更简单，其不需要定义枚举值，而常量类中的每个常量必须要手动添加值。枚举作为参数使用时可以在编译时避免弱类型错误，而常量类中的常量作为参数使用时在编译时无法避免弱类型错误（譬如常量类型为 int，参数传递一个常量类中没定义的 int 值）。枚举自动具备内置方法（如 values 方法可以获得所有值的集合来遍历，ordinal 方法可以获得排序值，compareTo 方法可以基于 ordinal 比较），而常量类默认不具备这些方法。</p><p> 枚举的缺点就是不能被继承（编译后生成的类是 final class 的），也不能通过 extends 继承其他类（枚举类编译后实质就是继承了 Enum 类，Java 是单继承机制），但是定义的枚举类可以通过 implements 实现其他接口，枚举值定义完毕后除非修改重构，否则无法做扩展，而常量类可以随意继承</p></li><li><p>Java 枚举类可以继承其他类（或实现其他接口）或者被其他类继承吗，为什么？<br> 枚举类可以实现其他接口但不能继承其他类，因为所有枚举类在编译后的字节码中都继承自 java.lang.Enum（由编译器添加），而 Java 不支持多继承，所以枚举类不可以继承其他类。</p><p> 枚举类不可以被继承，因为所有枚举类在编译后的字节码中都是继承自 java.lang.Enum（由编译器添加）的 final class 类，final 的类是不允许被派生继承的。（不清楚的可以查看前一篇历史推送枚举原理题）</p></li><li><p>Java switch 为什么能使用枚举类型？<br> 枚举类型之所以能使用其实是编译器层面实现的，编译器会将枚举 switch 转换为类似 switch(s.ordinal()) { case Status.START.ordinal() } 形式，所以实质还是 int 参数类型</p></li><li><p>Java 枚举会比静态常量更消耗内存吗？<br> 会更消耗，一般场景下不仅编译后的字节码会比静态常量多，而且运行时也会比静态常量需要更多的内存，不过这个多取决于场景和枚举的规模等等，不能明确的定论多多少（一般都至少翻倍以上），此外更不能因为多就一刀切的认为静态常量应该优于枚举使用，枚举有自己的特性和场景，优化也不能过度。我们在上一篇枚举实质原理中已经解释了每个枚举类中的具体枚举类型都是对应类中的一个静态常量，该常量在 static 块中被初始实例化，此外枚举类还有自己的一些特有方法，而静态常量实质却很简单，所以从对象占用内存大小方面来计算肯定是枚举类比静态常量更加占体积和消耗运行时内存，</p></li><li><p>Java 枚举是如何保证线程安全的？<br> static关键字，所有的属性都是static的。static类型的属性会在类被加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，创建一个enum类型是线程安全的。</p></li><li><p>为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？<br> （1）枚举写法简单<br> （2）枚举自己处理序列化</p><p> 除过枚举实现的单例模式以外的其他实现方式都有一个比较大的问题是一旦实现了 Serializable 接口后就不再是单例了，因为每次调用 readObject() 方法返回的都是一个新创建出来的对象（当然可以通过使用 readResolve() 方法来避免，但是终归麻烦），而 Java 规范中保证了每一个枚举类型及其定义的枚举变量在 JVM 中都是唯一的，在枚举类型的序列化和反序列化上 Java 做了特殊处理，序列化时 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化时则是通过 java.lang.Enum 的 valueOf 方法来根据名字查找枚举对象，同时禁用了 writeObject、readObject、readObjectNoData、writeReplace 和 readResolve 等方法</p></li><li><p>Java 迭代器和枚举器的区别是什么？<br> （1）Enumeration 枚举器接口是 JDK 1.0 提供的，适用于传统类，而 Iterator 迭代器接口是 JDK 1.2 提供的，适用于 Collections。<br> （2）Enumeration 只有两个方法接口，我们只能读取集合的数据而不能对数据进行修改，而 Iterator 有三个方法接口，除了能读取集合的数据外也能对数据进行删除操作。<br> （3）Enumeration 不支持 fail-fast 机制，而 Iterator 支持 fail-fast 机制（一种错误检测机制，当多线程对集合进行结构上的改变的操作时就有可能会产生 fail-fast 机制，譬如 ConcurrentModificationException 异常）。</p></li></ol><h2 id="final相关"><a href="#final相关" class="headerlink" title="final相关"></a>final相关</h2><p>final可以保护声明为public元素</p><ul><li>关于final的重要知识点<ol><li>final关键字可以用于成员变量、本地变量、方法以及类。</li><li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</li><li>你不能够对final变量再次赋值。</li><li>本地变量必须在声明时赋值。</li><li>在匿名类中所有变量都必须是final变量。</li><li>final方法不能被重写。</li><li>final类不能被继承。</li><li>final关键字不同于finally关键字，后者用于异常处理。</li><li>final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。</li><li>接口中声明的所有变量本身是final的。</li><li>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</li><li>final方法在编译阶段绑定，称为静态绑定(static binding)。</li><li>没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。</li><li>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</li><li>按照Java代码惯例，final变量就是常量，而且通常常量名要大写</li><li>对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容</li></ol></li></ul><p>参考<a href="http://www.cnblogs.com/dolphin0520/p/3736238.html" target="_blank" rel="noopener">浅析Java中的final关键字</a></p><ol><li><p>final修饰变量、方法、类都有什么特性<br> 当用final修饰一个类时，表明这个类不能被继承</p><p> 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了</p><p> 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象</p></li><li><p>有一个类怎样改变内部final类型的变量<br> 如果这个final型变量没有被初始化，而是在构造器中初始化，那么可以通过反射去修改<br> 如果这个final型变量初始化是用的三目表达式，比如<code>final String FINAL = null == null ? &quot;FINAL&quot; : null</code>，那么也可以通过反射修改<br> 除此以外，其他的都不能修改，即使通过反射修改了，使用时还是没有，也就没有意义，所有修改final类型的变量一定要避免编译时初始化，然后才能通过反射修改</p></li><li><p>final，finally，finalize的区别<br> final 是一个修饰符，如果一个类被声明为 final 则其不能再派生出新的子类，所以一个类不能既被声明为 abstract 又被声明为 final 的；将变量或方法声明为 final 可以保证它们在使用中不被改变（对于对象变量来说其引用不可变，即不能再指向其他的对象，但是对象的值可变），被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改，被声明为 final 的方法也同样只能使用不能重载。使用 final 关键字如果编译器能够在编译阶段确定某变量的值则编译器就会把该变量当做编译期常量来使用，如果需要在运行时确定（譬如方法调用）则编译器就不会优化相关代码；将类、方法、变量声明为 final 能够提高性能，这样 JVM 就有机会进行估计并进行优化；接口中的变量都是 public static final 的。</p><p> finally 用来在异常处理时提供块来执行任何清除操作，如果抛出一个异常，则相匹配的 catch 子句就会执行，然后控制就会进入 finally 块。</p><p> finalize 是一个方法名，Java 允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作，这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，它是在 Object 类中定义的，因此所有的类都继承了它，子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作，finalize() 方法在垃圾收集器删除对象之前对这个对象调用的。</p></li></ol><h2 id="static相关"><a href="#static相关" class="headerlink" title="static相关"></a>static相关</h2><p><a href="https://www.cnblogs.com/dolphin0520/p/3799052.html" target="_blank" rel="noopener">Java中的static关键字解析</a></p><ol><li><p>static修饰变量、方法、类都有什么特性。<br> static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。<br> 　　static成员变量的初始化顺序按照定义的顺序进行初始化</p><p> static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用</p><p> 静态类不能直接引用外部类实例变量或实例方法，创建不需要依赖外部类，可以通过外部类的类名进行访问</p></li><li><p>静态代码块和构造方法哪个先执行？子类中的静态代码块和父类的静态代码块哪个先执行？<br> 静态代码块（类加载中，静态代码块就执行，类还没加载完成，构造方法没有执行）<br> 父类中先执行<br> 参考<a href="https://www.cnblogs.com/Qian123/p/5713440.html" target="_blank" rel="noopener">Java提高篇——静态代码块、构造代码块、构造函数以及Java类初始化顺序</a></p></li><li><p>静态块何时运行<br> 它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的</p></li><li><p>java 中 static、final、static final 的区别是什么？<br> final 可以修饰属性、方法、类、局部变量（方法中的变量），修饰属性的初始化可以在编译期，也可以在运行期，初始化后不能被改变；修饰的属性表明是一个常数；修饰方法表示方法不能在子类中被重写；修饰类表示类不能被继承。</p><p> static 可以修饰属性、方法、代码段、内部类（静态内部类或嵌套内部类），修饰属性的初始化在编译期（类加载的时候），初始化后可以被修改值；修饰的属性、方法、代码段跟该类的具体对象无关，不创建对象也能调用 static 修饰的属性、方法等；static 不可以修饰局部变量。</p><p> static final（或者 final static）是组合修饰，static 修饰的属性强调它们只有一个，final 修饰的属性表明是一个常数（创建后不能被修改），static final 修饰的属性表示一旦给值就不可修改并且可以通过类名访问，static final 也可以修饰方法，表示该方法不能重写，可以在不 new 对象的情况下调用。</p></li></ol><h2 id="JDK相关"><a href="#JDK相关" class="headerlink" title="JDK相关"></a>JDK相关</h2><p><a href="https://www.oracle.com/corporate/pressrelease/Java-10-032018.html" target="_blank" rel="noopener">Java官网</a></p><h3 id="Java-10新特性"><a href="#Java-10新特性" class="headerlink" title="Java 10新特性"></a>Java 10新特性</h3><ul><li>局部变量类型推断</li><li>整合 JDK 代码仓库</li><li>统一的垃圾回收接口</li><li>并行全垃圾回收器 G1</li><li>应用程序类数据共享 AppCDS</li><li>线程-局部管控</li><li>移除 Native-Header 自动生成工具</li><li>额外的 Unicode 语言标签扩展</li><li>备用存储装置上的堆分配</li></ul><p>详细参考<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html" target="_blank" rel="noopener">Java 10 新特性介绍</a></p><h3 id="Java-9新特性"><a href="#Java-9新特性" class="headerlink" title="Java 9新特性"></a>Java 9新特性</h3><ul><li>模块系统：模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）</li><li>REPL (JShell)：交互式编程环境。</li><li>HTTP 2 客户端：HTTP/2标准是HTTP协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。</li><li>改进的 Javadoc：Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。</li><li>多版本兼容 JAR 包：多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。</li><li>集合工厂方法：List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。</li><li>私有接口方法：在接口中使用private私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。</li><li>进程 API: 改进的 API 来控制和管理操作系统进程。引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。</li><li>改进的 Stream API：改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。</li><li>改进 try-with-resources：如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</li><li>改进的弃用注解 @Deprecated：注解 @Deprecated 可以标记 Java API 状态，可以表示被标记的 API 将会被移除，或者已经破坏。</li><li>改进钻石操作符(Diamond Operator) ：匿名类可以使用钻石操作符(Diamond Operator)。</li><li>改进 Optional 类：java.util.Optional 添加了很多新的有用方法，Optional 可以直接转为 stream。</li><li>多分辨率图像 API：定义多分辨率图像API，开发者可以很容易的操作和展示不同分辨率的图像了。</li><li>改进的 CompletableFuture API ： CompletableFuture 类的异步机制可以在 ProcessHandle.onExit 方法退出时执行操作。</li><li>轻量级的 JSON API：内置了一个轻量级的JSON API</li><li>响应式流（Reactive Streams) API: Java 9中引入了新的响应式流 API 来支持 Java 9 中的响应式编程。</li></ul><h3 id="Java-8新特性"><a href="#Java-8新特性" class="headerlink" title="Java 8新特性"></a>Java 8新特性</h3><ul><li><p>Lambda表达式和函数式接口<br>  函数式接口（functional interface 也叫功能性接口，其实是同一个东西）。简单来说，函数式接口是只包含一个方法的接口。比如Java标准库中的java.lang.Runnable和 java.util.Comparator都是典型的函数式接口。java 8提供 @FunctionalInterface作为注解,这个注解是非必须的，只要接口符合函数式接口的标准（即只包含一个方法的接口），虚拟机会自动判断，但最好在接口上使用注解@FunctionalInterface进行声明，以免团队的其他人员错误地往接口中添加新的方法。<br>  使用了函数式接口的匿名类可以使用Lambda来优化代码</p></li><li><p>接口的默认方法与静态方法<br>  接口中可以有实现方法；并且接口也可以有静态方法，工具类也可以使用接口来实现。<br>  默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写</p></li><li><p>方法引用<br>  在学习lambda表达式之后，我们通常使用lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：<br>  <code>Arrays.sort(stringsArray,(s1,s2)-&gt;s1.compareToIgnoreCase(s2));</code><br>  在Java8中，我们可以直接通过方法引用来简写lambda表达式中已经存在的方法。这种特性就叫方法引用：<br>  <code>Arrays.sort(stringsArray, String::compareToIgnoreCase);</code></p><p>  第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式：Class::new<br>  第二种方法引用的类型是静态方法引用，语法是Class::static_method<br>  第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method<br>  第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method</p></li><li><p>重复注解<br>  允许在同一个地方多次使用同一个注解</p></li><li><p>更好的类型推断<br>  编译器可以推导出某个参数的数据类型</p></li><li><p>拓宽注解的应用场景<br>  注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上</p></li><li><p>参数名称<br>  为了在运行时获得Java程序中方法的参数名称，老一辈的Java程序员必须使用不同方法，例如Paranamer liberary。Java 8终于将这个特性规范化，在语言层面（使用反射API和Parameter.getName()方法）和字节码层面（使用新的javac编译器以及-parameters参数）提供支持。</p></li><li><p>Java官方库的新特性<br>  Java 8增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等</p></li><li><p>新工具<br>  新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps</p></li><li><p>Stream API</p></li><li><p>Date Time API</p></li><li><p>Optional 类 用来解决空指针异常</p></li><li><p>Nashorn, JavaScript 引擎</p></li></ul><h3 id="Java-7新特性"><a href="#Java-7新特性" class="headerlink" title="Java 7新特性"></a>Java 7新特性</h3><ul><li><p>switch中可以使用字串了</p></li><li><p>运用List tempList = new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断</p></li><li><p>语法上支持集合，而不一定是数组<br>  <code>final List&lt;Integer&gt; piDigits = [ 1,2,3,4,5,8 ];</code></p></li><li><p>新增一些取环境信息的工具方法</p><blockquote><p>File System.getJavaIoTempDir() // IO临时文件夹<br>File System.getJavaHomeDir() // JRE的安装目录<br>File System.getUserHomeDir() // 当前用户目录<br>File System.getUserDir() // 启动java进程时所在的目录5</p></blockquote></li><li><p>Boolean类型反转，空指针安全,参与位运算</p><blockquote><p>Boolean Booleans.negate(Boolean booleanObj)<br>True =&gt; False , False =&gt; True, Null =&gt; Null<br>boolean Booleans.and(boolean[] array)<br>boolean Booleans.or(boolean[] array)<br>boolean Booleans.xor(boolean[] array)<br>boolean Booleans.and(Boolean[] array)<br>boolean Booleans.or(Boolean[] array)<br>boolean Booleans.xor(Boolean[] array)</p></blockquote></li><li><p>两个char间的equals<br>  boolean Character.equalsIgnoreCase(char ch1, char ch2)</p></li><li><p>安全的加减乘除</p><blockquote><p>int Math.safeToInt(long value)<br>int Math.safeNegate(int value)<br>long Math.safeSubtract(long value1, int value2)<br>long Math.safeSubtract(long value1, long value2)<br>int Math.safeMultiply(int value1, int value2)<br>long Math.safeMultiply(long value1, int value2)<br>long Math.safeMultiply(long value1, long value2)<br>long Math.safeNegate(long value)<br>int Math.safeAdd(int value1, int value2)<br>long Math.safeAdd(long value1, int value2)<br>long Math.safeAdd(long value1, long value2)<br>int Math.safeSubtract(int value1, int value2)</p></blockquote></li><li><p>map集合支持并发请求，且可以写成 Map map = {name:”xxx”,age:18};</p></li></ul><p>附：指针和引用的联系与区别</p><ul><li>相同点：<ol><li>都是地址的概念；<br> 指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。</li></ol></li><li>区别：<ol><li>指针是一个实体，而引用仅是个别名；</li><li>引用使用时无需解引用(*)，指针需要解引用；</li><li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li><li>引用没有 const，指针有 const；</li><li>引用不能为空，指针可以为空；</li><li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；</li><li>指针和引用的自增(++)运算意义不一样；</li><li>从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</li></ol></li></ul><h3 id="Java-6新特性"><a href="#Java-6新特性" class="headerlink" title="Java 6新特性"></a>Java 6新特性</h3><ul><li>在awt中新增Desktop类与SystemTray类</li><li>使用JAXB2来实现对象与XML之间的映射</li><li>使用Compiler API实现动态编译</li><li>轻量级Http Server API</li><li>插入式注解处理API</li><li>用Console开发控制台程序</li><li>对脚本语言的支持 如：ruby,groovy,JavaScript</li><li>Common Annotations</li></ul><h3 id="Java-5新特性"><a href="#Java-5新特性" class="headerlink" title="Java 5新特性"></a>Java 5新特性</h3><ul><li>自动装箱拆箱</li><li>可变参数</li><li>for-each</li><li>枚举</li><li>静态导入</li><li>泛型</li><li>线程并发库concurrent</li><li>注解</li></ul><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><ol><li><p>Java1.7与1.8新特性<br> 如上</p></li><li><p>java8新特性，as怎么让他变成1.8编译<br> Lambda表达式和函数式接口、接口的默认方法与静态方法、方法引用、重复注解</p><p> 在app下的build.gradle中添加如下代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        <span class="comment">//使用JAVA8语法解析</span></span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>java 1.5 的自动装箱拆箱机制是编译特性还是虚拟机运行时特性？分别是怎么实现的？<br> java 1.5 开始的自动装箱拆箱机制其实是编译时自动完成替换的，装箱阶段自动替换为了 valueOf 方法，拆箱阶段自动替换为了 xxxValue 方法。对于 Integer 类型的 valueOf 方法参数如果是 -128~127 之间的值会直接返回内部缓存池中已经存在对象的引用，参数是其他范围值则返回新建对象；而 Double 类型与 Integer 类型类似，一样会调用 Double 的 valueOf 方法，但是 Double 的区别在于不管传入的参数值是多少都会 new 一个对象来表达该数值（因为在指定范围内浮点型数据个数是不确定的，整型等个数是确定的，所以可以 Cache）。</p></li></ol><h2 id="JAVA序列化"><a href="#JAVA序列化" class="headerlink" title="JAVA序列化"></a>JAVA序列化</h2><h2 id="克隆（拷贝）"><a href="#克隆（拷贝）" class="headerlink" title="克隆（拷贝）"></a>克隆（拷贝）</h2><p><a href="./Java拷贝总结.md">Java拷贝相关知识</a></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>参考 发展史<a href="https://blog.csdn.net/HeatDeath/article/details/78620330" target="_blank" rel="noopener">常见编码方式之间的区别</a><br><a href="https://blog.csdn.net/lubiaopan/article/details/4714909" target="_blank" rel="noopener">Java:Unicode简介</a></p><ul><li>Unicode<br>  Java中的标准编码方式，使用16进制，2字节，不兼容iso8859-1，不便于传输和存储（占用空间过大，英文也是2字节），兼容UTF-8、UTF-16、UTF-32</li><li>ASCII<br>  美国信息互换标准代码，单字节编码系统，表示英文，ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。</li><li>UTF-8<br>  不定长编码，每个字符长度1-6个字节不等，兼容ISO8859-1，UTF系列面向传输，一个中文字符占3个字节</li><li>GBK/GB2312<br>  GB2312是简体中文的国际编码，专门用于表示汉字，兼容ASCII，2字节。<br>  GBK是GB2312的扩展</li><li>ISO8859-1<br>  单字节编码，最多表示0~255的字符范围，主要用于英文，表示汉字时乱码（汉字2字节）</li><li>BIG5<br>  繁体字编码，2字节</li></ul><ol><li><p>常见编码方式<br> Unicode、ASCII、UTF-8、ISO8859-1、GBK</p></li><li><p>utf-8编码中的中文占几个字节<br> utf-8中占3字节，Unicode中占2字节</p></li><li><p>怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"你好"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(s1.getBytes(<span class="string">"GB2312"</span>), <span class="string">"ISO_8859-1"</span>);</span><br></pre></td></tr></table></figure></li><li><p>造成乱码的原因（基本都是编码原因）<br> （1）程序使用的编码与本机的编码不统一<br> （2）网络中，客户端与服务端的编码不统一</p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>静态代理和动态代理的区别，什么场景使用？<br> <a href="https://www.jianshu.com/p/2f518a4a4c2b" target="_blank" rel="noopener">Java静态代理和动态代理</a><br> <a href="https://www.jianshu.com/p/861223789d53" target="_blank" rel="noopener">Java代理和动态代理机制分析和应用</a></p></li><li><p>try catch finally，try里有return，finally还执行么？<br> 执行，try里的return会等到finally执行完后才返回，finally块的语句在try或catch中的return语句执行之后返回之前执行且finally里的修改语句可能影响也可能不影响try或catch中，如果finally中也有return语句，会覆盖try或catch里的return语句。</p></li><li><p>foreach与正常for循环效率对比<br> 由于for循环的特性，每次循环都会进行比较，所以效率上不如foreach。<br> 但这个结论并不是绝对的，选择for或者foreach，还要考虑几点：</p><p> 如果只是读数据，优先选择foreach，因为效率高，而且代码简单，方便；（ArrayList）<br> 如果要写数据，即替换指定索引位置处的对象，就只能选择for了。（数组结构）</p></li><li><p>谈下你对面向对象的理解<br> 面向对象是相对于面向过程而言的，面向过程强调的是功能，面向对象强调的是将功能封装进对象强调具备功能的对象，</p><ul><li>思想特点好处：<ul><li>是符合人们思考习惯的一种思想；</li><li>将复杂的事情简单化了；</li><li>将程序员从执行者变成了指挥者</li></ul></li></ul></li><li><p>java和JavaScript的区别<br> Java 是一种 OOP 编程语言，而 Java Script 是一种 OOP 脚本语言。<br> Java 创建在虚拟机或浏览器中运行的应用程序，而 JavaScript 代码仅在浏览器中运行。<br> Java 代码需要进行编译，而 JavaScript 代码都在文本中。<br> 它们需要不同的插件</p></li><li><p>printf的执行过程<br> <a href="http://naotu.baidu.com/file/8d503729584f01d4bb08e0ae80a909fe?token=0c738cb0ac5ffecb" target="_blank" rel="noopener">printf执行脑图</a><br> <a href="https://blog.csdn.net/asivy/article/details/18703417" target="_blank" rel="noopener">System.out 源码分析</a></p></li><li><p>Java与C++对比</p><blockquote><p>指针<br>Java 没有指针的概念，从而有效地防止了在 C/C++语言中，容易出现的指针操作失误（如指针悬空所造成的系统崩溃）。在 C/C++中，指针操作内存时，经常会出现错误。在Java 中没有指针，更有利于 Java 程序的安全。</p><p>多重继承</p><p>C++支持多重继承，它允许多父类派生一个子类。也就是说，一个类允许继承多个父类。尽管多重继承功能很强，但使用复杂，而且会引起许多麻烦，编译程序实现它也很不容易。所以 Java 不支持多重继承，但允许一个类实现多个接口。可见，Java 既实现了 C++多重继承的功能，又避免了 C++的许多缺陷。</p><p>数据类型</p><p>Java 是完全面向对象的语言，所有方法和数据都必须是类的一部分。除了基本数据类型之外，其余类型的数据都作为对象型数据。例如对象型数据包括字符串和数组。类将数据和方法结合起来，把它们封装在其中，这样每个对象都可实现具有自己特点的行为。而 C++将函数和变量定义为全局的，然后再来调用这些函数和变量，从而增加了程序的负担。此外，Java 还取消了 C/C++中的结构和联合，使编译程序更简洁。</p><p>自动内存管理<br>Java 程序中所有的对象都是用 new 操作符建立在堆栈上的，这个操作符类似于 C++的“new”操作符。Java 自动进行无用内存回收操作，不需要程序员进行删除。当 Java 中一个对象不再被用到时，无须使用内存回收器，只需要给它加上标签以示删除。无用内存的回收器在后台运行，利用空闲时间工作。而 C++中必须由程序释放内存资源，增加了程序设计者的负担。</p><p>操作符重载</p><p>Java 不支持操作符重载，操作符重载被认为是 C++的突出特征。在 Java 中虽然类可以实现这样的功能，但不支持操作符重载，这样是为了保持 Java 语言尽可能简单。</p><p>预处理功能</p><p>C/C++在编译过程中都有一个预编译阶段，即预处理器。预处理器为开发人员提供了方便，但增加了编译的复杂性。Java 允许预处理，但不支持预处理器功能，因为 Java 没有预处理器，所以为了实现预处理，它提供了引入语句（import），它与 C++预处理器的功能类似。</p><p>Java 不支持缺省函数参数，而 C++支持。<br>在 C 中，代码组织在函数中，函数可以访问程序的全局变量。C++增加了类，提供了类算法，该算法是与类相连的函数，C++类方法与 Java 类方法十分相似。由于 C++仍然支持 C，所以 C++程序中仍然可以使用 C 的函数，结果导致函数和方法混合使用，使得 C++程序比较混乱。</p><p>Java 没有函数，作为一个比 C++更纯的面向对象的语言。Java 强迫开发人员把所有例行程序包括在类中。事实上，用方法实现例行程序可激励开发人员更好地组织编码。</p><p>字符串</p><p>C 和 C++不支持字符串变量，在 C 和 C++程序中使用“Null”终止符代表字符串的结束，在 Java 中字符串是用类对象（String 和 StringBuffer）来实现的，在整个系统中建立字符串和访问字符串元素的方法是一致的。Java 字符串类是作为 Java 语言的一部分定义的，而不是作为外加的延伸部分。此外，Java 还可以对字符串用“+”进行连接操作。</p><p>goto 语句</p><p>“可怕”的 goto 语句是 C 和 C++的“遗物”。它是该语言技术上的合法部分，引用 goto语句造成了程序结构的混乱，不易理解。goto 语句一般用于无条件转移子程序和多结构分支技术。Java 不提供 goto 语句，其虽然指定 goto 作为关键字，但不支持它的使用，这使程序更简洁易读。</p><p>类型转换</p><p>在 C 和 C++中，有时出现数据类型的隐含转换，这就涉及了自动强制类型转换问题。例如，在 C++中可将一个浮点值赋予整型变量，并去掉其尾数。Java 不支持 C++中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。</p><p><a href="https://zh.wikipedia.org/wiki/Java和C%2B%2B的對照" target="_blank" rel="noopener">Java和C++的对照</a></p></blockquote></li><li><p>说说你对 Java 中 Jar 包的理解<br> Jar 包的本质是将多个文件聚集为一个 ZIP 包，与传统的 ZIP 文件不同的是 Jar 包不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被编译器和 JVM 等工具直接使用。在 Jar 包中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 Jar 包。此外 Jar 包提供了许多 ZIP 文件没有的优势和功能，譬如 Jar 包可以保证安全性（对 Jar 文件内容加上数字化签名）、增加传输平台扩展性（作为 Java 扩展框架）、密封性和跨平台特性。</p></li><li><p>Jar 包中 META-INF 目录下都有什么作用？<br> 很多 Jar 包包含一个 META-INF 目录，它用来存储包和扩展的配置数据（如安全性和版本信息），Java 平台会识别并解释 META-INF 目录下的文件来配置应用程序、扩展和类装载器。META-INF 目录包含的常见文件如下：</p><p> MANIFEST.MF：这个 manifest 文件定义了与扩展和包相关的数据（譬如 java -jar 命令执行的 MainClass 就在这里面指定）。</p><p> XXX.SF：这是 Jar 包的签名文件，其中 XXX 表示签名者。</p><p> XXX.DSA：这是与签名文件相关联的签名程序块文件，它存储了用于签名 Jar 文件的公共签名。</p></li><li><p>Jar 包签名是怎么回事，谈谈你的看法<br>签名的jar可以检测代码是否被篡改，还可以通过给有可信签名的jar赋予更多的操作权限。Jar 包可以用 jarsigner 工具或者直接通过 java.security API 进行签名来保证安全性。一个签名的 Jar 包与原来的 Jar 包代码部分完全相同，只是更新了它的 manifest 且在 META-INF 目录中增加了一个签名文件和一个签名块文件。<br>Jar包签名采用公钥/密钥机制。密钥就类似用于文件上签字的钢笔。只有你自己有，而与秘钥相对应的公钥可以被其他人拥有。通过公钥对被秘钥加密的文件进行解密，来验证文件的安全性。但是即使jar包含有匹配的公钥/密钥，你还是需要验证公钥是否来自真实的文件加密者（一个人可以伪造某个机构，用自己的密钥对jar进行加密，然后把公钥放入jar,这样同样能进行解密）</p></li><li><p>简单谈谈你对 Java 中 null 的理解与认识<br>null 在 java 中是一个老大难问题，最容易翻车的就是 NPE 问题，而譬如 kotlin 等语言的出现填补了 java 的这一弊端。关于 java 的 null 理解总结如下。</p><p>null 是 java 的关键字。</p><p>null 是 java 中引用类型的默认值。</p><p>null 既不是对象也不是一种类型，仅是一种特殊的值，我们可以将其赋予任何引用类型，也可以将 null 强转化成任何类型。</p><p>null 可以赋值给引用变量，但不能赋给基本类型变量，否则编译会报错。但是如果将 null 赋值给包装类型，然后将包装类型赋给各自的基本类型，编译器不会报，但在运行时会抛出空指针异常，这是因为 Java中 自动拆箱导致的。</p><p>instanceof 中使用带有 null 值的引用类型变量将会返回 false，这是 instanceof 操作符一个很重要的特性。</p><p>不能使用值为 null 的引用类型变量来调用对象的非静态方法（NPE 问题），但是可以使用值为 null 的引用类型变量来调用对象的静态方法，因为静态方法使用静态绑定，编译时就决定了，所以运行时不会抛出空指针异常。</p><p>可以使用 == 或 != 操作符来比较 null 值，但是不能使用其他操作符或者逻辑操作（譬如 &lt; 或 &gt; 等）来比较 null 值（会发生 NPE 问题），在 Java 中 null == null 会返回 true。</p></li><li><p>java.sql.Date 和 java.util.Date 有什么区别<br>java.util.Date 就是在除了SQL语句的情况下面使用, java.sql.Date 是针对SQL语句使用的，它只包含日期而没有时间部分,它都有getTime方法返回毫秒数，自然就可以直接构建<br>java.util.Date 是 java.sql.Date 的父类（注意拼写）；前者是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他；后者之后在读写数据库的时候用</p></li><li><p>说说 Java 中 ScheduledExecutorService 与 Timer 的区别<br>Timer 计时器具备使任务延迟执行以及周期性执行的功能，但是 Timer 天生存在一些缺陷，所以从 JDK 1.5 开始就推荐使用 ScheduledThreadPoolExecutor（ScheduledExecutorService 实现类）作为其替代工具。</p><p>首先 Timer 对提交的任务调度是基于绝对时间而不是相对时间的，所以通过其提交的任务对系统时钟的改变是敏感的（譬如提交延迟任务后修改了系统时间会影响其执行）；而 ScheduledThreadExecutor 只支持相对时间，对系统时间不敏感。</p><p>接着 Timer 的另一个问题是如果 TimerTask 抛出未检查异常则 Timer 将会产生无法预料的行为，因为 Timer 线程并不捕获异常，所以 TimerTask 抛出的未检查异常会使 Timer 线程终止，所以后续提交的任务得不到执行；而 ScheduledThreadPoolExecutor 不存在此问题。</p></li><li><p>Math.round(15.5) 等于多少？Math.round(-15.5) 等于多少<br>分别等于 16 和 -15。<br>因为四舍五入的原理是在参数上加 0.5 然后进行下取整。所以类似的 Math.round(15.6) 计算方式为 15.6 + 0.5 = 16.1，接着向下取整数为 16；Math.round(-15.6) 计算方式为 -15.6 + 0.5 = -15.1，接着向下取整数为 -16。<br>这是一个很小但是很坑的知识点，切记不是四舍五入，是加 0.5 向下取整数。</p></li><li><p>如何用最有效的方式计算 2 乘以 8 等于几<br>2 &lt;&lt; 3</p></li><li><p>定义一个赋值为 null 的类类型变量名 a，能否通过 a 不进行实例化而直接访问其 static 属性或者方法<br>可以，当通过一个对象的引用访问静态成员属性或方法时，访问操作只与声明的类型相关，与引用对象是否为null无关，因为访问静态属性或方法不需要实例化对象，即便引用不为null，也与运行时的多态无关，静态成员是类相关的</p></li><li><p>Java 中一个方法可以存在多个变长参数吗？<br>不可以，当方法有多个参数时，可变长参数必须位于最后。个方法只能有一个可变长参数，且这个可变长参数必须是该方法的最后一个参数，java 不允许存在一个方法具备多个变长参数或者变长参数不是方法的最后位置的情况</p></li><li><p>Java 代码块是什么？代码块的分类有哪些？作用是什么？<br>所谓代码块就是用大括号 {} 将多行代码封装在一起形成一个独立的数据体，用于实现特定的需求，一般来说代码块是不能单独运行的，它必须要有运行主体。</p><p>（1）普通代码块（局部代码快）是在方法名后面用 {} 括起来的代码段，不能够单独存在，必须要紧跟在方法名后面且必须使用方法名调用它，作用是限定变量的生命周期和提高效率。</p><p>（2）构造代码块是在类中方法外用 {} 括起来的代码，作用是把所有构造方法中相同的内容抽取出来，将来在调用构造方法的时候会去自动调用构造代码块，构造代码快优先于构造方法。</p><p>（3）静态代码块是在类中方法外用 {} 括起来且添加了 static 前缀修饰的代码，作用是随着类的加载而加载且只加载一次。</p><p>（4）同步代码块是方法中使用 synchronized 关键字修饰并使用 {} 括起来的代码片段，表示同一时间只能有一个线程进入到该代码块中，作用是一种多线程并发保护机制。</p></li><li><p>Java 中静态代码块、构造代码块、构造方法的执行顺序是什么？<br>因为静态代码块作用于类级别，构造代码块和构造方法作用于对象级别，所以静态代码块是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化；构造代码块在每次创建一个对象时就会执行一次且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境；构造方法在每次创建一个对象时就会执行一次，同时构造方法是给特定对象进行初始化，而构造代码是给所有对象进行初始化；所以通过分析得出他们三者的执行顺序为 静态代码块 &gt; 构造代码块 &gt; 构造方法。</p></li><li><p>java 中什么时候使用断言（assert）？<br>如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它<br>以一个函数为例，它要求在开始执行的时候满足一系列条件，这些条件被称为“前条件”或者“先验条件”，比如，参数不为空，某全局变量应该为1，等等。不满足前条件，是不能调用此函数的，如果出现了前条件不满足仍然调用了此函数，可以认为这是一个设计错误。检查前条件，可以使用assert</p></li><li><p>说说 java 的 instanceof 与 obj.instanceof(class) 的区别<br>java 中的 instanceof 运算符用来在运行时指出对象是否是特定类的一个实例，通过返回一个布尔值来指出这个对象是否是这个特定类或者是它的子类的一个实例；用法为 result = object instanceof class，参数 result 布尔类型，object 为必选项的实例，class 为必选项的任意已定义的对象类，如果 object 是 class 的一个实例则 instanceof 运算符返回 true，如果 object 不是指定类的一个实例或者 object 是 null 则返回 false；但是 instanceof 在 java 的编译状态和运行状态是有区别的，在编译状态中 class 可以是 object 对象的父类、自身类、子类，在这三种情况下 java 编译时不会报错，在运行转态中 class 可以是 object 对象的父类、自身类但不能是子类，当为父类、自生类的情况下 result 结果为 true，为子类的情况下为 false。</p><p>Class.isInstance(obj) 表明这个对象能不能被转化为这个类，如果 obj 是调用这个方法的 Class 或接口的实例则返回true，这个方法是 instanceof 运算符的动态等价，如果 obj 为 null 则返回 false。</p></li><li><p>说说 java 的 instanceof 与 clazz.getClass() 的区别？<br>instanceof判断是否是某一类型的实例时，该类型可以是父类或者接口。而getclass 用于判断准确的类型。etclass判断的是该变量实际指向的对象的类型（即运行时类型），跟声明该变量的类型无关</p></li><li><p>简单说说 java 的 instanceof 实现原理？<br>首先 instanceof 直接对应一条虚拟机指令 instanceof 且为 java 语法保留关键字，而非通过反射实现；instanceof 在底层实现上维护了主要超类型（继承深度）小于一个固定数值（一般为 7）的主数组和次要超类型（判断的时候需要 super 链遍历查找），然后在字节码使用特殊指令对常量池中的相关符号引用进行判断，从而来决定是否某个类或者派生类，以此返回 true 或 false</p></li><li><p>Java 创建对象的方式有哪几种？<br>（1）使用 new 关键字（调用构造方法）<br>（2）使用 Class 类的 newInstance 方法（调用构造方法）<br>（3）使用 Constructor 类的 newInstance 方法（调用构造方法）<br>（4）使用 clone 方法（没有调用构造方法）<br>（4）使用反序列化（没有调用构造方法）</p></li><li><p>if和switch的区别：<br>if针对结果是布尔类型的判断，switch的类型是byte、short、int、char、String、枚举<br>if可以针对范围的判断（关系操作符、逻辑操作符等），switch比较的就是一个具体的值或常量，只能==<br>当只有分支比较少的时候，if效率比switch高（因为switch有跳转表），分支比较多，switch效率高</p></li><li><p>java里带$的函数见过么，是什么意思</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本数据类型、String总结</title>
      <link href="/2020/02/07/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81String%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81String%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Java基本数据类型、String总结"><a href="#Java基本数据类型、String总结" class="headerlink" title="Java基本数据类型、String总结"></a>Java基本数据类型、String总结</h1><p><strong>声明</strong>：部分面试题来自微信公众号<strong>码农每日一题</strong></p><h2 id="数据基本类型"><a href="#数据基本类型" class="headerlink" title="数据基本类型"></a>数据基本类型</h2><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">内置数据类型</td><td align="center">bit数</td><td align="center">占用字节数</td><td align="center">范围和默认值</td><td align="center">封装类</td></tr><tr><td align="center">byte</td><td align="center">8</td><td align="center">1</td><td align="center">max：-2^7，min：2^7-1，默认值：0</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">16</td><td align="center">2</td><td align="center">max：-2^15，min：2^15，默认值：0</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">32</td><td align="center">4</td><td align="center">max：-2^31，min：2^31-1，默认值：0</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">64</td><td align="center">8</td><td align="center">max：-2^63，min：2^63-1，默认值：0L</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">32</td><td align="center">4</td><td align="center">单精度浮点数，默认值：0.0f</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">64</td><td align="center">8</td><td align="center">双精度浮点数，浮点数的默认类型，默认值：0.0d</td><td align="center">Double</td></tr><tr><td align="center">boolean</td><td align="center">8</td><td align="center">1</td><td align="center">只有true和false，默认值false</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">16</td><td align="center">2</td><td align="center">max：\u0000 (0)，min：\uffff (65535)</td><td align="center">Character</td></tr></tbody></table><p><strong>自动类型转换优先级</strong> 参考<a href="http://www.runoob.com/java/java-basic-datatypes.html" target="_blank" rel="noopener">Java 基本数据类型</a><br>从低到高：byte，short，char -&gt; int -&gt; long -&gt; float -&gt; double<br>需要注意：</p><blockquote><ol><li>不能对boolean类型进行转换</li><li>不能把对象类型传换成不相关类的对象</li><li>把容量大的类型转换为容量小的类型必须使用强制转换</li><li>转换过程中可能会出现溢出或损失精度</li><li>浮点数到整数的转换是通过舍弃小数得到的，而不是四舍五入</li><li>强制类型转换的数据类型必须是兼容的</li><li>隐含强制类型转换，整数的默认类型是int</li></ol></blockquote><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><ol><li><p>int、char、long各占多少字节数<br> 如上表格：分别4、2、8</p></li><li><p>九种基本数据类型的大小，以及他们的封装类<br> 如上表，或者参考<a href="https://blog.csdn.net/rabbit_in_android/article/details/49793813" target="_blank" rel="noopener">九种基本数据类型，以及他们的封装类</a></p><blockquote><p>byte -&gt; Byte 1字节<br>short -&gt; Short 2字节<br>int -&gt; Integer 4字节<br>long -&gt; Long 8字节<br>float -&gt; Float 4字节<br>double -&gt; Double 8字节<br>boolean -&gt; Boolean 1字节<br>char -&gt; Character 2字节<br>void -&gt; Void 没有字节数</p></blockquote></li><li><p>基本数据类型与对象的差别<br> 基本数据类型不是对象，也就是使用int、double、boolean等定义的变量、常量。<br> 基本数据类型没有可调用的方法。<br> 基本数据类型的值是直接保存在变量中，对象是引用类型，变量中保存的是实际对象的地址。参考<a href="https://www.jianshu.com/p/587625e390e1" target="_blank" rel="noopener">Java基本数据类型和引用类型的区别</a></p><p> 赋值的区别：基本数据类型进行的赋值操作是复制、按值传递，修改一个的值不会影响另一个的值（赋值后是两个地址）；对象的赋值操作是引用，指向同一块地址，当其中一个对象进行修改后，修改的是地址里面的内容，另一个获取的内容也是修改后的。参考<a href="https://blog.csdn.net/xiongmaodeguju/article/details/54409495" target="_blank" rel="noopener">JAVA中基本数据类型的引用与对象赋值的区别</a></p></li><li><p>什么是自动装箱拆箱<br> 见下面</p></li><li><p>java 是否存在使得语句 i &gt; j || i &lt;= j 结果为 false 的 i、j 值<br> 存在，java 的数值 NaN 代表 not a number，无法用于比较，例如使 i = Double.NaN; j = i; 最后 i == j 的结果依旧为 false，</p></li><li><p>java 1.5 的自动装箱拆箱机制是编译特性还是虚拟机运行时特性？分别是怎么实现的？<br> 参考<a href="https://mp.weixin.qq.com/s/akaEG8SPwlyaF2eXY_-AUA" target="_blank" rel="noopener">Java 包装类型装箱拆箱基础面试题</a></p></li><li><p>java 的 switch 语句能否作用在 byte 类型变量上，能否作用在 long 类型变量上，能否作用在 String 类型变量上？<br> switch<strong>不支持</strong>long、boolean类型变量，支持byte、short、int、char、enum、Byte、Short、Integer、Character类型变量以及<strong>Java 1.7开始支持String类型</strong>。其中long类型的数据范围过大，大于int，会造成精度损失；byte范围小于int</p><p> 原理：原来用在 switch 语句中的字符串被替换成了对应的哈希值，而 case 子句的值也被换成了原来字符串常量的哈希值。经过这样的转换，Java 虚拟机所看到的仍然是与整数类型兼容的类型。在这里值得注意的是，在 case 子句对应的语句块中仍然需要使用 String 的 equals 方法来进行字符串比较。这是因为哈希函数在映射的时候可能存在冲突，多个字符串的哈希值可能是一样的。进行字符串比较是为了保证转换之后的代码逻辑与之前完全一样。</p></li></ol><ul><li>byte、Byte</li><li>long、Long</li><li>boolean、Boolean</li><li>int、Integer<ol><li>int型几个字节<br> 4个</li><li>int与Integer的区别<br> int是Java内置基本数据类型之一，Integer是int的封装类（包装类），int默认值为0，Integer默认值为null，Integer是一个类，可以new一个对象</li><li>java 语句 Integer i = 1; i += 1; 做了哪些事情<br> Integer i = 1;这一句声明了一个了Integer的对象，并赋值为1，然后jdk会进行自动装箱，将1转换为一个Integer对象，调用Integer.valueOf(int i)<br> i += 1;这一句又进行了自动拆箱，由于i是一个对象引用，不能直接进行操作符运算，jdk会自动将i这个Integer对象拆箱为一个int值，其值为之前对象所拥有的值，然后将计算结果2赋值给i，由于i是一个Integer对象，2只是一个int型值，所以又会发生自动装箱，将2装进i这个对象引用</li></ol></li><li>double、Double<ol><li>能否在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量？<br> 不行，从自动转换的优先级 从低到高：byte，short，char -&gt; int -&gt; long -&gt; float -&gt; double可以知道，double类型的范围比long更大，大向小转换必须强制转换</li><li>java 中 3*0.1 == 0.3 将会返回什么？true 还是 false<br> false，浮点数不能完全精确的表示出来，一般都会精度损失</li></ol></li><li>float、Float<ol><li>java 中 float f = 3.4; 是否正确？<br> 不正确，3.4是双精度数，float是单精度，属于向下转换，必须强制类型转换，或者3.4f（声明单精度浮点数）</li></ol></li><li>char、Character<ol><li>char占多少字节数<br> 2字节</li><li>java 中 char 类型变量能不能储存一个中文的汉字，为什么？<br> 可以，char用于储存Unicode编码字符，Unicode字符集包含了汉字。但是有些生僻字不再Unicode字符集内，就不能储存。准确说Unicode包含了就可以存储。参考<a href="https://blog.csdn.net/lubiaopan/article/details/4714909" target="_blank" rel="noopener">Java:Unicode简介</a></li></ol></li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ol><li><p>String 为什么要设计成不可变的？<br> （1）线程安全，不可变天生线程安全<br> （2）String常被用做HashMap的key，如果可变会引发安全性问题<br> （3）String常被用做数据库或接口的参数，可变会引发安全性问题<br> （4）通过字符串常量池可以节省空间，String值是储存在常量池中的<br> （5）每个String对应一个hashcode，再次使用不用重新计算，一定的性能优化</p><p> <a href="https://user-gold-cdn.xitu.io/2018/3/11/162133576a03ec38?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2018/3/11/162133576a03ec38?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="只改变引用"></a>只改变引用</p><p> 为什么不可变？<br> （1）String类本身是final的，不可以被继承<br> （2）String类内部通过private final char value[]实现，从而保证了引用的不可变和对外的不可见<br> （3）String内部通过良好的封装，不去改变value数组的值</p><p> 可以通过反射机制改变<br> 参考<a href="https://blog.csdn.net/zhangjg_blog/article/details/18319521" target="_blank" rel="noopener">Java中的String为什么是不可变的？ – String源码分析</a><a href="https://juejin.im/post/5aa1ee0c51882555677e2109" target="_blank" rel="noopener">String 为什么要设计成不可变的</a></p></li><li><p>String，Stringbuffer，Stringbuilder 区别<br> <a href="https://blog.csdn.net/kingzone_2008/article/details/9220691" target="_blank" rel="noopener">Java：String、StringBuffer和StringBuilder的区别</a><br> <a href="https://blog.csdn.net/rmn190/article/details/1492013" target="_blank" rel="noopener">String,StringBuffer与StringBuilder的区别??</a></p></li><li><p>switch能否用string做参数<br> Java1.7以前不可以，1.7开始就可以。</p></li><li><p>string to integer<br> 先转换为int，再装箱为Integer</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(str);</span><br><span class="line"><span class="comment">//1.5后会自动装箱，或者Integer integer = new Integer(i);或者Integer integer = Integer.valueOf(i);</span></span><br><span class="line">Integer integer = i;</span><br></pre></td></tr></table></figure></li><li><p>String a=”abc”,String b = “abc”，创建了几个对象？<br> 一个对象，String a = “abc”创建一个对象在堆上，当执行String b = “abc”时，堆上已经有了”abc”这个对象，所以不会再新建，直接将b指向”abc”这个对象</p></li><li><p>简单说说 String 的 isEmpty() 与 null 与 “” 的区别<br> isEmpty()是JDK封装的方法，是字符串对象的方法，如果没有分配内存时（String s或String s = null），调用此方法会报空指针异常。值为空，变量是否被初始化<br> null是判断字符串有没有分配内存空间，字符串是否指向一个内存地址，对象为空，表示数据未知或不可用，一般用于判断是不是实例化对象<br> “”是一个有值的字符串，值比较特殊，是空字符串，但是有内存空间，有内存地址<br> <a href="https://upload-images.jianshu.io/upload_images/4061843-1e1434d621a9d331.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-1e1434d621a9d331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br> <em>注意</em>：null+”abc”，结果为”nulabc”（原因可以看源码）</p></li><li><p>用 java 代码实现字符串的反转<br> （1）使用JDK中StringBuffer、StringBuidler的反转方法reverse</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ((str == <span class="keyword">null</span>) || (str.length() &lt;= <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(str).reverse().toString();</span><br><span class="line">    <span class="comment">//return new StringBuilder(str).reverse().toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> （2）递归实现</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((str == <span class="keyword">null</span>) || (str.length() &lt;= <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse(str.substring(<span class="number">1</span>)) + str.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 java 代码来检查输入的字符串是否回文（对称）<br> （1）JDK现有API</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">    strBuilder.reverse();</span><br><span class="line">    <span class="keyword">return</span> strBuilder.toString.equals(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> （2）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) != str.charAt(length - i -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 java 代码写一个方法从字符串中删除给定字符？</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeChar</span><span class="params">(String str, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.replaceAll(Character.toString(c), <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>能不能继承String类<br>不能，String类是final修饰的，被final修饰的类是不能被继承的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说说 String str = “hello world”; 和 String str = new String(“hello world”); 的区别？<br>String str = “hello world”在编译期间生成了字面常量和符号引用，在运行期间字面常量”hello world”被存储在运行时常量池（只保存一份），后面如果有再创建相同的字符串（比如String str1 = “hello world”）不会再重新创建，只会将新的引用指向它。<br>String str = new String(“hello world”)由于采用了new操作，所以每次new的时候都会产生一个新的对象，且new操作后，对象是放在堆内存中，每一个对象的地址都不同，哪怕是值相同（比如String str3 = new String(“hello world”)，str3与前面一个是不相同的两个对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"hello world"</span>;</span><br><span class="line">    String str0 = <span class="string">"Hello world"</span>;</span><br><span class="line">    String str1 = <span class="string">"hello world"</span>;</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="comment">//==比较的是内存地址，String不是基本类型所以不是比较的值</span></span><br><span class="line">    System.out.println(str == str0);  <span class="comment">//值不同，内存地址也应不同，在常量池中</span></span><br><span class="line">    System.out.println(str == str1);  <span class="comment">//相同的常量池，两个引用却是一个值</span></span><br><span class="line">    System.out.println(str == str2);  <span class="comment">//一个在常量池，一个在堆内存，地址不同</span></span><br><span class="line">    System.out.println(str2 == str3);  <span class="comment">//new操作，地址不同</span></span><br><span class="line">    <span class="comment">//由于String类重写了equals方法，所以equals比较的是字符串内容（值）</span></span><br><span class="line">    System.out.println(str.equals(str0));  <span class="comment">//值不同</span></span><br><span class="line">    System.out.println(str.equals(str1));  <span class="comment">//值相同</span></span><br><span class="line">    System.out.println(str.equals(str2));  <span class="comment">//值相同</span></span><br><span class="line">    System.out.println(str2.equals(str3));  <span class="comment">//值相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>false<br>true<br>false<br>false<br>false<br>true<br>true<br>true</p><p>Process finished with exit code 0</p></blockquote></li><li><p>语句 String str = new String(“abc”); 一共创建了多少个对象？<br>运行期间，new操作只创建了一个堆上的“abc”对象；在类加载过程中在运行时常量池中会先创建一个“abc”对象；创建了两个String对象。一个是“abc”，一个是指向“abc”的str。问题存在歧义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考链接[请别再拿“String s = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);创建了多少个String实例”来面试了吧](http:<span class="comment">//rednaxelafx.iteye.com/blog/774673/)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="自动装箱拆箱"><a href="#自动装箱拆箱" class="headerlink" title="自动装箱拆箱"></a>自动装箱拆箱</h2><p>自动装箱拆箱是在Java 1.5开始引入</p><ul><li>自动装箱：在1.5开始后，可以直接对基本类型的封装类进行直接赋值，jdk会自动将其转换。Java自动将原始类型值转换成对应的对象</li><li>自动拆箱：与装箱的过程正好相反，拆箱就是将对象转换为对应的原始类型</li></ul><p>例子1：参考<a href="https://blog.csdn.net/JairusChan/article/details/7513045" target="_blank" rel="noopener">Java自动装箱与拆箱及其陷阱</a><br>参考<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析Java中的装箱和拆箱</a><br>参考<a href="https://mp.weixin.qq.com/s/akaEG8SPwlyaF2eXY_-AUA" target="_blank" rel="noopener">Java 包装类型装箱拆箱基础面试题</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;  <span class="comment">//自动装箱，Java 1.5开始</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = i;  <span class="comment">//自动拆箱，Java 1.5</span></span><br></pre></td></tr></table></figure><p>自动装箱过程中，程序会自动执行Integer.valueOf(int i)这个方法，来进行new对象，实现了自动装箱<br>自动拆箱过程中，进行赋值的时候，程序会自动先执行Integer.intValue()方法，来实现拆箱</p><p>装箱拆箱陷阱：<br><a href="https://upload-images.jianshu.io/upload_images/4061843-9084ea13c1d09fd1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-9084ea13c1d09fd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="会导致如此的原因跟源码很有关系"></a>会导致如此的原因跟源码很有关系</p><ul><li><p>基本数据类型的自动装箱拆箱源码：<br>  （1）Integer</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装箱，缓存-128~127的值。可能缓存除此外的值（new了一个新的Integer对象）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （2）Byte</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （3）Long</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装箱，类似Integer，在-128~127时会强转为int缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （4）Character</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装箱，ASCII码&lt;=127的时候一定缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （5）Short</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装箱，类似Long</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">shortValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （6）Double</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装箱，直接new了一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （7）Float</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装箱，类似Double，直接new了一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Float <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Float(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （8）String</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似Double、Float，直接new对象，但是没怎么看懂String的拆箱（没找到）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>一个简单的总结</em>：Integer、Byte、Short、Long、Character五者的装箱拆箱过程基本差不多，出来Byte装箱不需要做判断，其余4个都需要判断是直接缓存还是new一个新的对象，缓存的时候对值有一定的要求；Double、Float没有对值进行判断，直接new了一个对象；String放在一起，它的装箱也有点类似Double</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射、注解总结</title>
      <link href="/2020/02/07/Java%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Java%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Java反射、注解"><a href="#Java反射、注解" class="headerlink" title="Java反射、注解"></a>Java反射、注解</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在运行时，通过反射可以获取类的所有信息</p><h3 id="什么是Class对象"><a href="#什么是Class对象" class="headerlink" title="什么是Class对象"></a>什么是Class对象</h3><p>Class对象包含了与类有关的信息，事实上，它就是用来创建类的所有的“常规”的对象。<br>每一个类都有一个Class对象（编译后被保存在一个同名的.class文件中），生成这个的过程是由JVM使用“类加载器”的子系统实现。</p><ul><li><strong>特别注意</strong><br>  RTTI和反射的区别只有一个，RTTI是编译器在编译时打开和检查.class文件，反射是编译器在运行时打开和检查.class文件（因为对于反射来说，编译时不能获取.class文件）</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>获取Class对象</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">""</span>;  <span class="comment">//全限定名（包含包名）</span></span><br><span class="line">Class stuClass = Class.forName(className);  <span class="comment">//根据全限定名</span></span><br><span class="line"></span><br><span class="line">Class stuClass = Student.class;  <span class="comment">//根据类名获取，这种更高效安全（会受到检查）</span></span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">Class stuClass = student.getClass();  <span class="comment">//根据类型对象，直接获取</span></span><br><span class="line"></span><br><span class="line">Class&lt;Student&gt; stuClass = Student.class;  <span class="comment">//可以范化，后面实例化对象的时候就可以不用强制转换了</span></span><br></pre></td></tr></table></figure></li><li><p>实例化对象</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据获取构造器实例化</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获取所有的构造器</span></span><br><span class="line">    Constructor[] constructors = stuClass.getConstructors();</span><br><span class="line">    <span class="comment">//获取对应的构造器，传入构造器的参数类型</span></span><br><span class="line">    Constructor constructor = stuClass.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//根据构造器实例化</span></span><br><span class="line">    Student student = constructor.newInstance(<span class="string">"constructor student"</span>, <span class="number">2345</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过newInstance获取实例，默认构造器</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//类型转换，方便后面调用</span></span><br><span class="line">    Student student = (Student) stuClass.newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有的方法</span></span><br><span class="line"><span class="comment">//获取方法，包括父类（Object也是）的，public的方法</span></span><br><span class="line">Method[] methods = stuClass.getMethods();</span><br><span class="line"><span class="comment">//只获取本类的方法，不问权限</span></span><br><span class="line">Method[] methods1 = stuClass.getDeclaredMethods();</span><br><span class="line"><span class="comment">//获取指定方法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//public的，参数方法名</span></span><br><span class="line">    Method method = stuClass.getMethod(<span class="string">"toString"</span>);</span><br><span class="line">    <span class="comment">//不管权限，不包括父类的方法</span></span><br><span class="line">    Method method1 = stuClass.getDeclaredMethod(<span class="string">"toString"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  访问方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果声明Class时没有泛化，就要强制转换，因为默认返回的是Object</span></span><br><span class="line">Student student = (Student) stuClass.newInstance();</span><br><span class="line"><span class="comment">//调用私有方法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method methodStudy = stuClass.getDeclaredMethod(<span class="string">"study"</span>, String.class);</span><br><span class="line">    methodStudy.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    methodStudy.invoke(student, <span class="string">"通过class访问方法"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取接口，进而可以获取接口中的方法、成员变量</span></span><br><span class="line">Class&lt;?&gt;[] interfaces = stuClass.getInterfaces();</span><br></pre></td></tr></table></figure></li><li><p>获取父类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取父类，进而可以获取父类相关的信息</span></span><br><span class="line">Class&lt;?&gt; parent = stuClass.getSuperclass();</span><br></pre></td></tr></table></figure></li><li><p>获取成员变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取public成员变量，所有的（包括父类，接口)</span></span><br><span class="line">Field[] fields = stuClass.getFields();</span><br><span class="line"><span class="comment">//只获取本类的成员变量，不问访问权限</span></span><br><span class="line">Field[] fields1 = stuClass.getDeclaredFields();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获取指定public成员变量</span></span><br><span class="line">    Field field = stuClass.getField(<span class="string">"age"</span>);</span><br><span class="line">    <span class="comment">//根据字段只获取Student类的，不问权限</span></span><br><span class="line">    Field field1 = stuClass.getDeclaredField(<span class="string">"stuNum"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  修改成员变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果声明Class时没有泛化，就要强制转换，因为默认返回的是Object</span></span><br><span class="line">Student student = (Student) stuClass.newInstance();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//根据名称获取，不问权限，只能获取本类</span></span><br><span class="line">    Field fieldStuNum = stuClass.getDeclaredField(<span class="string">"stuNum"</span>);</span><br><span class="line">    <span class="comment">//获得访问权限，即使是私有变量</span></span><br><span class="line">    fieldStuNum.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//修改值，前面一个参数是引用对象，后面是值</span></span><br><span class="line">    fieldStuNum.set(student, <span class="number">6666</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  修改final常量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能是这两种方式初始化的final常量才可以修改，直接初始化的可以修改，但调用的时候还是没有被修改，所以没有意义</span></span><br><span class="line"><span class="comment">//声明一个变量，在构造器中初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String FINAL;</span><br><span class="line"><span class="comment">//或者利用三目表达式初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String FINAL = <span class="keyword">null</span> == <span class="keyword">null</span> ? <span class="string">"FINAL"</span> : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取私有常量</span></span><br><span class="line">Field fieldFinal = stuClass.getDeclaredField(<span class="string">"FINAL"</span>);</span><br><span class="line">fieldFinal.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">fieldFinal.set(student1, <span class="string">"change final"</span>);</span><br></pre></td></tr></table></figure><p>  <a href="https://user-gold-cdn.xitu.io/2017/8/12/7a376b8628ac1343bba0715b211a531b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2017/8/12/7a376b8628ac1343bba0715b211a531b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="别人博客中的图片"></a>别人博客中的图片</p></li><li><p>获取类加载器<br>  <code>stuClass.getClassLoader()</code></p></li><li><p>操作数组</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String[] strArray = <span class="keyword">new</span> String[]&#123;<span class="string">"5"</span>,<span class="string">"7"</span>,<span class="string">"暑期"</span>,<span class="string">"美女"</span>,<span class="string">"女生"</span>,<span class="string">"女神"</span>&#125;;</span><br><span class="line">Array.set(strArray,<span class="number">0</span>,<span class="string">"帅哥"</span>);</span><br><span class="line">Class clazz = strArray.getClass();</span><br><span class="line"><span class="keyword">if</span> (clazz.isArray()) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(strArray);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        Object object = Array.get(strArray, i);</span><br><span class="line">        String className=object.getClass().getName();</span><br><span class="line">        System.out.println(<span class="string">"----&gt; object="</span> + object+<span class="string">",className="</span>+className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得泛型类型</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method =TestHelper.class.getDeclaredMethod(<span class="string">"getGenericHelper"</span>,HashMap.class);</span><br><span class="line">    Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    <span class="comment">// 检验是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == genericParameterTypes || genericParameterTypes.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取 getGenericHelper 方法的第一个参数</span></span><br><span class="line">    ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[<span class="number">0</span>];</span><br><span class="line">    Type rawType = parameterizedType.getRawType();</span><br><span class="line">    System.out.println(<span class="string">"----&gt; rawType="</span> + rawType);</span><br><span class="line">    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">    <span class="keyword">if</span> (actualTypeArguments==genericParameterTypes || actualTypeArguments.length&lt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  打印出每一个类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; actualTypeArguments.length; i++) &#123;</span><br><span class="line">        Type type = actualTypeArguments[i];</span><br><span class="line">        System.out.println(<span class="string">"----&gt; type="</span> + type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例子</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String content)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">personPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentFunI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"StudentFunI"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(String book)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">study</span><span class="params">(String className)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">StudentFunI</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stuNum;</span><br><span class="line">    <span class="keyword">private</span> String book;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> stuNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.stuNum = stuNum;</span><br><span class="line">        <span class="keyword">this</span>.book = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"默认构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.getName() + <span class="string">" speak "</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.book = book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">study</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span> + <span class="keyword">super</span>.getName() + <span class="string">"stuNum:"</span> + stuNum + <span class="string">"\tclassName:"</span> + className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"  stuNum:"</span> + stuNum + <span class="string">"  book:"</span> + book + <span class="string">"  FINAL: "</span> + FINAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">studentPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//必须使用全限定名（含包名），获取Class对象引用的一种方式，</span></span><br><span class="line">        <span class="comment">//如果Student类没有被加载，调用它会触发Student类的static子句（静态初始化块）类构造器的初始化</span></span><br><span class="line">        Class stuClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stuClass = Class.forName(<span class="string">"reflection.Student"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过字面常量获取（类名）。不会触发类构造器的初始化</span></span><br><span class="line">        Class stuClass1 = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过实例化后，获取Class</span></span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"new student"</span>, <span class="number">1234</span>);</span><br><span class="line">        Class stuClass2 = student.getClass();</span><br><span class="line">        <span class="comment">//泛化的class引用，</span></span><br><span class="line">        Class&lt;Integer&gt; intClass = <span class="keyword">int</span>.class;</span><br><span class="line"></span><br><span class="line">        example(stuClass);</span><br><span class="line">        newStudent(stuClass);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取实例</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> stuClass</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newStudent</span><span class="params">(Class stuClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取构造器，构造实例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取所有的构造器</span></span><br><span class="line">            Constructor[] constructors = stuClass.getConstructors();</span><br><span class="line">            <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">                System.out.println(<span class="string">"构造方法"</span>+constructor);</span><br><span class="line">            &#125;</span><br><span class="line">            Constructor constructor = stuClass.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">            Object stuConstructor = constructor.newInstance(<span class="string">"constructor student"</span>, <span class="number">2345</span>);</span><br><span class="line">            System.out.println(stuConstructor.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//通过newInstance获取实例，默认构造器</span></span><br><span class="line">        Student student1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//类型转换，方便后面调用</span></span><br><span class="line">            student1 = (Student) stuClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(student1 != <span class="keyword">null</span> ? student1.study(<span class="string">"Java"</span>) : <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(student1.toString());</span><br><span class="line">        <span class="comment">//修改私有变量</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field fieldStuNum = stuClass.getDeclaredField(<span class="string">"stuNum"</span>);</span><br><span class="line">            fieldStuNum.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            fieldStuNum.set(student1, <span class="number">6666</span>);</span><br><span class="line">            Field fieldBook  = stuClass.getDeclaredField(<span class="string">"book"</span>);;</span><br><span class="line">            fieldBook.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            fieldBook.set(student1, <span class="string">"修改book"</span>);</span><br><span class="line">            Field fieldFinal = stuClass.getDeclaredField(<span class="string">"FINAL"</span>);</span><br><span class="line">            fieldFinal.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            fieldFinal.set(student1, <span class="string">"change final"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"修改后"</span>);</span><br><span class="line">        System.out.println(student1.toString());</span><br><span class="line">        <span class="comment">//调用私有方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method methodStudy = stuClass.getDeclaredMethod(<span class="string">"study"</span>, String.class);</span><br><span class="line">            methodStudy.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            System.out.println(methodStudy.invoke(student1, <span class="string">"通过class访问方法"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * class应用示例</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> stuClass</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">(Class stuClass)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getName:"</span> + stuClass.getName());</span><br><span class="line">        System.out.println(<span class="string">"getSimpleName:"</span> + stuClass.getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">"getCanonicalName:"</span> + stuClass.getCanonicalName());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取public成员变量，所有的（包括父类，接口)</span></span><br><span class="line">        Field[] fields = stuClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">"包括父类 field: "</span> + field.getName() + <span class="string">"\t"</span> + field.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只获取Student类的成员变量，不问访问权限</span></span><br><span class="line">        Field[] fields1 = stuClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"field: "</span> + field.getName() + <span class="string">"\t"</span> + field.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取指定public成员变量</span></span><br><span class="line">            Field field = stuClass.getField(<span class="string">"age"</span>);</span><br><span class="line">            <span class="comment">//根据字段只获取Student类的，不问权限</span></span><br><span class="line">            Field field1 = stuClass.getDeclaredField(<span class="string">"stuNum"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取方法，包括父类（Object也是）的</span></span><br><span class="line">        Method[] methods = stuClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">"包括父类 method: "</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只获取Student的方法</span></span><br><span class="line">        Method[] methods1 = stuClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods1) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method: "</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定方法</span></span><br><span class="line">        Method method = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = stuClass.getMethod(<span class="string">"toString"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(method != <span class="keyword">null</span> ? method.getName() : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//获取指定的方法，不包括父类</span></span><br><span class="line"><span class="comment">//        Method method1 = stuClass.getDeclaredMethod("toString");</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取接口</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = stuClass.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">            Class&lt;?&gt; inter = interfaces[i];</span><br><span class="line">            Method[] methods2 = inter.getMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method1 : methods2) &#123;</span><br><span class="line">                System.out.println(inter.getName() + <span class="string">"接口中的方法"</span> + method1.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取父类</span></span><br><span class="line">        Class&lt;?&gt; parent = stuClass.getSuperclass();</span><br><span class="line">        Method[] parentMethods = parent.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method1 : parentMethods) &#123;</span><br><span class="line">            System.out.println(parent + <span class="string">"父类  方法"</span> + method1.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类加载器</span></span><br><span class="line">        System.out.println(<span class="string">"类加载器 "</span> + stuClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  结果：</p><blockquote><p>getName:reflection.Student<br>getSimpleName:Student<br>getCanonicalName:reflection.Student</p><p>包括父类 field: TAG class java.lang.String<br>包括父类 field: age int<br>field: FINAL class java.lang.String<br>field: stuNum int<br>field: book class java.lang.String</p><p>包括父类 method: toString<br>包括父类 method: read<br>包括父类 method: study<br>包括父类 method: getName<br>包括父类 method: wait<br>包括父类 method: wait<br>包括父类 method: wait<br>包括父类 method: equals<br>包括父类 method: hashCode<br>包括父类 method: getClass<br>包括父类 method: notify<br>包括父类 method: notifyAll<br>method: toString<br>method: read<br>method: study<br>method: studentPrivate<br>method: speak<br>toString</p><p>reflection.StudentFunI接口中的方法read<br>reflection.StudentFunI接口中的方法study<br>class reflection.Person父类 方法toString<br>class reflection.Person父类 方法getName<br>class reflection.Person父类 方法personPrivate<br>class reflection.Person父类 方法speak<br>类加载器 sun.misc.Launcher$AppClassLoader@18b4aac2<br>构造方法public reflection.Student(java.lang.String,int)<br>构造方法public reflection.Student()<br>constructor student stuNum:2345 book:null FINAL: final tag</p><p>name:默认构造stuNum:0 className:Java<br>默认构造 stuNum:0 book:null FINAL: final tag<br>修改后<br>默认构造 stuNum:6666 book:修改book FINAL: change final<br>name:默认构造stuNum:6666 className:通过class访问方法</p></blockquote></li></ul><h3 id="缺陷与作用"><a href="#缺陷与作用" class="headerlink" title="缺陷与作用"></a>缺陷与作用</h3><ul><li>反射的性能<br>  反射机制给予Java开发很大的灵活性，但反射机制本身也有缺点，代表性的缺陷就是反射的性能，一般来说，通过反射调用方法的效率比直接调用的效率要至少慢一倍以上。</li><li>作用<br>  反射的一个很重要的作用，就是在设计模式中的应用，包括在工厂模式和代理模式中的应用</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解：也称为元数据，为我们在代码中添加信息提供了一种形式化的方法，注解在一定程度上是在把元数据与源代码文件结合在一起。</p><ul><li>作用：<ol><li>能够以编译器来测试和验证的的格式，存储有关程序的额外信息</li><li>用来生成描述符文件，或新的类定义</li><li>有助于减轻编写“样板”代码的负担</li><li>将元数据保存在Java源代码中，利用annotation API为自己的注解构造处理工具</li></ol></li></ul><h3 id="三种标准注解"><a href="#三种标准注解" class="headerlink" title="三种标准注解"></a>三种标准注解</h3><ul><li>@Override<br>  表示当前的方法定义将覆盖超类中的方法，仅保留在Java源文件中</li><li>@Desperated<br>  用于告知编辑器，某以程序元素（方法、成员变量）不建议使用（过时了），如果程序员使用了注解为它的元素，编译器会发出警告</li><li>@Suppress Warnings<br>  关闭不当的编译器警告信息<table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">deprecation</td><td align="center">使用了过时的类或方法时的警告</td></tr><tr><td align="center">unchecked</td><td align="center">执行了未检查的转换时的警告</td></tr><tr><td align="center">fallthrough</td><td align="center">当switch程序块进入下一个case而没有break的警告</td></tr><tr><td align="center">path</td><td align="center">在类路径、源文件路径等有不存在路径时的警告</td></tr><tr><td align="center">serial</td><td align="center">当可序列化的类缺少serialVersionUID定义时的警告</td></tr><tr><td align="center">finall</td><td align="center">任意finally子句不能正常完成时的警告</td></tr><tr><td align="center">all</td><td align="center">以上所有情况的警告</td></tr></tbody></table></li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul><li><p>@Target<br>  表示该注解用于什么地方</p><table><thead><tr><th align="center">参数类型</th><th align="center">参数说明</th></tr></thead><tbody><tr><td align="center">CONSTRUCTOP</td><td align="center">构造器的声明</td></tr><tr><td align="center">FIEFLE</td><td align="center">域声明（包括enum实例）</td></tr><tr><td align="center">LOCAL_VARIABLE</td><td align="center">局部变量声明</td></tr><tr><td align="center">METHOD</td><td align="center">方法声明</td></tr><tr><td align="center">PACKAEGE</td><td align="center">包声明</td></tr><tr><td align="center">PARAMETER</td><td align="center">参数声明</td></tr><tr><td align="center">TYPE</td><td align="center">类、接口或enum声明</td></tr><tr><td align="center">TYPE_PARAMETER</td><td align="center">注解可以用于类型参数声明（1.8新加入）</td></tr><tr><td align="center">TYPE_USE</td><td align="center">类型使用声明（1.8新加入)</td></tr></tbody></table></li><li><p>@Retention<br>  表示需要在什么级别保存该注解信息</p><table><thead><tr><th align="center">参数类型</th><th align="center">参数说明</th></tr></thead><tbody><tr><td align="center">SOURCE</td><td align="center">注解将被编译器丢弃，仅在java源文件</td></tr><tr><td align="center">CLASS</td><td align="center">注解在class文件中可用，但会被VM丢弃</td></tr><tr><td align="center">RUNTIME</td><td align="center">VM在运行期也保留注解，因此可以通过反射机制获取信息</td></tr></tbody></table></li><li><p>@Documented<br>  将注解包含在javadoc中</p></li><li><p>@Inherited<br>  允许子类继承父类中的注解</p></li><li><p>@Repeatable<br>  1.8新加入，表示同一个位置重复相同的注解</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8前无法这样使用</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>当一个接口直接继承java.lang.annotation.Annotation接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过@interface关键字的方式，其实通过该方式会隐含地继承.Annotation接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//使用了默认值，如果没有给出description值，就会使用这个默认值</span></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="comment">//嵌套注解，注解可以作为元素</span></span><br><span class="line">    <span class="function">UseCase <span class="title">usecase</span><span class="params">()</span> <span class="keyword">default</span> @<span class="title">UseCase</span><span class="params">(id = <span class="number">-1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswdUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用</span></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">47</span>, description = <span class="string">"至少包含一个数字"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePasswd</span><span class="params">(String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passwd.matches(<span class="string">"\\w*\\d\\w*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPasswd</span><span class="params">(String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(passwd).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">49</span>, description = <span class="string">"新密码不能跟旧密码相同"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkForNewPasswd</span><span class="params">(List&lt;String&gt; prevPasswd, String passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !prevPasswd.contains(passwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试，通过查找@UseCase标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCaseTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCase</span><span class="params">(List&lt;Integer&gt; useCase, Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取cl的所有方法，不问权限</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="comment">//获取方法的注解，此处获取指定的UseCase标记</span></span><br><span class="line">            UseCase uc = method.getAnnotation(UseCase.class);</span><br><span class="line">            <span class="keyword">if</span> (uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Found UseCase:"</span> + uc.id() + <span class="string">" "</span> + uc.description());</span><br><span class="line">                <span class="comment">//移除已经找到的id</span></span><br><span class="line">                useCase.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : useCase) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Warning Missing UseCase"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; useCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//提供一组id值</span></span><br><span class="line">        Collections.addAll(useCases, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>);</span><br><span class="line">        trackUseCase(useCases, PasswdUtils.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Found UseCase:48 no description<br>Found UseCase:47 至少包含一个数字<br>Found UseCase:49 新密码不能跟旧密码相同<br>Warning Missing UseCase50<br>Warning Missing UseCase51</p></blockquote><ul><li><p>注解元素<br>  注解元素可有的类型有如下：</p><ol><li>所有基本类型（int、float等）</li><li>String</li><li>enum</li><li>Annotation</li><li>以上类型的数组<br> 除此外，不可用其他类型注解元素。注解也可以作为元素的类型（注解可以嵌套）<br> 例如上述UseCase.java中，包含int元素id，String元素description</li></ol></li><li><p>默认值<br>  元素不能有不确定的值，要么有默认值，要么在使用注解时提供元素的值<br>  默认值不能用null</p></li><li><p>快捷方式<br>  在注解中定义了value的元素，且该元素是唯一要赋值的一个元素，就可以不用采用名-值对的语法<br>  例如</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在使用时就不用<code>@UseCase(value = 47)</code>，可以直接使用<code>@UseCase(47)</code></p></li><li><p>注解不支持继承</p></li><li><p>使用apt处理注解<br>  注解处理工具apt，与javadoc一样被设计为操作Java源文件，而不是编译后的类。</p></li></ul><h3 id="1-8后的一些改进"><a href="#1-8后的一些改进" class="headerlink" title="1.8后的一些改进"></a>1.8后的一些改进</h3><ul><li><p>@Target<br>  新增两个参数</p></li><li><p>重复注解</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8前无法这样使用</span></span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/update"</span>)</span><br><span class="line"><span class="meta">@FilterPath</span>(<span class="string">"/web/add"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型注解</p><ol><li>创建类实例<code>new @Interned MyObject();</code></li><li>类型映射<code>myString = (@NonNull String) str;</code></li><li>implements语句中<code>class UnmodifiableList&lt;T&gt; implements @Readonly List&lt;@Readonly T&gt; { ... }</code></li><li>throw execption声明<code>void monitorTemperature() throws @Critical TemperatureException { ... }</code></li></ol></li></ul><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li><p>说说你对Java反射的理解<br> 在运行时需要一些类的信息，可以通过反射来动态获取并且修改，通过反射可以做很多事情，重点还是获取Class对象，然后就可以获取实例、访问方法、修改变量等等</p></li><li><p>说说你对依赖注入的理解<br> 依赖注入是实现程序解耦的一种方式，降低依赖，按需绑定</p><p> 设置注入：设置注入是通过setter方法注入被调用者的实例。<br> 构造注入：利用构造方法来设置依赖注入的方式称为构造注入。</p></li><li><p>java注解<br> 用于标记，比javadoc更好一点的东西</p></li><li><p>简单说说 Java 反射各种获取 Field 方法的区别<br> getFields()：获取public成员变量，所有的（包括父类，接口)<br> getDeclaredFields()：只获取本类的成员变量，不问访问权限<br> getField(String name)：获取指定public成员变量<br> getDeclaredField(String name)：获取指定的本类中的成员变量，不问权限</p></li><li><p>简单说说 Java 反射各种获取 Method 方法的区别<br> getMethods()：获取所有的方法，包括父类（Object也是）的，public的方法<br> getDeclaredMethods()：只获取本类的方法，不问权限<br> getMethod(String name, Class&lt;?&gt;… parameterTypes)：public的，参数方法名，参数类型 getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)：不管权限，不包括父类的方法，方法名、参数类型</p></li><li><p>简单说说 Java 反射各种获取类 Constructor 的方法区别<br> getConstructors()：获取所有的构造器<br> getDeclaredConstructors()：获取本类的所有构造器，不问权限<br> getConstructor(Class<?>… parameterTypes)：获取对应的构造器，传入构造器的参数类型 getDeclaredConstructor(Class<?>… parameterTypes)：获取指定的构造器，本类，不管权限</p></li><li><p>如何防止反射、序列化攻击单例？<br> 修改构造器，加锁，让单例在被要求创建第二个实例化的时候抛出异常<br> 利用枚举类型，编写一个包含单个元素的枚举类型</p><p> 针对序列化：实现Serializable，重写readResolve方法</p><p> 针对该clone：实现Cloneable接口，重写克隆方法</p></li><li><p>简单说说 Java Class.newInstance() 与Constructor.newInstance() 方法区别<br> Class.newInstance() 只能够调用无参的构造函数，即默认的构造函数；<br> Constructor.newInstance() 可以根据传入的参数，调用任意构造构造函数。</p><p> Class.newInstance() 抛出所有由被调用构造函数抛出的异常。</p><p> Class.newInstance() 要求被调用的构造函数是可见的，也即必须是public类型的;<br> Constructor.newInstance() 在特定的情况下，可以调用私有的构造函数。</p></li></ol><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p>Java 编程思想<br><a href="https://juejin.im/post/598ea9116fb9a03c335a99a4" target="_blank" rel="noopener">Java 反射由浅入深 | 进阶必备</a><br><a href="https://www.cnblogs.com/rollenholt/archive/2011/09/02/2163758.html" target="_blank" rel="noopener">java反射详解</a><br><a href="https://blog.csdn.net/gdutxiaoxu/article/details/68947735" target="_blank" rel="noopener">Java 反射机制详解</a><br><a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">深入理解Java注解类型(@Annotation)</a><br><a href="https://www.jianshu.com/p/4068da3c8d3d" target="_blank" rel="noopener">Java注解深入理解</a><br><a href="http://www.hollischuang.com/archives/1144" target="_blank" rel="noopener">单例与序列化的那些事儿</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类</title>
      <link href="/2020/02/07/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/02/07/Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类是定义在另一个类中的类。</p><p><strong>内部类的好处</strong>：</p><ol><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据</li><li>内部类可以对同一个包中的其他类隐藏起来</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷</li></ol><p>先来个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">protected</span> String mAge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerDemo</span><span class="params">(String name, String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mName = name;</span><br><span class="line">        <span class="keyword">this</span>.mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getmName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getmAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        InnerClass() &#123;</span><br><span class="line">            mName = <span class="string">"内部访问外部name"</span>;</span><br><span class="line">            mAge = <span class="string">"内部访问外部age"</span>;</span><br><span class="line">            name = mName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/25.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutClass outClass = <span class="keyword">new</span> OutClass(<span class="string">"外部name"</span>, <span class="string">"外部age"</span>);</span><br><span class="line">        System.out.println(outClass.getmName()+<span class="string">"\t"</span>+outClass.getmAge());</span><br><span class="line">        <span class="comment">//一种获取内部类的方法</span></span><br><span class="line">        OutClass.InnerClass innerClass = outClass.new InnerClass();</span><br><span class="line">        System.out.println(outClass.getmName()+<span class="string">"\t"</span>+outClass.getmAge());</span><br><span class="line">        System.out.println(innerClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果：</span></span><br><span class="line"><span class="comment"> * 外部name外部age  </span></span><br><span class="line"><span class="comment"> * 内部访问外部name内部访问外部age  </span></span><br><span class="line"><span class="comment"> * 内部访问外部name  </span></span><br><span class="line"><span class="comment"> * Process finished with exit code 0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这就是一个简单的内部类，简单来说，就是在一个类的内部再定义一个类。可以看到，内部类可以毫无顾忌的访问外部类的成员变量，不管外部的成员变量修饰的权限是什么。</p><p>上面的例子，程序在编译后生成的是两个Class文件，一个OutClass.Class，一个OutClass$InnerClass.Class。</p><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">protected</span> String mAge;</span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (innerClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> innerClass;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/25.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutClass outClass = <span class="keyword">new</span> OutClass(<span class="string">"外部name"</span>, <span class="string">"外部age"</span>);</span><br><span class="line">        <span class="comment">//获取内部类</span></span><br><span class="line">        OutClass.InnerClass innerClass0 = outClass.getInnerClass();</span><br><span class="line">        System.out.println(outClass.getmName()+<span class="string">"\t"</span>+outClass.getmAge());</span><br><span class="line">        <span class="comment">//另一种获取内部类的方法</span></span><br><span class="line">        OutClass.InnerClass innerClass = outClass.new InnerClass();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码注释中给出两种获取内部类的方法，一般建议写成外部类的公有方法。</p><ul><li>注意<br>  成员内部类中不能存在任何static变量和方法（若要，就是静态类）<br>  成员内部类依附于外部类，必须先有外部类才能创建内部类</li></ul><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>有这样一种内部类，它是嵌套在方法和作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。</p><ul><li>定义在方法内</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destionation <span class="title">destionation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestionation</span> <span class="keyword">implements</span> <span class="title">Destionation</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestionation</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestionation(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel5 parcel5 = <span class="keyword">new</span> Parcel5();</span><br><span class="line">        Destionation d = parcel5.destionation(<span class="string">"chenssy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义在作用域类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">"chenssy"</span>);</span><br><span class="line">            String string = ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;</span><br><span class="line">        internalTracking(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel6 parcel6 = <span class="keyword">new</span> Parcel6();</span><br><span class="line">        parcel6.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意<br>  局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的</li></ul><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护</p><p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意<ol><li>匿名内部类没有访问修饰符</li><li>new 匿名内部类，这个类首先是要存在的</li><li>当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final</li><li>匿名内部类没有构造方法</li></ol></li></ul><h2 id="静态内部类（嵌套内部类）"><a href="#静态内部类（嵌套内部类）" class="headerlink" title="静态内部类（嵌套内部类）"></a>静态内部类（嵌套内部类）</h2><p>有时候，使用内部类只是为了把一个类隐藏在另一个类的内部，并不需要内部类引用外围类对象。因此可以将内部类声明为static。静态内部类可以有静态域和方法；但是它的创建是不需要依赖于外部类，也不能使用任何外部类的非static成员变量和方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 14512 on 2018/7/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">protected</span> String mAge;</span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String staticName;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String staticStr = <span class="string">"静态内部类静态常量"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getStaticName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//staticName = mName;  //错误，无法访问外部类的成员变量</span></span><br><span class="line">            <span class="comment">//staticName = getName();  //错误，无法访问外部类的方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"静态内部类属性"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutClass outClass = <span class="keyword">new</span> OutClass(<span class="string">"外部name"</span>, <span class="string">"外部age"</span>);</span><br><span class="line">        System.out.println(outClass.getmName()+<span class="string">"\t"</span>+outClass.getmAge());</span><br><span class="line">        <span class="comment">//一种获取非静态内部类的方法</span></span><br><span class="line">        OutClass.InnerClass innerClass = outClass.new InnerClass();</span><br><span class="line">        System.out.println(outClass.getmName()+<span class="string">"\t"</span>+outClass.getmAge());</span><br><span class="line">        System.out.println(innerClass.getName());</span><br><span class="line">        <span class="comment">//静态内部类的获取，实例化</span></span><br><span class="line">        OutClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OutClass.StaticInnerClass();</span><br><span class="line">        System.out.println(staticInnerClass.getStaticName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 外部name外部age</span></span><br><span class="line"><span class="comment"> * 内部访问外部name内部访问外部age</span></span><br><span class="line"><span class="comment"> * 内部访问外部name</span></span><br><span class="line"><span class="comment"> * 静态内部类属性</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息</p><p>例如：一个接口程序员和一个基类作家都有一个相同的方法work，相同的方法名，但是其含义完全不同，这时候就需要闭包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> </span>&#123;<span class="comment">//作家基类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">programmer</span></span>&#123;<span class="comment">//程序员接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterProgrammer</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//写作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//写代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ProgrammerInner</span> <span class="keyword">implements</span> <span class="title">programmer</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">            code();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.jianshu.com/p/367b138fe909" target="_blank" rel="noopener">java内部类与内部类的闭包和回调</a></p><h2 id="内部类相关面试题"><a href="#内部类相关面试题" class="headerlink" title="内部类相关面试题"></a>内部类相关面试题</h2><ol><li>Java中Class类是用来干嘛的<br> class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class,类型.getClass(),Class.forName(“类名”)等方法获取class对象）。数组同样也被映射为为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。</li></ol><ul><li><p>内部类</p><ol><li><p>开发中使用 Java 匿名内部类有哪些注意事项（经验）<br> （1）使用匿名内部类时必须是继承一个类或实现一个接口（二者不可兼得且只能继承一个类或者实现一个接口）。</p><p> （2）匿名内部类中是不能定义构造函数的，如需初始化可以通过构造代码块处理。</p><p> （3）匿名内部类中不能存在任何的静态成员变量和静态方法。</p><p> （4）匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</p><p> （5）匿名内部类不能是抽象类，必须要实现继承的类或者实现接口的所有抽象方法</p></li><li><p>非静态内部类里面为什么不能有静态属性和静态方法？<br> 非静态内部类要依赖于外部类，必须先创建了外部类引用才会有非静态内部类。但是静态属性和静态方法（也就是static修饰）是在类加载时就开始存于内存，且是单独的一块存储空间，而此时类加载还未完成；如果这时调用了静态属性或静态方法，但是外部类并没有实例化，内部类也没加载，却试图调用内部类的静态成员和方法，就矛盾了。</p></li><li><p>什么是内部类？内部类的作用<br> 内部类是定义在另一个类中的类。</p><p> 内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据<br> 内部类可以对同一个包中的其他类隐藏起来<br> 当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷<br> 可以避免修改接口而实现同一个类中两种同名方法的调用</p></li><li><p>内部类和静态内部类和匿名内部类，以及项目中的应用<br> 内部类就是定义在类中的类<br> 用static修饰的内部类就叫静态内部类<br> 没有构造器，没有名字的内部类就叫匿名内部类（view的点击事件）</p></li><li><p>成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用<br> 将一个内部类当作外部类的成员变量，看作一个属性使用，就叫成员内部类<br> static修饰的内部类就叫静态内部类<br> 内部类作用于某一个方法或某一个作用于的时候，就叫局部内部类<br> 没有名字的内部类叫匿名内部类</p></li><li><p>静态内部类的设计意图。<br> 为了把一个类隐藏在另一个类的内部，并不需要内部类引用外围类对象</p></li><li><p>Static class 与non static class的区别<br> 静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态内部类类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。静态内部类可以独立于外部类</p></li><li><p>闭包和局部内部类的区别<br> 利用内部类实现闭包，局部内部类就是一个闭包结构</p></li><li><p>Java 匿名内部类为什么不能直接使用构造方法，匿名内部类有没有构造方法？<br> 匿名内部类没有构造方法（没有名字），而且每次创建的匿名内部类同时被实例化后只能使用一次，所以就无法创建一个同名的构造方法，但是可以直接调用父类的构造方法。<br> 从JVM来说，匿名内部类是有构造方法的，是通过编译器在编译时生成的</p></li><li><p>Java 中为什么成员内部类可以直接访问外部类的成员？<br>编译后，成员内部类有一个指向外部类对象的引用，且成员内部类编译后构造方法有一个指向外部类对象的引用参数</p></li><li><p>Java 1.8 之前为什么方法内部类和匿名内部类访问局部变量和形参时必须加 final？<br>在这之前，普通局部变量或者形参的作用域是方法内，方法结束，局部变量和形参都会消失，而其匿名内部类或方法内的内部类的声明周期还没有结束（其他地方仍有引用），匿名内部类或者方法内部类如果想继续使用方法的局部变量就需要一些手段，所以 Java 在编译匿名内部类或者方法内部类时就有一个规定来解决生命周期问题，即如果访问的外部类方法的局部变量值在编译期能确定则直接在匿名内部类或者方法内部类里面创建一个常量拷贝，如果访问的外部类方法的局部变量值无法在编译期确定则通过构造器传参的方式来对拷贝进行初始化赋值。由此说明在匿名内部类或者方法内部类中访问的外部类方法的局部变量或者形参是内部类自己的一份拷贝，和外部类方法的局部变量或者形参不是一份，所以如果在匿名内部类或者方法内部类对变量做修改操作就一定会导致数据不一致性（外部类方法的参数不会跟着被修改，引用类型仅是引用，值修改不存在问题），为了杜绝数据不一致性导致的问题 Java 就要求使用 final 来保证，所以必须是 final 的。在 Java 1.8 开始我们可以不加 final 修饰符了，系统会默认添加，Java 将这个功能称为 Effectively final。</p></li><li><p>为什么Java里的匿名内部类只能访问final修饰的外部变量？<br>匿名内部类和外部方法形成了一个闭包，因此匿名内部类能够访问外部方法的变量。但是匿名内部类的生命周期可能比外部的类要长，所以都会修改数据，容易导致数据不一致，所以Java就强制要求为final</p></li></ol></li></ul><p>部分参考<a href="http://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">Java内部类详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java三大特性、抽象类以及接口相关</title>
      <link href="/2020/02/07/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BB%A5%E5%8F%8A%E6%8E%A5%E5%8F%A3%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/02/07/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BB%A5%E5%8F%8A%E6%8E%A5%E5%8F%A3%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Java三大特性、抽象类以及接口相关"><a href="#Java三大特性、抽象类以及接口相关" class="headerlink" title="Java三大特性、抽象类以及接口相关"></a>Java三大特性、抽象类以及接口相关</h1><p><strong>声明</strong>：部分面试题来自微信公众号<strong>码农每日一题</strong></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>概念：对象属性的封装隐藏，方法的公开；属性私有化后，则其他类不能直接使用对象名.属性名访问，必须通过提供的公开方法。控制在程序中属性的读和修改的访问级别。</p><p>目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。</p><p>基本要求：把所有的属性私有化，对每个属性提供getter和setter方法</p><p>一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装之前</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDemo</span><span class="params">(String name, String address, String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TestDemo() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用是这样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestDemo testDemo = <span class="keyword">new</span> TestDemo();</span><br><span class="line">        String name = testDemo.name;</span><br><span class="line">        String address = testDemo.address;</span><br><span class="line">        String age = testDemo.age;</span><br><span class="line">        testDemo.name = <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String age;  <span class="comment">//构造私有属性，并且不对外公开获取，只能从构造函数设置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDemo</span><span class="params">(String name, String address, String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TestDemo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用是这样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestDemo testDemo = <span class="keyword">new</span> TestDemo();</span><br><span class="line">        TestDemo testDemo1 = <span class="keyword">new</span> TestDemo(<span class="string">"Hello"</span>, <span class="string">"world"</span>， <span class="string">"man"</span>);</span><br><span class="line"></span><br><span class="line">        String name = testDemo1.getName();</span><br><span class="line">        String address = testDemo1.getAddress();</span><br><span class="line">        <span class="comment">//String age = testDemo1.getAge();  //无法获取age</span></span><br><span class="line">        testDemo1.setName(<span class="string">"world"</span>);  <span class="comment">//调用公开方法进行属性的修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>实现代码的复用，可以基于已经存在的类构造一个新类，继承已存在的类就是复用这个类的方法和域，在此基础上还可以添加一些新的方法和域，一个类只能继承一个类</p><p><strong>缺点</strong>：</p><ol><li>父类变，子类就必须变。</li><li>继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。</li><li>继承是一种强耦合关系。</li></ol><p>访问修饰符：</p><ol><li>private：仅对本类可见</li><li>protected：对本包和所有子类可见</li><li>public：对所有类可见</li><li>默认（无修饰）：对本包可见</li></ol><p>继承和权限：<br>| | | | | | | | |<br>|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|<br>| | Public | 无修饰 | Private | Protected | final | abstract | static |<br>| 类继承 | 可继承 | 同一包中的可继承 | 不能修饰类 | 不能修饰类 | 不能派生子类（不可继承） | 一般可继承 | 不能修饰类 |<br>| 方法重载 | 可重载 | 可重载 | 不能重载 | 可重载 | 不可重载 | 可重载 | 可重载（修饰主函数就不能重载） |<br>| 成员变量 | 父类属性被隐藏，使用调用super | 父类属性被隐藏，使用调用super | 子类不能直接访问父类的私有变量（通过父类构造器初始化父类私有变量） | 父类属性被隐藏，使用调用super | 必须赋初值 | 不能修饰成员变量 | 每个实例共享这个类变量 |</p><h3 id="类、超类、子类"><a href="#类、超类、子类" class="headerlink" title="类、超类、子类"></a>类、超类、子类</h3><p>引例：一家公司，有经理、普通员工等等，但是所有人都是老板的雇员，以此设计它们之间的关系<br>分析：不管是经理、普通员工都是雇员的一类，但是各种身份又有一些不同的属性、不同的功能</p><ul><li>定义父类（超类） Employee</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工资</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义子类 Manager</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 奖金信息，特有的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Manager的构造器不能访问父类的私有域，所以通过父类的构造器进行初始化</span></span><br><span class="line">        <span class="keyword">super</span>(name, salary);</span><br><span class="line">        bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写父类的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类的方法</span></span><br><span class="line">        <span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();</span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承关系：<a href="https://upload-images.jianshu.io/upload_images/4061843-1952b22e7fa34fe4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-1952b22e7fa34fe4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继承层次"></a>继承层次</p><p>强制类型转化：</p><ol><li>只能在继承层次内进行类型转换</li><li>在将超类转换成子类之前，应该使用instance检查</li></ol><h3 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h3><p>Object类是Java中所有类的始祖，如果一个类没有明确指出超类，那么默认超类是Object。</p><ul><li><p>euqals方法<br>  用于检测一个对象是否等于另一个对象，判断两个对象是都具有相同的引用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  一般equals和==是不一样的，但是在Object中两者是一样的</p></li><li><p>toString</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getClass 获得运行时类型<br>  <code>public final native Class&lt;?&gt; getClass();</code></p></li><li><p>hashCode<br>  <code>public native int hashCode();</code><br>  该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p><p>  一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p></li><li><p>notify 唤醒在该对象上等待的某个线程<br>  <code>public final native void notify();</code></p></li><li><p>notifyAll 唤醒在该对象上等待的所有线程<br>  <code>public final native void notifyAll();</code></p></li><li><p>wait(long timeout) 在规定时间内没有获得锁就返回<br>  <code>public final native void wait(long timeout) throws InterruptedException;</code></p></li><li><p>wait(long timeout, int nanos)<br>  在规定时间内没有获得锁就返回，有一个附加时间</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>wait() 一直等待，直到获得锁或者被中断</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>finalize 用于释放资源<br>  <code>protected void finalize() throws Throwable { }</code></p></li><li><p>clone<br>  <code>protected native Object clone() throws CloneNotSupportedException;</code><br>  实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法。主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。</p></li></ul><h3 id="抽象类、接口"><a href="#抽象类、接口" class="headerlink" title="抽象类、接口"></a>抽象类、接口</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>类也可以继承抽象类，抽象类可以继承类，也可以继承抽象类，可以实现接口。</p><ul><li><p>abstract<br>  使用abstract class 定义的类都是抽象类，可以含有、也可以不含有抽象方法<br>  还是上面的例子，不管是经理还是雇员，都是人，所以人可以定义为一个抽象类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类Person</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee继承Person</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"a employee"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义新的Student类继承Person</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String major;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String major)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMajor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"a student"</span> + major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意问题：</p><ol><li>抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。</li><li>抽象方法必须由子类来进行重写</li><li>只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法</li><li>抽象类中可以包含具体的方法，当然也可以不包含抽象方法</li><li>子类中的抽象方法不能与父类的抽象方法同名</li><li>abstract不能与final并列修饰同一个类</li><li>abstract 不能与private、static、final或native并列修饰同一个方法</li></ol></li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>类可以实现接口，抽象类也可以实现接口，但是接口只能实现接口。类、抽象类、接口都可以实现多个接口</p><ul><li><p>接口示例：<br>  Comparable接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk 1.5后使用泛型定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  使用 implements关键字</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        Employee other = (Employee) other;  <span class="comment">//使用泛型后不用强转了，比较的方式自定义</span></span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口的默认方法<br>  可以为接口提供一个默认实现，必须用default修饰符标记</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  默认方法可能导致冲突，例如现在一个接口中将方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法</p></li><li><p>接口的继承<br>  一个接口可以继承另一个接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Work</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Study</span> <span class="keyword">extends</span> <span class="title">Work</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Study的时候会重写两个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Study</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Study接口自己声明了一个方法，又继承了Work，所以实现Study接口的时候，一共有两个方法需要重写</p></li><li><p>接口与回调<br>  参考<a href="https://blog.csdn.net/xiaanming/article/details/8703708" target="_blank" rel="noopener">一个经典例子让你彻彻底底理解java回调机制</a></p></li><li><p>注意事项：</p><ol><li>一个Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！</li><li>接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name</li><li>接口中不存在实现的方法</li><li>实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现</li><li>不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。</li><li>在实现多接口的时候一定要避免方法名的重复</li></ol></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。</p><p>例子：利用抽象类的例子写一个测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Employee(<span class="string">"Employee"</span>, <span class="number">5000</span>);  <span class="comment">//向上转型为Person，person指向Employee</span></span><br><span class="line">        System.out.println(person.getDescription());  <span class="comment">//最终调用的是Employee重写的方法</span></span><br><span class="line"></span><br><span class="line">        Employee employee = (Employee) person;  <span class="comment">//向下转型，需要强制转换</span></span><br><span class="line">        System.out.println(employee.getDescription());  <span class="comment">//调用的是Employee重写的方法</span></span><br><span class="line"></span><br><span class="line">        person = <span class="keyword">new</span> Student(<span class="string">"Student"</span>, <span class="string">"java"</span>);  <span class="comment">//向上转型，将person重新指向一个新的Student</span></span><br><span class="line">        System.out.println(person.getDescription());  <span class="comment">//调用Student重写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 结果</span></span><br><span class="line"><span class="comment"> * a employee</span></span><br><span class="line"><span class="comment"> * a employee</span></span><br><span class="line"><span class="comment"> * a studentjava</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure><p>Employee是Person的子类， Person person = new Employee(“Employee”, 5000) 编译时变量和运行时变量不一样，所以多态发生了。</p><blockquote><p>（1）Person person作为一个引用类型数据，存储在JVM栈的本地变量表中。<br>（2）new Employee(“Employee”, 5000)作为实例对象数据存储在堆内存中<br>Employee的对象实例数据（接口、方法、field、对象类型等）的地址也存储在堆中<br>Employee的对象的类型数据（对象实例数据的地址所执行的数据）存储在方法区中，方法区中对象类型数据中有一个指向该类方法的方法表。</p><p>（3）Java虚拟机规范中并未对引用类型访问具体对象的方式做规定，目前主流的实现方式主要有两种：<br>１. 通过句柄访问<br>在这种方式中，JVM堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。<br>２.通过直接指针访问<br>通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。</p><p>（4）实现过程<br>首先虚拟机通过reference类型（Person的引用）查询java栈中的本地变量表，得到堆中的 对象类型数据的地址，从而找到方法区中的对象类型数据（Employee的对象类型数据），然后查询方法表定位到实际类（Employee类）的方法运行。</p></blockquote><h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ol><li>继承<br> 如例子中的Employee是Person的子类</li><li>重写<br> Employee重写了Person的getDescription方法</li><li>父类引用指向子类对象<br> Person person = new Employee(“Employee”, 5000);</li></ol><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ol><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ol><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>多态性分为编译时的多态性和运行时的多态性。</p><blockquote><ol><li>运行时的多态性<br> 方法重写（override）实现的是运行时的多态性（也称为后绑定），运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li><li>编译时的多态<br> 方法重载（overload）实现的是编译时的多态性（也称为前绑定）。</li></ol></blockquote><ul><li><p>方法调用绑定<br>  将一个方法主体关联起来被称作绑定<br>  （1）前期绑定（静态绑定）：在程序执行之前进行绑定（默认的绑定方式）<br>  （2）后期绑定（动态绑定或运行时绑定）：在运行时根据对象的类型进行绑定</p><p>  Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定</p></li><li><p>方法的型构：指方法的组成结构，具体包括方法的名称和参数，涵盖参数的数量、类型以及出现的顺序，但是不包括方法的返回值类型，访问权限修饰符，以及 abstract、static、final 等修饰符。</p><ol><li><p>相同型构</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">(String s)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同型构</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i, String s)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s, <span class="keyword">int</span> i)</span> []</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>重载<br>  指在同一个类中定义了一个以上具有相同名称，但是型构不同的方法。</p></li><li><p>重写<br>  指在继承情况下，子类中定义了与其父类中方法具有相同型构的新方法，就称为子类把父类的方法重写了（子类必须重写父类为抽象类的方法）。这是实现多态必须的步骤</p></li></ul><h2 id="相关面试问题"><a href="#相关面试问题" class="headerlink" title="相关面试问题"></a>相关面试问题</h2><ol><li><p>父类的静态方法能否被子类重写<br> 不能，声明为static的方法不能被重写，但是能够被再次声明<br> 用static修饰的方法不依赖于任何对象就可以进行访问（就是说你不需要实例化，就可以通过类名访问），在JVM中，这两个静态方法的存储空间是两个，即使没有对象，它也存在。如果试图在子类重写父类的静态方法，编译器不会报错，但是并不会得到相应的结果，当你用父类引用调用的仍是父类的方法，new一个子类调用时，调用的就是子类的静态方法。也就是说你试图重写父类的静态方法和父类的静态方法完全就是两个方法。重写仅对非静态方法有用</p><p> 小提示：JVM中的静态分派（重载）和动态分派（重写）</p></li><li><p>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？<br> 静态属性和静态方法可以，重写不可以<br> <a href="http://www.cnblogs.com/kabi/p/5181941.html" target="_blank" rel="noopener">java中静态属性和和静态方法的继承问题 以及多态的实质</a></p></li><li><p>Java中实现多态的机制是什么<br> 继承、重写、父类引用指向子类对象</p></li><li><p>在Java中，什么时候用重载，什么时候用重写？<br> 子类继承父类，重写父类方法<br> 方法重载，不同的参数，同样的方法名</p></li><li><p>Override和Overload的含义与区别。<br> Override是重写，子类重写父类的方法<br> Overload是重载，方法重载</p><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>异常</td><td>可以修改</td><td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td>访问</td><td>可以修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>返回类型</td><td>可以修改</td><td>一定不能修改</td></tr></tbody></table></li><li><p>Java可以多继承吗<br> 不可以，最多继承一个类，但是可以实现多个接口</p></li><li><p>object类的equal 和hashcode 方法重写，为什么？<br> hashcode用于哈希查找，可以减少在查找中使用equals的次数，所以通常两个一起重写，以便用户可以将对象插入散列表中</p></li><li><p>object有哪些公用方法<br> euqals、toString、hashCode、getClass、wait、notify、notifyAll、</p></li><li><p>抽象类与接口的区别；应用场景；抽象类是否可以没有方法和属性<br> （1）只能继承一个抽象类，但是可以实现多个接口。<br> （2）在abstract class 中可以有自己的数据成员，也可以有非abstarct的方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在 interface中一般不定义数据成员），所有的方法都是public abstract的。<br> （3）抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。接口中定义的变量默认是public static final 型，且必须给其赋初值，所以实现类中不能重新定义，也不能改变其值。<br> （4）abstract class和interface所反映出的设计理念不同。其实abstract class表示的是”is-a”关系，interface表示的是”like-a”关系，门和报警的关系。</p><p> （5）现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法</p><p> 应用场景：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p><p> 可以没有方法和属性</p></li><li><p>abstract 的方法是否可同时是 static、是否可同时是 native、是否可同时是 synchronized 的？为什么？<br>都不可以<br>用static声明方法表明这个方法在不生成类的实例时可直接被类调用，而abstract方法不能被调用，两者矛盾。<br>因为native 暗示这些方法是有实现体的，只不过这些实现体是非java 的，但是abstract却显然的指明这些方法无实现体。<br>从synchronized的功能也可以看出，用synchronized的前提是该方法可以被直接调用，显然和abstract连用</p></li><li><p>抽象关键字不可以和哪些关键字共存？<br>abstract 不能与private、static、final或native并列修饰同一个方法</p></li><li><p>接口与回调；回调的原理；写一个回调demo<br>参考<a href="https://blog.csdn.net/xiaanming/article/details/8703708" target="_blank" rel="noopener">一个经典例子让你彻彻底底理解java回调机制</a></p></li><li><p>接口的意义<br>1、重要性：在Java语言中， abstract class 和interface 是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的 面向对象能力。</p><p>2、简单、规范性：如果一个项目比较庞大，那么就需要一个能理清所有业务的架构师来定义一些主要的接口，这些接口不仅告诉开发人员你需要实现那些业务，而且也将命名规范限制住了（防止一些开发人员随便命名导致别的程序员无法看明白）。</p><p>3、维护、拓展性：比如你要做一个画板程序，其中里面有一个面板类，主要负责绘画功能，然后你就这样定义了这个类，可是在不久将来，你突然发现这个类满足不了你了，然后你又要重新设计这个类，更糟糕是你可能要放弃这个类，那么其他地方可能有引用他，这样修改起来很麻烦，如果你一开始定义一个接口，把绘制功能放在接口里，然后定义类时实现这个接口，然后你只要用这个接口去引用实现它的类就行了，以后要换的话只不过是引用另一个类而已，这样就达到维护、拓展的方便性。</p><p>4、安全、严密性：接口是实现软件松耦合的重要手段，它描叙了系统对外的所有服务，而不涉及任何具体的实现细节。这样就比较安全、严密一些(一般软件服务商考虑的比较多)。</p></li><li><p>权限修饰符protected和默认的区别？proctected 修饰的方法，假如子类和父类不在一个包下，子类可以访问父类中这个方法吗？<br>protected不能用于修饰类，默认可以修饰类，修饰的类同一包中可继承。修饰方法和变量时差不错</p><p>可以，是子类或者同一个包就可以</p></li><li><p>父类的方法是public，子类重写后，改为protect，会不会报错？反过来呢？<br>会反过来不会</p><p>父类中声明为 public 的方法在子类中也必须为 public。</p><p>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private</p></li><li><p>静态绑定和动态绑定的区别<br>（1）静态绑定发生在编译时期，动态绑定发生在运行时<br>（2）使用private或static或final修饰的变量或者方法，使用静态绑定。而虚方法（可以被子类重写的方法）则会根据运行时的对象进行动态绑定。<br>（3）静态绑定使用类信息来完成，而动态绑定则需要使用对象信息来完成。<br>（4）重载(Overload)的方法使用静态绑定完成，而重写(Override)的方法则使用动态绑定完成<br>（5）真实的对象不能用于静态绑定，相反，类型信息比如变量的类型可以用于本地的方法。另一方面，动态绑定用一个真是的对象去找到那个真正的方法的</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM相关总结</title>
      <link href="/2020/02/07/Java%20JVM%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Java%20JVM%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="JVM相关总结"><a href="#JVM相关总结" class="headerlink" title="JVM相关总结"></a>JVM相关总结</h1><h2 id="内存区域和内存溢出异常"><a href="#内存区域和内存溢出异常" class="headerlink" title="内存区域和内存溢出异常"></a>内存区域和内存溢出异常</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><a href="https://upload-images.jianshu.io/upload_images/4061843-15cbe9a02edba4e4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-15cbe9a02edba4e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java虚拟机运行时数据区"></a>Java虚拟机运行时数据区</p><ul><li><p><strong>程序计数器</strong><br>  是一块<strong>较小、线程私有的</strong>的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p><blockquote><p>如果线程正在执行的是一个Java方法，计数器记录的就是正在执行的虚拟机字节码指令的地址；</p><p>如果正在执行的是Native方法，计数器就为空值</p></blockquote><p>  这个内存区域是唯一一个在Java虚拟机规范中没有规定OutOfMemoryError的情况</p></li><li><p><strong>Java虚拟机栈</strong><br>  <strong>线程私有的内存空间，生命周期与线程相同。</strong></p><p>  <strong>描述的是Java方法（字节码）执行的内存模型</strong>：</p><blockquote><p>每个方法执行的同时都会创建一个栈帧用于存储局部变量、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成对应着一个栈帧在虚拟机栈中入栈到出站的过程</p><p>其中局部变量表部分存放了编译器可知的各种基本数据类型、对象引用（reference类型）、returnAddress类型（指向了一条字节码指令的地址）。这些都是所执行的方法中所持有的。基本数据类型中的long和double类型的数据会占用2个局部变量空间（Slot），其余的占用1个。</p><p><strong>局部变量表的内存空间是在编译期间完成分配，方法运行期间不会改变其大小</strong></p></blockquote><p>  这个内存区域有两种异常情况：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）StackOverflowError：如果线程请求的栈深度大于了虚拟机所允许的深度，将抛出此异常（特别是递归） </span><br><span class="line">（2）OutOfMemoryError：如果虚拟机可以动态扩展，当扩展时无法申请到足够的内存</span><br></pre></td></tr></table></figure></li><li><p><strong>本地方法栈</strong><br>  <strong>作用与虚拟机栈类似，不过虚拟机栈是虚拟机执行Java方法的服务，而本地方法栈是为虚拟机使用的Native方法服务。</strong></p><p>  在规范中并没有强制规定本地方法栈中方法使用的语言、使用方式和数据结构等，可以任意实现</p><p>  这个内存区域有两种异常情况：（与虚拟机栈差不多）<br>  （1）StackOverflowError：<br>  （2）OutOfMemoryError：</p></li><li><p><strong>Java堆</strong><br>  Java堆算是虚拟机中内存最大的一块，是被<strong>所有线程共享</strong>的一块内存区域，在虚拟机启动时创建</p><p>  <strong>唯一目的就是存放对象的实例，几乎所有的对象实例在这分配内存</strong></p><blockquote><p>Java堆是垃圾收集器管理的主要区域，因此也可以称之为GC堆。</p><p>从回收的角度看，Java堆还可以细分为<strong>新生代和老年代</strong>，再细致一点可以分为Eden空间、From Survivor空间、To Survivor空间等。</p><p>从内存分配角度，可以划分出多个<em>线程私有的分配缓冲区（TLAB）</em></p></blockquote><p>  有一种异常情况：<br>  OutOfMemoryError：当堆中没有内存完成实例分配且堆无法扩展时，抛出</p></li><li><p><strong>方法区</strong><br>  与Java堆一样，是<strong>各个线程共享</strong>的内存区域，用于<strong>存储已被虚拟机记载的类信息、常量、静态常量、即时编译器编译后的代码等数据</strong></p><blockquote><p>在虚拟机规范中这是Java堆的一个逻辑部分，但也叫Non-Heap（非堆）</p><p>和堆一样不需要连续的内存，并且可以动态扩展；</p><p>这块区域的垃圾回收主要目标是对常量池的回收和对类的卸载，一般比较难以实现</p><p>1.8 HotShopt移除永久代，方法区移至元空间，不再虚拟机内存中：在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p></blockquote><p>  一种异常情况：<br>  OutOfMemoryError：当方法区无法满足内存分配需求时，抛出</p></li><li><p><strong>运行时常量池</strong><br>  <strong>是方法区的一部分，用于存放类加载后进入方法区的Class文件中的常量池信息</strong>，存放了编译器生成的各种字面量和符号引用</p><p>  一种异常情况：<br>  OutOfMemoryError：当常量池无法再申请到内存时，抛出</p></li><li><p><strong>直接内存</strong><br>  不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存被频繁使用</p><blockquote><p>本机直接内存的分配不会手Java堆的大小限制</p><p>使用Native函数库直接分配堆外内存，然后通过Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作</p></blockquote><p>  一种异常情况：<br>  OutOfMemoryError：在给其他区域分配内存时忽略了直接内存，导致动态扩展时内个内存区域总和大于物理内存限制，就抛出</p></li></ul><h3 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h3><ul><li><p>普通Java对象的创建<br>  （1）当遇到一个new指令时，虚拟机首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。如果没有，就会先进行类加载。<br>  （2）当类加载检查通过后，就开始为新生对象分配内存。对象所需的内存大小在类加载完成后就完全确定。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p><blockquote><p>指针碰撞：<br>假设堆中内存绝对规整，所有用过的内存在一边，空闲的在一边，中间放着一个指针作为分界点的指示器，分配新的内存时就仅仅是把指示器这个指针想空闲空间挪动一段与对象大小相等的距离</p><p>空闲列表：<br>如果堆中内存不规整，用过的和空闲的相互交错，虚拟机必须维护一个表用于记录可用的内存块，在分配的时候从列表中找到一块足够大的空间灰分给对象表，并更新表上的记录</p><p>Java堆是否规整取决于垃圾收集器是否带有压缩整理功能，不同的垃圾收集器分配方式不同。Serial、ParNew带有Compact过程就采用指针碰撞，CMS基于Mark-Sweep采用空闲列表</p><p>还需要处理的问题：并发安全，可能出现正在给对象A分配内存，指正还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况<br>解决方案：<br>（a）对分配内存空间的动作进行同步处理：虚拟机采用CAS配上失败重试的方式保证更新操作的原子性<br>（b）把内存分配的动作按照线程划分在不同的空间之中进行：即每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲区TLAB），分配内存时优先在自己的TLAB上分配，只有TLAB用完才进行同步锁定</p></blockquote><p>  （3）分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）<br>  （4）接着，虚拟机对对象进行必要的设置：配置对象头，例如这个对象是哪个类的实例、如何找到类的元数据、对象的哈戏码、对象的GC分代年龄，是否使用对象锁<br>  （5）此时从虚拟机来说，一个新对象就产生了，从Java程序来说，才刚刚开始，因为&lt;init&gt;方法还没有执行，所有的字段都为0</p></li><li><p>对象的内存布局<br>  在HotSpot虚拟机中，对象在内存中存储的布局分为如下：<br>  （1）对象头（Header）</p><blockquote><p>对象头包含两部分信息：</p><p>第一部分用于存储对象自身的运行时数据，如哈戏码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit</p><p>另一部分是类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个的实例</p><p>如果对象是一个Java数组，还有一部分用于记录数组长度的数据</p></blockquote><p>  （2）实例数据（Instance Data）<br>  对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段的内容，包括父类继承、子类定义的。</p><p>  HotSpot虚拟机中默认相同宽度的字段分配到一起</p><p>  （3）对齐填充（Padding）<br>  不一定存在，没有特别含义，仅仅是占位符的作用</p></li><li><p>对象的访问定位<br>  （1）使用句柄访问<br>  Java虚拟对中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息<br>  <a href="https://upload-images.jianshu.io/upload_images/4061843-09b108809fe65ab1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-09b108809fe65ab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="句柄访问"></a>句柄访问</p><p>  （2）直接指针访问<br>  reference中存储的直接就是对象的地址<br>  <a href="https://upload-images.jianshu.io/upload_images/4061843-3be01a80907ff6fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-3be01a80907ff6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="指针访问"></a>指针访问</p><p>  两种方式的优缺点：句柄访问最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，reference本身不修改；直接指针访问的最大好处就是速度更快，节省了一次指针定位的时间开销</p></li></ul><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ul><li><p>Java堆溢出<br>  当对象数量到达最大堆的容量限制就会产生内存溢出异常</p></li><li><p>虚拟机栈和本地方法栈溢出<br>  两种异常：StackOverflowError和OutOfMemoryError<br>  在单个线程下，即使内存无法分配，基本上只会抛出StackOverflowError；每个线程的栈分配的内存越大越容易抛出OutOfMemoryError<br>  每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽</p><p>  <strong>在大多数情况下，虚拟机默认栈深度可以达到1000~2000。如果建立过多线程导致的内存溢出，在不能减少线程数或者更换64位机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程（这样虚拟机栈和本地方法栈的内存就会更多）</strong></p></li><li><p>方法区和运行时常量池溢出<br>  JDK1.7开始，String.intern()方法是一个Native方法，作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象，否则添加，并返回引用</p><p>  方法区溢出是一种常见的内存溢出异常。</p></li><li><p>本机内存直接溢出<br>  unsafe.allocateMemory()</p></li></ul><hr><h2 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h2><h3 id="判断对象已死"><a href="#判断对象已死" class="headerlink" title="判断对象已死"></a>判断对象已死</h3><ul><li><p>引用计数算法<br>  给对象添加一个引用计数器，每当有地方引用它时，计数+1，引用失效时，计数-1，；任何时刻计数为0的对象是不可能再被使用的，但是无法解决对象间循环引用的问题，所以大部分Java虚拟机并没采取这种用法</p></li><li><p>可达性分析算法<br>  现在主流采用的算法<br>  通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索的路径成为引用链，当一个对象到GC Roots对象没有任何引用链相连，则说明此对象是不可用的<br>  <a href="https://upload-images.jianshu.io/upload_images/4061843-c17f6016a79cee8b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-c17f6016a79cee8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可达性分析算法"></a>可达性分析算法</p><p>  Java语言中，可以作为GC Roots对象有：<br>  （1）虚拟机栈中引用的对象<br>  （2）方法区中类静态属性引用的对象<br>  （3）方法区中常量引用的对象<br>  （4）本地方法栈中JNI引用的对象</p></li><li><p>引用<br>  （1）强引用</p><blockquote><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。<br>如：Object o=new Object(); //强引用</p><p>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：<br><code>o=null; //帮助垃圾收集器回收此对象</code></p><p>显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象</p></blockquote><p>  举个ArrayList的实现源代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private transient Object[] elementData;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // Let gc do its work</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">        elementData[i] = null;</span><br><span class="line">    size = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存</p><p>（2）软引用  </p><blockquote><p>是用来描述一些还有用但非必需的对象 </p><p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。二次回收后还是内存不够才会抛出内存溢出异常。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存  </p><p>在JDK 1.2后提供了SoftReference来实现软引用  </p><p>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。 </p><p>（a）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p><p>（b）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出，这时候就可以使用软引用</p></blockquote><p>Browser prev = new Browser();  // 获取页面进行浏览<br>SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用<br>if(sr.get() != null) {<br>    rev = (Browser) sr.get();  // 还没有被回收器回收，直接获取<br>} else {<br>    prev = new Browser();  // 由于内存吃紧，所以对软引用的对象回收了<br>    sr = new SoftReference(prev);  // 重新构建<br>}</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中</p><p>（3）弱引用  </p><blockquote><p>也是用来描述非必须对象，但是强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，不管内存是否足够，都会回收掉关联的对象。  </p><p>在JDK 1.2后，提供了WeakReference来实现弱引用  </p><p>引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p>当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。这个引用不会在对象的垃圾回收判断中产生任何附加的影响。</p><p>比如说Thread中保存的ThreadLocal的全局映射，因为我们的Thread不想在ThreadLocal生命周期结束后还对其造成影响，所以应该使用弱引用，这个和缓存没有关系，只是为了防止内存泄漏所做的特殊操作</p></blockquote><p>（4）虚引用  </p><blockquote><p>也成为幽灵引用或者幻影引用，是最弱的一种引用关系。 </p><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 </p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知  </p><p>在JDK 1.2后，提供了PhantomReference来实现虚引用  </p><p>虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。</p><p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存后，把这个虚引用加入到与之关联的引用队列中。</p><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存回收后采取必要的行动。</p><p>由于Object.finalize()方法的不安全性、低效性，常常使用虚引用完成对象回收后的资源释放工作。</p><p>当你创建一个虚引用时要传入一个引用队列，如果引用队列中出现了你的虚引用，说明它已经被回收，那么你可以在其中做一些相关操作，主要是实现细粒度的内存控制。比如监视缓存，当缓存被回收后才申请新的缓存区。</p></blockquote><ul><li><p>是否回收，判断死亡<br>  即使在可达性分析算法中不可达对象也不是“非死不可”，这时只是一个标记阶段，真正判断回收至少还需要经历两次标记过程：</p><p>  （1）如果对象进行可达性分析后，没有与GC Roots的引用链，那么会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”（finalize只能执行一次，不管是手动还是系统调用）。</p></li></ul><p>（2）如果对象被判定有必要执行finalize()方法，那么会讲对象放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行（所谓的执行是虚拟机会出发该方法，但并不承诺等待它运行结束）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（3）finalize()方法是对象逃脱死亡的最后一次机会，稍后GC会对F-Queue中的对象进行第二次小规模的标记，如果在finalize()中从新与引用链连上，就会被移除“即将回收”的集合</span><br></pre></td></tr></table></figure><ul><li><p>回收方法区<br>  Java虚拟机规范中不要求在方法区实现垃圾收集</p><p>  永久代（方法区）的垃圾收集主要是两部分：<br>  （1）废弃常量<br>  与回收堆中的对象类似</p><p>  （2）无用的类<br>  必须满足以下条件才能判定为无用的类</p><blockquote><p>该类所有的实例都已被回收，Java堆中不存在该类的任何实例<br>加载该类的ClassLoader已经被回收</p><p>该类对应的方法java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p></blockquote><p>  判定为无用的类后也只是可以回收，并<em>不是一定回收</em></p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3></li></ul><h4 id="标记擦除算法"><a href="#标记擦除算法" class="headerlink" title="标记擦除算法"></a>标记擦除算法</h4><p>分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象<br>标记过程就是对象判定死亡过程<br><a href="https://upload-images.jianshu.io/upload_images/4061843-46c2b3f0a1fb2c7b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-46c2b3f0a1fb2c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标记擦除算法"></a>标记擦除算法</p><ul><li>主要不足：<br>  （1）效率问题：标记和清除的效率都不高<br>  （2）空间问题：标记清除后会产生大量不连续的内存碎片，碎片太多导致分配大内存时没有连续的内存就不得不触发新一次的回收</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完后，就将存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。<br>这样使得每一次都是对整个半区进行内存回收，内存分配时就不用考虑碎片的情况了，只要一动栈顶指正，按顺序分配即可<br><a href="https://upload-images.jianshu.io/upload_images/4061843-333edfae62095428.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-333edfae62095428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复制算法"></a>复制算法</p><ul><li>不足：<br>  内存缩小了一半，代价太高</li></ul><p>商业虚拟机基本采用这种回收算法</p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>针对老年代的算法，标记后，不是直接清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存<br><a href="https://upload-images.jianshu.io/upload_images/4061843-9a35d0b36faee56a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-9a35d0b36faee56a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标记整理算法"></a>标记整理算法</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后根据不同的特点采用最恰当的算法<br><strong>新生代中采用复制算法，老年代中采用标记-清理或标记-整理算法</strong></p><h3 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h3><ul><li><p>枚举根节点<br>  HotSpot使用一组OopMap的数据结构来记录哪些地方有对象引用、对象内偏移量上的数据类型，便于在枚举根节点时提高速度（<em>枚举根节点几乎是所有的虚拟机在GC要做的事情</em>）</p></li><li><p>安全点<br>  HotSpot只会在特定的位置（特定的指令）去生成OopMap，这些特定的位置就叫安全点。也就是程序执行时并非在所有地方都停顿下来开始GC，只有在到达安全点时才暂停去GC</p><blockquote><p>安全点的选定：</p><ol><li>指令序列复用</li><li>会让程序长时间执行的代码。例如方法调用、循环跳转、异常条状等会产生安全点</li></ol></blockquote></li></ul><p>如何在GC发生时让所有的线程都到达安全点：<br>（1）抢断式中断：不需要线程的代码主动配合，GC时，首先把所有的线程中断，如果发现有线程没有到达安全点，就恢复让它到达安全点（基本不采用了）<br>（2）主动式中断：当GC需要中断线程时，不直接对线程操作，仅仅简单设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起；轮询标志的地方和安全点重合</p><ul><li>安全区域<br>  在一段代码中，引用关系不会发生变化。这个区域的任意地方开始GC都是安全的</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><a href="https://upload-images.jianshu.io/upload_images/4061843-e0de46a1a32947ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-e0de46a1a32947ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HotSpot"></a>HotSpot</p><ul><li><p>Serial收集器<br>  单线程的收集器，只会使用一个CPU或一条收集线程去GC，并且在进行GC时必须暂停其他所有的工作线程，知道GC结束<br>  在Client模式下默认新生代收集器</p></li><li><p>ParNew收集器<br>  是Serial收集器的多线程版本，使用多条线程进行GC，除此外并无啥区别<br>  在Server模式下是首选的新生代收集器，因为只有它能和CMS配合工作</p></li><li><p>Parallel Scavenge收集器<br>  一个新生代收集器，使用复制算法，并行的多线程收集器<br>  也称为“吞吐量优先”收集器，因为它的目标就是达到一个可控制的吞吐量</p></li><li><p>Serial Old收集器<br>  Serial的老年代收集器，单线程，使用“标记-整理”算法</p></li><li><p>Parallel Old收集器<br>  Parallel Scavenge的老年代收集器，使用多线程和“标记-整理”算法</p></li><li><p>CMS收集器<br>  一种以最短回收停顿时间为目标的收集器，GC过程是与用户线程一起并发执行的，使用“标记-清除”算法</p><p>  GC过程：<br>  （1）初始标记<br>  （2）并发标记：耗时较长<br>  （3）重新标记<br>  （4）并发清楚：耗时较长</p><p>  缺点：<br>  （1）对CPU资源非常敏感<br>  （2）无法处理浮动垃圾：标记过后，GC无法在当次回收的的就是浮动垃圾<br>  （3）采用“标记-清除”会导致大量的空间碎片</p></li><li><p>G1收集器<br>  面向服务端的垃圾收集器，最牛逼的一个（未来），将内存化整为零</p><p>  特点：<br>  （1）并行与并发：充分利用多CPU、多核，来缩短停顿时间<br>  （2）分代收集<br>  （3）空间整合：G1整体看似基于“标记-整理”，但在局部是基于“复制”算法，不会留下空间碎片<br>  （4）可停顿的预测</p><p>  过程：<br>  （1）初始标记<br>  （2）并发标记<br>  （3）最终标记<br>  （4）筛选回收</p></li></ul><h3 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h3><p>对象主要分配在新生代的Eden区上，如果有本地线程缓冲，将按线程优先在TLAB上分配，少数情况可能会直接分配在老年代中</p><ul><li><p>内存分配策略</p><ol><li>对象优先在Eden分配<br> 大多数情况下，对象在新生代Eden区分配，当Eden不够时，会触发一次Minor GC（新生代GC），也可能直接将新对象直接分配到老年代</li><li>大对象直接进入老年代<br> 需要大量连续内存空间的Java对象（长字符串、数组）很容易导致内存还有不少空间就提前触发GC，所以可以直接在老年代分配</li><li>长期存活的对象将进入老年代<br> 每个对象有一个对象年龄计数器（经过的GC次数，仍存活），当这个年龄到达一定的次数（默认15），这个对象就进入老年代</li><li>动态对象年龄判定<br> 如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须达到最大限制次数（比如年龄为5，但是有多个，并且占用内存很大，它们的总和大于了Survivor的一半，那么它们中大于或等于5的都可以直接进入老年代）</li><li>控件分配担保<br> 在新生代GC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么新生代GC是安全的，如果不成立，虚拟机会查看是否允许担保失败。如果允许，就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次新生代GC，如果小于，则不允许冒险，就进行一次老年代GC（Full GC）</li></ol></li><li><p>Full GC的触发条件</p><p>   对于Minor GC（年轻代GC），当Eden区满了就会触发一次；而Full GC需要有一下的条件</p><ol><li>调用System.gc()：调用此方法只是建议虚拟机去执行，虚拟机不一定真正去执行</li><li>老年代空间不足</li><li>空间分配担保失败</li><li>1.7及以前的永久代空间不足</li><li>Concurrent Mode Failure：执行CMS GC过程中同时有对象进入老年代，而此时老年代空间不足（可能时GC过程中浮动垃圾过多导致暂时性的空间不足）就会报这个错并触发Full GC</li></ol></li></ul><hr><h2 id="类文件结构（class文件）"><a href="#类文件结构（class文件）" class="headerlink" title="类文件结构（class文件）"></a>类文件结构（class文件）</h2><p><a href="https://upload-images.jianshu.io/upload_images/4061843-bdacd9b813a6316f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-bdacd9b813a6316f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>Java虚拟机只与Class文件（二进制）所关联</p><h3 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h3><blockquote><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但类或接口不一定都得定义在文件里</p><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按顺序紧凑地排列在文件中，中间没有添加任何分隔符。当遇到占用8位字节以上空间的数据会按照高位在前的方式分割成若干个8位字节</p><p>包含两种数据类型：无符号和表<br>无符号数属于基本的数据类型，u1、u2、u4、u8分别代表1、2、4、8个字节的无符号数，可以用于描述数字、索引引用、数量值或按照UTF-8编码构成的字符串值<br>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，以_info结尾，整个Class文件本质上是一张表</p></blockquote><p>Class文件格式：<br>| 类型 | 名称 | 数量 |<br>| :-: | :-: | :-: |<br>| u4 | magic | 1 |<br>| u2 | minor_version | 1 |<br>| u2 | major_version | 1 |<br>| u2 | constant_pool_count | 1 |<br>| cp_info | constant_pool | constant_pool_count - 1 |<br>| u2 | access_flags | 1 |<br>| u2 | this_class | 1 |<br>| u2 | super_class | 1 |<br>| u2 | interfaces_count | 1 |<br>| u2 | interfaces | interfaces_count |<br>| u2 | fields_count | 1 |<br>| field_info | fields | fields_count |<br>| u2 | methods_count | 1 |<br>| method_info | methods | methods_count |<br>| u2 | attributes_count | 1 |<br>| attribute_info | attributes | attributes_count |<br>| | | |</p><ul><li><p>魔数<br>  每个Class文件的头4个字节成为魔数，也就是magic，唯一作用是确定这个文件是为一个能被虚拟机接受的Class文件。值为：0XCAFEBABE（咖啡宝贝？）<br>  很多文件存储都会使用魔数来进行身份识别，如gif、jpeg</p></li><li><p>Class文件的版本<br>  第5、第6个字节是次版本号（minor_version）<br>  第7、第8个字节是主版本号（major_version）</p><p>  Class文件版本号：</p><table><thead><tr><th align="center">编译器版本</th><th align="center">-target参数</th><th align="center">十六进制版本号</th><th align="center">十进制版本号</th></tr></thead><tbody><tr><td align="center">JDK 1.1.8</td><td align="center">不能带target参数</td><td align="center">00 03 00 2D</td><td align="center">45.3</td></tr><tr><td align="center">JDK 1.2.2</td><td align="center">不带（默认target 1.1）</td><td align="center">00 03 00 2D</td><td align="center">45.3</td></tr><tr><td align="center">JDK 1.2.2</td><td align="center">target 1.2</td><td align="center">00 00 00 2E</td><td align="center">46.0</td></tr><tr><td align="center">JDK 1.3.1_19</td><td align="center">不带（默认1.1）</td><td align="center">00 03 00 2D</td><td align="center">45.3</td></tr><tr><td align="center">JDK 1.4.2_19</td><td align="center">target 1.3</td><td align="center">00 00 00 2F</td><td align="center">47.0</td></tr><tr><td align="center">JDK 1.4.2_10</td><td align="center">不带（默认1.2）</td><td align="center">00 00 00 2E</td><td align="center">46.0</td></tr><tr><td align="center">JDK 1.4.2_10</td><td align="center">1.4</td><td align="center">00 00 00 30</td><td align="center">48.0</td></tr><tr><td align="center">JDK 1.5.0_11</td><td align="center">不带（默认1.5）</td><td align="center">00 00 00 31</td><td align="center">49.0</td></tr><tr><td align="center">JDK 1.5.0_11</td><td align="center">-target 1.4 -source 1.4</td><td align="center">00 00 00 30</td><td align="center">48.0</td></tr><tr><td align="center">JDK 1.6.0_01</td><td align="center">不带（默认1.6）</td><td align="center">00 00 00 32</td><td align="center">50.0</td></tr><tr><td align="center">JDK 1.6.0_01</td><td align="center">1.5</td><td align="center">00 00 00 31</td><td align="center">49.0</td></tr><tr><td align="center">JDK 1.6.0_01</td><td align="center">-target 1.4 -source 1.4</td><td align="center">00 00 00 30</td><td align="center">48.0</td></tr><tr><td align="center">JDK 1.7.0</td><td align="center">不带（默认1.7）</td><td align="center">00 00 00 33</td><td align="center">51.0</td></tr><tr><td align="center">JDK 1.7.0</td><td align="center">1.6</td><td align="center">00 00 00 32</td><td align="center">50.0</td></tr><tr><td align="center">JDK 1.7.0</td><td align="center">-target 1.4 -source 1.4</td><td align="center">00 00 00 30</td><td align="center">48.0</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>常量池<br>  constant_pool，Class文件中的资源仓库，与其他项目关联最多，占用Class文件空间最大的数据项目之一，第一个出现表类型数据项目</p><p>  由于常量池中常量的数量不定，所以先用一个u2型的constant_pool_count表示常量池容量计数值，从1开始（只有这个值是从1开始，其余都是从0开始）</p><p>  常量池中主要存放字面量和符号引用：<br>  （1）字面量：接近于Java语言的常量概念，如文本字符串、声明为final的常量值<br>  （2）符号引用：编译原理概念，包括：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p><p>  常量池中的每一个常量都是一张表<br>  常量池的项目类型：</p><table><thead><tr><th align="center">常量类型</th><th align="center">标志</th><th align="center">项目结构</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CONSTANT_Utf8_info</td><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center">UTF-8编码的字符串</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为1，标志位</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">length</td><td align="center">u2</td><td align="center">UTF-8编码的字符串占用的字节数</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">bytes</td><td align="center">u1</td><td align="center">长度为length的UTF-8编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center"></td><td align="center"></td><td align="center">整型字面量</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为3</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">bytes</td><td align="center">u4</td><td align="center">按照高位在前存储的int值</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">4</td><td align="center"></td><td align="center"></td><td align="center">浮点型字面量</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为4</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">bytes</td><td align="center">u4</td><td align="center">按照高位在前存储的float值</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">5</td><td align="center"></td><td align="center"></td><td align="center">长整型字面量</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为5</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">bytes</td><td align="center">u8</td><td align="center">按照高位在前存储的long值</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">6</td><td align="center"></td><td align="center"></td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为6</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">bytes</td><td align="center">u8</td><td align="center">按照高位在前存储的double值</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">7</td><td align="center"></td><td align="center"></td><td align="center">类或接口的符号引用</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为7</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">name_index</td><td align="center">u2</td><td align="center">一个索引值，指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或接口）的全限定名</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">8</td><td align="center"></td><td align="center"></td><td align="center">字符床类型字面量</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为8</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">index</td><td align="center">u2</td><td align="center">指向字符串字面量的索引</td></tr><tr><td align="center">CONSTANT_Fieldref_info</td><td align="center">9</td><td align="center"></td><td align="center"></td><td align="center">字段的符号引用</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为9</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">index</td><td align="center">u2</td><td align="center">指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">index</td><td align="center">u2</td><td align="center">指向字段描述符CONSTANT_NameAndType的索引项</td></tr><tr><td align="center">CONSTANT_Methodref_info</td><td align="center">10</td><td align="center"></td><td align="center"></td><td align="center">类中方法的符号引用</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为10</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">index</td><td align="center">u2</td><td align="center">指向声明方法的类描述符CONSTANT_Class_info的索引项</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">index</td><td align="center">u2</td><td align="center">指向名称及类型描述符CONSTANT_NameAndType的索引项</td></tr><tr><td align="center">CONSTANT_InterfaceMethodref_info</td><td align="center">11</td><td align="center"></td><td align="center"></td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为11</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">index</td><td align="center">u2</td><td align="center">指向声明方法的接口描述符CONSTANT_Class_info的索引项</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">index</td><td align="center">u2</td><td align="center">指向名称及类型描述符CONSTANT_NameAndType_info的索引项</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center"></td><td align="center"></td><td align="center">字段或方法的部分符号引用</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为12</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">index</td><td align="center">u2</td><td align="center">指向该字段或方法名称常量项的索引</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">index</td><td align="center">u2</td><td align="center">指向该字段或方法名称描述符常量项的索引</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center"></td><td align="center"></td><td align="center">表示方法句柄</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为15</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">reference_kind</td><td align="center">u1</td><td align="center">值必须在1~9之间，决定了方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">reference_index</td><td align="center">u2</td><td align="center">值必须是对常量池的有效索引</td></tr><tr><td align="center">CONSTANT_MethodType_info</td><td align="center">16</td><td align="center"></td><td align="center"></td><td align="center">标识方法类型</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为16</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">descriptor_index</td><td align="center">u2</td><td align="center">值必须是对常量池的有效索引，常量池在该索引处必须是CONSTANT_Utf8_info结构，表示方法的描述符</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">18</td><td align="center"></td><td align="center"></td><td align="center">表示一个动态方法调用点</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">tag</td><td align="center">u1</td><td align="center">值为18</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">bootstrap_method_attr_index</td><td align="center">u2</td><td align="center">值必须是对当前Class文件中引导方法表中的bootstrap_methods[]数组的有效索引</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">name_and_type_index</td><td align="center">u2</td><td align="center">值必须是对当前常量池的有效索引，常量池也该在索引处的项必须是CONSTANT_NameAndType_indo结构，表示方法名和方法描述符</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>访问标志<br>  在常量池后面紧接着2个字节表示访问标志，用于识别一些类或者接口层次的访问信息，包括这个Class是类还是接口、是否定义为public类型、是否定义为abstract类型、如果是类是否声明为final等</p><table><thead><tr><th align="center">标志名称</th><th align="center">标志值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td align="center">是否为public类型</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td align="center">是否被声明为final，只有类可设置</td></tr><tr><td align="center">ACC_SUPER</td><td align="center">0x0020</td><td align="center">是否允许使用invokespecial字节码指令的新语意</td></tr><tr><td align="center">ACC_INTERFACE</td><td align="center">0x0200</td><td align="center">标识这是一个接口</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td align="center">是否为abstract类型，对于类或接口为真</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td align="center">标识这个类并非由用户代码产生</td></tr><tr><td align="center">ACC_ANNOTATION</td><td align="center">0x2000</td><td align="center">标识这是一个注解</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td align="center">标识只是一个枚举</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>类索引、父类索引、接口索引集合<br>  类索引（this_class）、父类索引（super_class）都是一个u2类型，接口索引集合（interfaces）是一组u2类型的集合，入口第一项表示集合大小</p><p>  Class文件通过这三项来确定类的继承关系</p></li><li><p>字段表集合<br>  field_info（字段表）用于描述接口或类中声明的变量，字段包括类级变量以及实例级变量，<strong>但不包括在方法内存声明的局部变量</strong></p><p>  字段修饰符access_flags与类中的access_flags项目类似，都是一个u2的数据类型，包括是否为public、private、protected、static、final、volatile、transient、enum、是否由编译器自动产生</p><p>  name_index代表字段的简单名称，指没有类型和参数修饰的方法或字段名称，对应常量池的引用</p><p>  descriptor_index代表字段和方法的描述符，对应常量池的引用</p></li><li><p>方法表集合<br>  同字段表结构一样，包括了access_flags、name_index、descriptor_index、attributes</p><p>  访问标志access_flags中没有了volatile和transient关键字的标志，多了synchronized、native、strictfp、abstract关键字的标志</p></li><li><p>属性表集合<br>  Class文件、字段表、方法表都会携带自己的属性表集合，用于表述某些场景专有的信息<br>  属性表集合不再要求各个属性表具有严格的顺序</p><p>  主要看看Code属性：Java程序方法体中的代码经过Javac编译处理后，最终变为字节码指令存储在Code属性内</p></li></ul><hr><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</p><p>类的加载、连接和初始化过程都是在运行期完成的</p><p><strong>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有的类</strong></p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>类或接口从被加载到虚拟机内存中开始到卸载出内存为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading），其中验证、准备、解析3个部分称为连接（Linking）<br><a href="https://upload-images.jianshu.io/upload_images/4061843-bc2fbc0e66129948.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-bc2fbc0e66129948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类加载过程"></a>类加载过程</p><p><strong>加载、验证、准备、初始化、卸载5个阶段的顺序是确定的，加载过程必须按照这个顺序。但解析不一定：在某些情况下可以在初始化之后再开始（为了支持动态绑定或晚期绑定）</strong></p><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><ul><li><p>主动引用</p><p>  5种情况必须初始化（初始化之前加载、验证、准备已经执行完）：</p><ol><li>遇到new、setstatic、putstatic、invokestatic这4条字节码指令时，如果类或接口没有进行初始化，则需要先进行初始化<br> 常见场景：使用new实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）、调用一个类的静态方法时</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果没有初始化，触发初始化</li><li>当初始化一个类的时候，如果发现其父类还没有初始化，则先触发父类进行初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的类（包含main函数的ActivityThread），虚拟机会先初始化这个主类</li><li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHanlde实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则先触发初始化</li></ol></li></ul><p>只有主动引用（上面5种情况）才能触发初始化，被动引用不可以。</p><ul><li>被动引用<ol><li>对于静态字段，只有直接定义这个字段的类才会被初始化，通过其子类来引用父类中定一个的静态字段，只会触发父类的初始化而不会触发子类的初始化，但加载、验证是否被触发就跟虚拟机相关了</li><li>通过数组定义类引用类，不会触发此类的初始化<br> <code>MyClass[] mycls = new MyClass[10];</code></li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类（常量传播优化，存储到引用的类的常量池），因此不会触发定义常量的类的初始化，直接调用常量不会触发类的初始化</li></ol></li></ul><p>接口基本与类相同，但是没有static静态语句块，但编译器会为接口生成&lt;clinit&gt;()类构造器来初始化接口中定义的成员变量，接口在初始化的时候不会要求父接口的都完成了初始化，只有使用父接口的时候，父接口才会初始化</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><ul><li><p>加载</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><p> 非数组类的加载（获取类的二进制字节流的动作）可以使用系统提供的引导类加载器来完成，也可以通过用于自定义的类加载器完成</p><p> 数组类由虚拟机直接创建的，不通过加载器，创建遵循规则：</p><p> （1）如果数组的组件类型（去掉一个维度的类型）是引用类型（如MyClass[]），那就递归采用加载器去加载，数组类将在加载该组件类型的类加载器的类名称空间上被标识</p></li></ol></li></ul><p>（2）如果数组的组件类型不是引用类型（如int[]），Java虚拟机会把这个数组类标记为与引导类加载器关联</p><p>（3）数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，可见性则默认public</p><p>加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区的外部接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载阶段和连接阶段是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始</span><br></pre></td></tr></table></figure><ul><li><p>验证<br>  <strong>验证是连接的第一步，确保Class文件的字节流中包含的信息符号当前虚拟机的要求且不会危害虚拟机自身的安全</strong></p><ol><li><p>文件格式验证<br> 验证字节流是否符合Class文件格式的规范，且能被当前虚拟机处理<br> 验证点：<br> （1）是否以魔数0xCAFEBABE开头</p><p> （2）主次版本号是否在当前虚拟机处理范围内</p><p> （3）常量池的常量中有不被支持的常量类型（常量tag标志）</p><p> （4）指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量</p><p> （5）CONSTANT_Utf8_info型的常量是否有不符合UTF8编码的数据</p><p> （6）Class文件中各个部分及文件本身是否有被删除的或附加的其他信息<br> …</p></li><li><p>元数据验证</p><p> 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范</p><p> 验证点：</p><p> （1）这个类是否有父类</p><p> （2）这个类的父类是否继承了不允许继承的类（final修饰的类）</p><p> （3）如果这个类不是抽象类，是否实现了父类或接口中要求实现的所有方法</p><p> （4）类中的字段、方法是否与父类产生矛盾<br> …</p></li><li><p>字节码验证</p><p> 是整个验证过程最复杂的阶段，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的<br> 如果一个类方法体的字节码没有通过字节码验证，那肯定有问题，但如果通过了，也不能说明一定安全</p></li><li><p>符号引用验证<br> 在虚拟机将符号引用转化为直接引用的时候验证，这个转化动作在连接的第三阶段——解析阶段发生<br> 是对类自身以外的信息进行匹配性校验</p><p> 检验点：<br> （1）符号引用中通过字符串描述的全限定名是否恁找到对应的类</p><p> （2）在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</p><p> （3）符号引用中的类、字段、方法的访问性是否可被当前类访问<br> …</p></li></ol></li><li><p>准备<br>  <strong>正式为类变量分配内存并设置类变量初始值的阶段，在方法区中进行内存分配。</strong><br>  进行分配的仅包括类变量（static修饰的变量）而不包括实例变量，实例变量将会在对象实例化时伴随对戏那个一起分配在堆中，这里的初值是数据类型的零值。<br>  如果类字段的字段属性表中存在ConstantValue属性，那就在这个阶段进行初始化赋值，如<code>public static final int value = 123;</code><strong>就会在准备阶段直接赋值为123而不是零值</strong></p></li><li><p>解析<br>  <strong>虚拟机将常量池内的符号引用替换为直接引用的程</strong><br>  符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量。引用的目标不一定已经加载到内存中</p></li></ul><p>直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">主要针对以下符号引用解析：  </span><br><span class="line">1. 类或接口的解析 </span><br><span class="line">    假设当前代码所处的类为D，符号引用N解析为一个类或接口C的直接引用； </span><br><span class="line">    （1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载C </span><br><span class="line"></span><br><span class="line">    （2）如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“|[Ljava/land/Integer”的形式，就会按照（1）加载数组元素类型；如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象 </span><br><span class="line"></span><br><span class="line">    （3）如果（1）（2）没有任何异常，那么C在虚拟机中实际上就是一个类或接口了，但在解析完成之前之前还要进行符号引用验证，确认D是否具备对C的访问权限  </span><br><span class="line"></span><br><span class="line">2. 字段解析 </span><br><span class="line">    首先将对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用，C解析成功后，对C后续字段的搜索 </span><br><span class="line"></span><br><span class="line">    （1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束 </span><br><span class="line"></span><br><span class="line">    （2）否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束  </span><br><span class="line"></span><br><span class="line">    （3）否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束  </span><br><span class="line"></span><br><span class="line">    （4）否则查找失败  </span><br><span class="line"></span><br><span class="line">    查找过程成功返回了引用后，还将对这个字段进行权限验证</span><br><span class="line"></span><br><span class="line">3. 类方法解析  </span><br><span class="line"></span><br><span class="line">    第一个步骤与字段解析的第一个步骤一样，也需要先解析出方法表类的class_index项中索引的方法所属的类或接口的符号引用，解析成功后进行类方法搜索  </span><br><span class="line"></span><br><span class="line">（1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就抛出异常  </span><br><span class="line"></span><br><span class="line">    （2）如果通过了（1），在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束  </span><br><span class="line"></span><br><span class="line">    （3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束  </span><br><span class="line"></span><br><span class="line">    （4）否则，在类C实现的接口列表及它们的父接口中递归查找是否有简单名称和描述符都与目标想匹配的方法，如果存在，则说明类C是一个抽象类，查找结束，抛出异常  </span><br><span class="line"></span><br><span class="line">    （5）否则，宣告方法查找失败，抛出异常  </span><br><span class="line"></span><br><span class="line">4. 接口方法解析  </span><br><span class="line"></span><br><span class="line">    先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，进行后续的接口方法搜索  </span><br><span class="line"></span><br><span class="line">    （1）如果在接口方法表中发现class_index中的索引C是个类不是接口，直接抛出异常  </span><br><span class="line"></span><br><span class="line">    （2）否则，在接口C中查找是否有简单名称和符号引用都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束  </span><br><span class="line"></span><br><span class="line">    （3）否则，在接口C的父接口中递归查找，知道java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束  </span><br><span class="line"></span><br><span class="line">    （4）否则，宣告查找失败</span><br></pre></td></tr></table></figure><ul><li><p>初始化</p><p>  类加载过程的最后一步。</p><p>  在这个阶段，<strong>根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，初始化阶段是执行类构造器&lt;clinit&gt;()方法（不是实例构造器，平时所说的是实例构造器）的过程</strong></p><p>  <strong>&lt;clinit&gt;()方法</strong>是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量前面的静态语句块可以赋值但不能访问</p><p>  <strong>&lt;clinit&gt;()方法</strong>与类的构造函数（类的实例构造函数<strong>&lt;init&gt;</strong>）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<strong>&lt;clinit&gt;()方法</strong>执行之前（<em>也就意味着父类定义的静态语句块的执行要优先于子类</em>），父类的<strong>&lt;clinit&gt;()方法</strong>执行完毕，因此虚拟机上第一个执行的类是Object</p><p>  <strong>&lt;clinit&gt;()方法</strong>对类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<strong>&lt;clinit&gt;()</strong></p><p>  接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口和类一样都会生成<strong>&lt;clinit&gt;()方法</strong>，但执行接口的<strong>&lt;clinit&gt;()方法</strong>不需要先执行父接口的&lt;clinit&gt;()方法，只有当父接口中定一个的变量使用时，父接口才会初始化。接口的实现类在初始化的时候也一样不会执行接口的<strong>&lt;clinit&gt;()方法</strong></p><p>  虚拟机会保证一个类的<strong>&lt;clinit&gt;()方法</strong>在多线程环境中被正确地枷锁、同步，如果多个线程同时初始化一个类，那么只会有一个线程去执行这个类的<strong>&lt;clinit&gt;()方法</strong>，其他线程都需要阻塞等待，知道活动线程执行<strong>&lt;clinit&gt;()方法</strong>完毕</p></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><p>类与类加载器<br>  类加载器用于实现类的加载动作。每一个类加载器都有一个独立的类名称空间（比较两类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使两个类来源于同一个Class文件，但类加载器不同，必定不相等）</p></li><li><p>双亲委派模型<br>  两种类加载器：一种是启动类加载器，用C++实现，是虚拟机自身的一部分呢；另一种是所有其他的类加载器，由Java语言实现，独立于虚拟机外部，且全继承自抽象类java.lang.ClassLoader</p><p>  三种系统提供的类加载器：</p><p>  （1）启动类加载器：负责将存放在&lt;JAVA_HOME&gt;\lib目录中的或者被-Xbootclasspath参数所指定的路径中的且是虚拟机识别的类库加载到虚拟机内存中。无法被Java程序直接引用</p></li></ul><p>（2）扩展类加载器：负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的或者被java.ext.dirs系统变量所指定的路径中的所有类库。开发者可以直接使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（3）应用程序类加载器：是ClassLoader的getSystemClassLoader()方法的返回值，一般也称为系统类加载器</span><br><span class="line"></span><br><span class="line">类加载器之间的层次模型就是双亲委派模型，除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器  </span><br><span class="line"></span><br><span class="line">![双亲委派模型](https://upload-images.jianshu.io/upload_images/4061843-f27f2e4b8899540d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父加载器反馈无法完成时，子加载器才会尝试自己加载</span><br></pre></td></tr></table></figure><ul><li><p>破坏双亲委派模型<br>  （1）双亲委派模型出现之前，已经有了自定义类加载器</p><p>  （2）模型自身的缺陷导致（基础类需要调回用户的代码</p></li></ul><p>JNDI服务，使用线程上下文类加载器，父类加载器请求子类加载器去完成类加载的动作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（3）由于用户对程序动态性的追求而导致的（代码热替换、模块热部署）</span><br></pre></td></tr></table></figure><hr><h2 id="虚拟机字节码"><a href="#虚拟机字节码" class="headerlink" title="虚拟机字节码"></a>虚拟机字节码</h2><p>虚拟机字节码执行引擎的过程：输入的是字节码文件，处理的过程是字节码解析的等效过程，输出的是执行结果</p><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，就是虚拟机运行时数据区中的虚拟机栈的栈元素</p><p><strong>栈帧存储了方法的局部变量表、操作数栈、动态连接、方法返回地址等信息</strong><br>在活动线程中，只有位于栈顶的栈帧才是有效的，成为当前栈帧，与这个栈帧相关联的方法称为当前方法。所有字节码指令都只针对当前栈帧进行操作<br><a href="https://upload-images.jianshu.io/upload_images/4061843-4659287409b6321f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-4659287409b6321f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈帧结构概念图"></a>栈帧结构概念图</p><ul><li><p>局部变量表<br>  是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，建立在线程的堆栈上，线程私有。在编译为Class文件时，在方法的Code属性的max_locals确定了变量表的最大容量</p><p>  局部变量的容量以变量槽（Slot）为最小单位，每个boolean、byte、char、short、int、float、reference（对象实例引用）、returnAddress类型的数据应该占一个Slot。一个Slot可以存放一个32位以内的数据类型<br>  64位中，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间，访问必须同时访问两个Slot</p><p>  方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含参数。<br>  局部变量表中的Slot可以重用</p></li><li><p>操作数栈<br>  也叫操作栈，后入先出栈，最大深度在写入到Code属性的max_stacks数据项中。32位数据类型所占栈容量为1，64位则为2</p><p>  栈帧重叠：部分重叠，实现栈帧之间的数据共享</p></li><li><p>动态连接<br>  字节码中的方法调用是以常量池中指向方法的符号引用作参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就直接转化为直接引用，这就是静态解析<br>  另外一部分将在每一次运行期间转化为直接引用，称为动态连接</p></li><li><p>方法返回地址<br>  当一个方法执行后，只有两种方式可以退出：<br>  （1）执行引擎遇到任意一个方法返回的字节码指令，正常完成出口（正常退出）<br>  （2）方法执行过程中遇到了异常，且没有在方法体内得到处理，异常完成出口（异常退出）</p></li></ul><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（调用哪一个方法，特别是重载、重写的情况），暂时不涉及方法内部的具体运行过程</p><ul><li><p>解析<br>  调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析<br>  类加载阶段能确定下来的方法：静态方法、私有方法、实例构造器、父类方法、final修饰的方法，类加载的时候会直接将符号引用解析成直接引用</p><p>  解析调用一定是个静态的过程，编译期间完全确定</p></li><li><p>分派<br>  多态的最基本的实现就是通过分派来实现</p><ol><li><p>静态分派<br> 依赖于静态类型来定位方法执行版本的分派动作叫静态分派</p><p> 典型应用：方法重载，具体调用哪个方法取决于参数参数的数量和数据类型<br> <code>Human man = new Man();</code>中，Human称为变量的静态类型（或者叫外观类型），Man称为变量的实际类型。静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译器可知的；而实际类型变化的结果是运行器才可确定，编译器在编译程序并不知道一个对象的实例是什么<br> 虚拟机在重载时是通过参数的静态类型（静态类型在编译时可知）而不是实际类型作为判断依据来决定使用哪个方法，这里的选择只是最优的，如果没有就会选择次优的（如果没有最优匹配，注意自动转换、自动装箱）</p></li><li><p>动态分派<br> 在运行期根据实例类型确定方法执行版本的动作叫做动态分派</p><p> 典型应用：重写，调用父类还是子类的方法取决于调用者的实例类型<br> 实例类型只有运行期才能确定</p></li><li><p>单分派与多分派<br> 方法的接收者与方法的参数统称为方法的宗量<br> 静态多分派，动态单分派</p></li><li><p>虚拟机动态分派的实现<br> <a href="https://upload-images.jianshu.io/upload_images/4061843-90005266ef1a1fd1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-90005266ef1a1fd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚方法表"></a>虚方法表<br> 虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口一致，都指向父类的实现入口。如果重写了方法，子类方法表中的地址将会替换为子类实现版本的入口地址</p></li></ol></li><li><p>动态类型语言支持</p><ol><li>动态类型语言：类型检查的主体过程是在运行期而不是编译期，如APL、PHP…</li><li>JDK 1.7与动态类型</li><li>java.lang.invoke包：提供一种新的动态确定目标方法的机制</li></ol></li></ul><h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><ul><li>解释执行</li><li>编译执行</li></ul><hr><h2 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h2><ul><li>解析与填充符号表过程<ol><li>词法、语法分析</li><li>填充符号表</li></ol></li><li>插入式注解处理器的注解过程</li><li>分析与字节码生成过程<ol><li>标注检查</li><li>数据及控制流分析</li><li>解语法糖</li><li>字节码生成</li></ol></li></ul><hr><h2 id="内存模型与线程"><a href="#内存模型与线程" class="headerlink" title="内存模型与线程"></a>内存模型与线程</h2><p>内存模型：在特定的操作协议下，对特定的操作内存或高速缓存进行读写访问的过程抽象</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型的主要目标是定义程序中各个变量（包括视力字段、静态字段、构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有，不会被共享也就不会有竞争）的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这些底层的细节。</p><ul><li>主内存与工作内存<br>  Java内存模型规定了所有的变量都存储在主内存，每条线程有自己的工作内存（有点类似于高速缓存），线程的工作内存中保存了被该线程使用到的变量的内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接操作主内存中的。不同线程间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。<br>  <a href="https://upload-images.jianshu.io/upload_images/4061843-43ba39b5231dc50e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-43ba39b5231dc50e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java内存模型"></a>Java内存模型</li><li>内存间交互操作<br>  Java内存模型定义了8种操作来完成内存间的交互（主内存和工作内存），这几种操作都是原子的、不可再分的（对于double和long的load、store、read、write在某些平台有例外）<ol><li>lock（锁定）：作用于主内存变量，把一个变量标识为一条线程独占的状态</li><li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定</li><li>read（读取）：作用于主内存变量，把一个变量的值从主内存传输到线程工作内存中，以便后续的load使用</li><li>load（载入）：作用于工作内存变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use（使用）：作用于工作内存变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作</li><li>assign（赋值）：作用于工作内存变量，把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li>store（存储）：作用于工作内存变量，把工作内存中一个变量的值传送到主内存中，以便随后的write使用</li></ol></li></ul><ol><li>write（写入）：作用于主内存变量，把store操作从工作内存中得到的变量放入主内存的变量中</li></ol><p>如果变量从主内存到工作内存，必须顺序执行read和load；从工作内存到主内存，必须顺序执行store和write</p><p>以上8种操作需满足规则：<br>（1）不允许read和load、store和write操作单一出现，即不允许一个变量从主内存读取了但工作内存不接受或者从工作内存发起回写了但主内存不接受<br>（2）不允许一个线程丢弃它的最经的assign操作，即变量在工作内存改变了之后必须把该变化同步到主内存</p><p>（3）不允许一个线程无原因（没有assign操作）地把数据从工作内存同步回主内存</p><p>（4）一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化的变量。也就是说对一个变量实施use、store操作之前，一定要先执行assign、load</p><p>（5）一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程多次执行，lock的次数和unlock次数对应才会解锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（6）如果对一个变量执行lock操作，那么将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值  </span><br><span class="line"></span><br><span class="line">（7）如果一个变量事先没有被lock锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量  </span><br><span class="line"></span><br><span class="line">（8）对一个变量执行unlock之前，必须先把此变量同步回主内存中（执行store、write）</span><br></pre></td></tr></table></figure><ul><li><p>对于volatile型变量的特殊规则</p><p>  关键字volatile是实现最轻量级的同步机制</p><p>  当一个变量用volatile修饰后，具有两种特性：第一是保证此变量对所有线程的可见性（当一条线程修改变量的值，其他线程立即得知），但是并非原子性操作，并发下不安全。第二是禁止指令重排序优化</p><p>  对一个变量操作时，必须是load后面跟着use，use前面是load，assign后面是store，store前面是assign这样的顺序</p></li><li><p>对于long和double型变量的特殊规则<br>  对于64位的数据类型（long和double），允许虚拟机将没有被volatile修饰的数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read、write这四个操作的原子性</p></li><li><p>原子性、可见性、有序性<br>  原子性：</p></li></ul><p>Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write，大致可以认为基本数据类型的访问读写具有原子性，lock、unlock也是，synchronized也具有原子性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可见性： </span><br><span class="line">当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 </span><br><span class="line">Java内存模型通过变量修改后同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现</span><br></pre></td></tr></table></figure><p>volatile、synchronized、final都可以实现可见性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序性：</span><br></pre></td></tr></table></figure><p>Java提供了volatile（本身禁止指令重排序）和synchronized（一个变量在同一时刻只允许一条线程对其进行lock操作）来保证线程间操作的有序性</p><ul><li><p>先行发生原则<br>  是判断数据是否存在竞争、线程是否安全的主要依据<br>  先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说发生在B之前，操作A产生的影响能被操作B观察到</p><p>  天然的先行发生关系：</p><ol><li>程序次序规则：在一个线程内，按照程序代码顺序（控制流顺序）执行，在前的先执行</li><li>管程锁定规则：一个unlock先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li><li>线程启动规则：Thread对象的start方法先行发生于此线程的每一个动作</li><li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测</li><li>线程中断操作：对线程interrupt方法的调用先行于被中断线程的代码检查到中断事件的发生</li><li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行于发生于它的finalize方法的开始</li><li>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么A一定先行于C</li></ol></li></ul><h3 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3><ul><li><p>线程的实现</p><ol><li><p>使用内核线程实现<br> 内核线程（KLT）：直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。支持多线程的内核叫做多线程内核</p><p> 程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（LWP），就是我们通常说的线程。由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。一对一模型<br> <a href="https://upload-images.jianshu.io/upload_images/4061843-acb5a8e360141ac4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-acb5a8e360141ac4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内核线程实现"></a>内核线程实现</p></li><li><p>使用用户线程实现<br> 广义上来讲一个线程只要不是内核线程都算是用户线程。这样轻量级线程也算是用户线程，但其实现是内核线程。<br> 狭义上的用户线程是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁、调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作非常快速且低消耗，也可以支持规模更大的线程数量。一对多的模型<br> <a href="https://upload-images.jianshu.io/upload_images/4061843-c7bf39b397e59e1d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-c7bf39b397e59e1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户线程实现"></a>用户线程实现</p></li><li><p>使用用户线程加轻量级进程混合实现<br> 内核线程和用户线程一起使用。N:M模型<br> <a href="https://upload-images.jianshu.io/upload_images/4061843-5c9c4fc95f3975dd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-5c9c4fc95f3975dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户线程加轻量级进程"></a>用户线程加轻量级进程</p></li></ol></li><li><p>Java线程调度<br>  线程调度：系统为线程分配处理器使用权的过程</p><p>  主要调度方式：</p><ol><li><p>协同式线程调度：线程执行的时间由现场本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上，最大的好处就是实现简单，坏处就是线程执行时间不可控</p></li><li><p>抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定；线程的执行时间是系统可控的，不会有进程阻塞问题</p><p> Java中采用抢占式，但是有10个级别的线程优先级，优先级越高越容易执行</p></li></ol></li><li><p>状态转换<br>  线程一共有5中状态，任何时刻，一个线程只能有一种状态</p><ol><li>新建（New）：创建后尚未启动的线程处于这种状态</li><li>运行（Runable）：包括了操作系统线程状态中的Running和Ready，此状态的线程可能执行可能等待CPU分配时间</li><li>无限期等待（Waiting）：这种状态的线程不会被分配CPU执行时间，要等待被其他线程显式地唤醒<br> 以下方法会让线程陷入Waiting：<br> （1）没有设置Timeout参数的Object.wait()<br> （2）没有设置Timeout参数的Thread.wait()<br> （3）LockSupport.park()</li><li>限期等待（Timed Waiting）：这种状态的线程不会被分配时间，不过无须等待被其他线程显式地唤醒，一定时间后就由系统自动唤醒<br> 以下是进入限期等待：<br> （1）Thread.sleep()<br> （2）设置了Timeout参数的Object.wait()<br> （3）设置了Timeout参数的Thread.join()<br> （4）LockSupport.parkNaons()<br> （5）LockSupport.parkUntil()</li><li>阻塞（Blocked）：线程被阻塞了，阻塞状态和等待状态的区别是：阻塞状态在等待着获取到一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而等待状态则是在等待一段时间或者唤醒动作的发生，在程序等待进入同步区域的时候就是进入这种状态</li></ol></li></ul><h2 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li><p>Java语言中的线程安全</p><ol><li>不可变：不可变的对象一定是线程安全的，用final修饰符，例如String、枚举、Number的部分子类、Long、Double的包装类型、BigInteger、BigDecimal都是不可变的</li><li>绝对线程安全：Java API中标注自己是线程安全的类大多数是不安全的，例如Vector在多线程进行操作的时候仍然需要手动保证安全（上锁）</li><li>相对线程安全：通常意义上就是我们所说的线程安全，需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做保障措施，比如Vector、HashTable、Collections的synchronized、Collection方法包装的集合</li><li>线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发的环境中安全使用</li><li>线程对立：指无论调用端是否采用了同步措施，都无法在多线程环境中并发使用的代码，例如线程的操作suspend和resume，必须对立不同同时操作调用这两个方法</li></ol></li><li><p>线程安全实现方法</p><ol><li><p>互斥同步：<br> （1）通过synchronized关键字来实现，这是一个重量级的操作</p><p> （2）还可以用ReentrantLock（重入锁）来实现</p><blockquote><p>一些区别：<br>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助</p><p>公平锁：多个线程在等待同一个锁时，必须按照申请所得时间顺序来依次获得锁，非公平锁不保证这一点，synchronized、ReetrantLock的锁是非公平的</p><p>锁绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait和notify、notifAll方法可以实现一个隐含的条件，如果要和多于一个条件关联的时候，就不得不额外枷锁，而ReentrantLock只需要多次调用newCondition方法就可以了</p></blockquote></li><li><p>非阻塞同步：<br> 互斥同步最主要的问题就是进行线程阻塞和唤醒带来的问题，从处理问题的方式来说，互斥同步属于一种悲观的并发策略</p><p> 基于冲突检测的乐观并发策略：先进性操作，如果没有其他线程争用共享数据，那操作成功；如果有争用，产生了冲突，那就再采取其他的补偿措施（不断重试），因为不需要把线程挂起，所以这就是非阻塞同步</p></li><li><p>无同步方案：<br> 保证线程安全并不一定要进行同步，两者没有因果关系。如果一个方法不涉及共享数据，就无需同步措施保证正确性</p><p> 可重入代码：也叫纯代码，可以在代码执行的任何时刻去中断它，转而去执行另一段代码，而在控制权返回后原来的程序不会出现任何错误</p><p> 线程本地存储：如果一段代码中所需要的数据必须是与其他代码共享，那就可以考虑这些共享数据在同一个线程，就无需同步也能保证线程之间不出现争用</p></li></ol></li></ul><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li><p>自旋锁、自适应自旋<br>  自旋锁：为了让线程等待，让线程执行一个忙循环（自旋），默认自旋次数10</p><p>  自适应自旋锁：自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋可能再次成功，进而允许自旋等待持续相对更长的时间</p></li><li><p>锁消除</p><p>  虚拟机即时编译器在运行时，对一些代码上要求同步，但不能被检测到不可能存在共享数据竞争的锁进行消除。</p><p>  锁小吃的主要判定依据来源于逃逸分析的数据支持，如果在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的</p></li><li><p>锁粗化</p></li><li><p>轻量级锁<br>  相对于使用操作系统互斥量来实现传统所而言的，传统的锁机制成为“重量级”锁。<br>  轻量级锁并不是代理重量级锁的，是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</p></li><li><p>偏向锁<br>  目的是为了消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能</p></li></ul><h2 id="JVM、DVM、ART的区别"><a href="#JVM、DVM、ART的区别" class="headerlink" title="JVM、DVM、ART的区别"></a>JVM、DVM、ART的区别</h2><p>JVM：Java虚拟机</p><p>DVM：Dalvik虚拟机， Android中的</p><p>ART：Android L开始引入的</p><ol><li>Java虚拟机运行的时Java字节码，Dalvik虚拟机运行的dex字节码</li><li>Dalvik可执行文件体积更小</li><li>Java虚拟机编译后，Java字节码保存在class文件中；Dalvik则会将Java字节码转换为dex字节码，并打包在dex可执行文件中</li><li>JVM基于栈，DVM基于寄存器</li><li>apk都是dex文件，但DVM执行的是dex字节码，依靠JIT即时编译器解释执行，运行时动态将dex翻译成本地机器码；ART执行的是本地机器码，依靠AOT预编译，在安装时将dex文件翻译成本地机器码；所以DVM安装块，启动慢，ART安装时间长，启动快</li></ol><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li><p>GC回收策略<br> （1）对象优先在Eden分配<br> 大多数情况下，对象在新生代Eden区分配，当Eden不够时，会触发一次Minor GC（新生代GC），也可能直接将新对象直接分配到老年代<br> （2）大对象直接进入老年代<br> 需要大量连续内存空间的Java对象（长字符串、数组）很容易导致内存还有不少空间就提前触发GC，所以可以直接在老年代分配<br> （3）长期存活的对象将进入老年代<br> 每个对象有一个对象年龄计数器（经过的GC次数，仍存活），当这个年龄到达一定的次数（默认15），这个对象就进入老年代<br> （4）动态对象年龄判定<br> 如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须达到最大限制次数（比如年龄为5，但是有多个，并且占用内存很大，它们的总和大于了Survivor的一半，那么它们中大于或等于5的都可以直接进入老年代）<br> （5）控件分配担保<br> 在新生代GC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么新生代GC是安全的，如果不成立，虚拟机会查看是否允许担保失败。如果允许，就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次新生代GC，如果小于，则不允许冒险，就进行一次老年代GC（Full GC）</p></li><li><p>对 Dalvik、ART 虚拟机有基本的了解；<br> Dalvik虚拟机执行的是dex字节码，是安卓中使用的虚拟机，所有安卓程序都运行在安卓系统进程里，每个进程对应着一个Dalvik虚拟机实例，应用每次运行的时候，字节码都需要通过即时编译器（JIT）转换为本地机器码</p><p> ART虚拟机执行的是本地机器码，从 Android L 开始引入，应用在第一次安装的时候，会使用设备上的dex2oat工具进行字节码转码，把字节码预先编译成本地机器码，使其成为真正的本地应用（这个过程叫做预编译），加快了启动速度，但相对安装时间加长，安装所需空间增大</p><p> ART取代了Dalvik</p><p> <a href="https://blog.csdn.net/jason0539/article/details/50440669" target="_blank" rel="noopener">JAVA虚拟机、Dalvik虚拟机和ART虚拟机简要对比</a><br> <a href="https://www.jianshu.com/p/a8cc7a92137c" target="_blank" rel="noopener">JVM、Dalvik、ART 介绍</a></p></li><li><p>类加载机制<br> 加载、验证、准备、解析、初始化、使用、卸载<br> 其中验证、准备、解析三个阶段又统称为连接阶段，加载、验证、准备、初始化、卸载5个阶段的顺序是确定的</p></li><li><p>双亲委派模型<br> 类加载器之间的层次模型就是双亲委派模型，除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器</p></li><li><p>垃圾收集机制 对象创建，新生代与老年代<br> 通过可达性分析算法判断一个对象是否真的已死（经过两次标记后），确定后就会GC<br> 对象主要分配在新生代的Eden区上，如果有本地线程缓冲，将按线程优先在TLAB上分配，少数情况可能会直接分配在老年代中，如果遇到大对象（长字符串、数组等）会直接分配进入老年代</p></li><li><p>JVM内存模型，内存区域<br> Java内存模型规定了所有的变量都存储在主内存，每条线程有自己的工作内存（有点类似于高速缓存），线程的工作内存中保存了被该线程使用到的变量的内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接操作主内存中的。不同线程间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。<br> <a href="https://upload-images.jianshu.io/upload_images/4061843-43ba39b5231dc50e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-43ba39b5231dc50e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java内存模型"></a>Java内存模型</p><p> <a href="https://upload-images.jianshu.io/upload_images/4061843-15cbe9a02edba4e4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-15cbe9a02edba4e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java虚拟机运行时数据区"></a>Java虚拟机运行时数据区</p></li><li><p>强引用置为null，会不会被回收？<br> 不会，显式地设置为null，GC会认为该对象不存在，就可以被回收</p></li><li><p>Java中内存区域与垃圾回收机制<br> <a href="https://upload-images.jianshu.io/upload_images/4061843-15cbe9a02edba4e4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-15cbe9a02edba4e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java虚拟机运行时数据区"></a>Java虚拟机运行时数据区</p><p> GC机制：<br> （1）判断对象已死：通过可达性分析，两次标记后判定为对象已死<br> （2）GC收集算法：通过收集算来来回收内存空间，现在常用分代收集算法<br> （3）内存分配：内存分配的策略对回收也很重要</p><p> <a href="https://blog.csdn.net/justloveyou_/article/details/71216049" target="_blank" rel="noopener">图解Java 垃圾回收机制</a></p></li><li><p>垃圾回收机制与调用System.gc()区别<br> 垃圾回收机制是到达安全点或安全域然后自动触发一次GC回收，当内存不足或应用程序空闲时也会触发一次GC，调用System.gc()是手动触发强制GC回收</p></li><li><p>解释一下栈帧<br>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，就是虚拟机运行时数据区中的虚拟机栈的栈元素</p><p>栈帧存储了方法的局部变量表、操作数栈、动态连接、方法返回地址等信息<br>在活动线程中，只有位于栈顶的栈帧才是有效的，成为当前栈帧，与这个栈帧相关联的方法称为当前方法。所有字节码指令都只针对当前栈帧进行操作<br><a href="https://upload-images.jianshu.io/upload_images/4061843-4659287409b6321f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-4659287409b6321f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈帧结构概念图"></a>栈帧结构概念图</p></li><li><p>Android中弱引用与软引用的应用场景<br>弱引用：当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。这个引用不会在对象的垃圾回收判断中产生任何附加的影响。比如说Thread中保存的ThreadLocal的全局映射，因为我们的Thread不想在ThreadLocal生命周期结束后还对其造成影响，所以应该使用弱引用</p><p>软引用：例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢</p></li><li><p>SOF你遇到过哪些情况。 (JVM)<br>StackOverflowError，程序中一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过默认大小而导致溢出。</p><p>栈溢出的原因：<br>递归调用<br>大量循环或死循环<br>全局变量是否过多<br>数组、List、map数据过</p></li><li><p>对象创建方法，对象的内存分配，对象的访问定位<br>对象创建方法：<br>（1）当遇到一个new指令时，虚拟机首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过。如果没有，就会先进行类加载。<br>（2）当类加载检查通过后，就开始为新生对象分配内存。对象所需的内存大小在类加载完成后就完全确定。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<br>（3）分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）<br>（4）接着，虚拟机对对象进行必要的设置：配置对象头，例如这个对象是哪个类的实例、如何找到类的元数据、对象的哈戏码、对象的GC分代年龄，是否使用对象锁<br>（5）此时从虚拟机来说，一个新对象就产生了，从Java程序来说，才刚刚开始，因为&lt;init&gt;方法还没有执行，所有的字段都为0</p><p>对象的内存分配：<br>（1）对象头（Header）<br>对象头包含两部分信息：第一部分用于存储对象自身的运行时数据，如哈戏码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit。另一部分是类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个的实例</p><p>（2）实例数据（Instance Data）<br>对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段的内容，包括父类继承、子类定义的。<br>（3）对齐填充（Padding）<br>不一定存在，没有特别含义，仅仅是占位符的作用</p><p>对象的访问定位：<br>（1）使用句柄访问<br>Java虚拟对中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息<br><a href="https://upload-images.jianshu.io/upload_images/4061843-09b108809fe65ab1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-09b108809fe65ab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="句柄访问"></a>句柄访问</p><p>（2）直接指针访问<br>reference中存储的直接就是对象的地址<br><a href="https://upload-images.jianshu.io/upload_images/4061843-3be01a80907ff6fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-3be01a80907ff6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="指针访问"></a>指针访问</p></li><li><p>GC收集器有哪些？CMS收集器与G1收集器的特点</p><ul><li>Serial收集器<br>  单线程的收集器，只会使用一个CPU或一条收集线程去GC，并且在进行GC时必须暂停其他所有的工作线程，知道GC结束<br>  在Client模式下默认新生代收集器</li><li>ParNew收集器<br>  是Serial收集器的多线程版本，使用多条线程进行GC，除此外并无啥区别<br>  在Server模式下是首选的新生代收集器，因为只有它能和CMS配合工作</li><li>Parallel Scavenge收集器<br>  一个新生代收集器，使用复制算法，并行的多线程收集器<br>  也称为“吞吐量优先”收集器，因为它的目标就是达到一个可控制的吞吐量</li><li>Serial Old收集器<br>  Serial的老年代收集器，单线程，使用“标记-整理”算法</li><li>Parallel Old收集器<br>  Parallel Scavenge的老年代收集器，使用多线程和“标记-整理”算法</li><li>CMS收集器<br>  一种以最短回收停顿时间为目标的收集器，GC过程是与用户线程一起并发执行的，使用“标记-清除”算法<br>  缺点：<br>  （1）对CPU资源非常敏感<br>  （2）无法处理浮动垃圾：标记过后，GC无法在当次回收的的就是浮动垃圾<br>  （3）采用“标记-清除”会导致大量的空间碎片</li><li>G1收集器<br>  面向服务端的垃圾收集器，最牛逼的一个（未来），将内存化整为零<br>  特点：<br>  （1）并行与并发：充分利用多CPU、多核，来缩短停顿时间<br>  （2）分代收集<br>  （3）空间整合：G1整体看似基于“标记-整理”，但在局部是基于“复制”算法，不会留下空间碎片<br>  （4）可停顿的预测</li></ul></li><li><p>Minor GC与Full GC分别在什么时候发生？<br>Eden区分配内存不足时会触发Minor GC<br>在新生代GC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么新生代GC是安全的，如果不成立，虚拟机会查看是否允许担保失败。如果允许，就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次新生代GC，如果小于，则不允许冒险，就进行一次老年代GC（Full GC）</p></li><li><p>分派：静态分派与动态分派<br>静态分派：<br>依赖于静态类型来定位方法执行版本的分派动作叫静态分派</p><p>典型应用：方法重载，具体调用哪个方法取决于参数参数的数量和数据类型<br>虚拟机在重载时是通过参数的静态类型（静态类型在编译时可知）而不是实际类型作为判断依据来决定使用哪个方法，这里的选择只是最优的，如果没有就会选择次优的（如果没有最优匹配，注意自动转换、自动装箱）</p><p>动态分派：<br>在运行期根据实例类型确定方法执行版本的动作叫做动态分派</p><p>典型应用：重写，调用父类还是子类的方法取决于调用者的实例类型<br>实例类型只有运行期才能确定</p></li><li><p>java内存模型，五个部分，程序计数器、栈、本地栈、堆、方法区。每个部分的概念、特点、作用。<br><a href="https://upload-images.jianshu.io/upload_images/4061843-15cbe9a02edba4e4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-15cbe9a02edba4e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java虚拟机运行时数据区"></a>Java虚拟机运行时数据区</p><ul><li><p><strong>程序计数器</strong><br>  是一块较小、线程私有的的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p><p>  如果线程正在执行的是一个Java方法，计数器记录的就是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，计数器就为空值</p><p>  这个内存区域是唯一一个在Java虚拟机规范中没有规定OutOfMemoryError的情况</p></li><li><p><strong>Java虚拟机栈</strong><br>  线程私有的内存空间，生命周期与线程相同。</p><p>  描述的是Java方法（字节码）执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成对应着一个栈帧在虚拟机栈中入栈到出站的过程</p><p>  其中局部变量表部分存放了编译器可知的各种基本数据类型、对象引用（reference类型）、returnAddress类型（指向了一条字节码指令的地址）。这些都是所执行的方法中所持有的。基本数据类型中的long和double类型的数据会占用2个局部变量空间（Slot），其余的占用1个。<br>  局部变量表的内存空间是在编译期间完成分配，方法运行期间不会改变其大小</p><p>  这个内存区域有两种异常情况：<br>  （1）StackOverflowError：如果线程请求的栈深度大于了虚拟机所允许的深度，将抛出此异常（特别是递归）<br>  （2）OutOfMemoryError：如果虚拟机可以动态扩展，当扩展时无法申请到足够的内存</p></li><li><p><strong>本地方法栈</strong><br>  作用与虚拟机栈类似，不过虚拟机栈是虚拟机执行Java方法的服务，而本地方法栈是为虚拟机使用的Native方法服务。在规范中并没有强制规定本地方法栈中方法使用的语言、使用方式和数据结构等，可以任意实现</p><p>  这个内存区域有两种异常情况：（与虚拟机栈差不多）<br>  （1）StackOverflowError：<br>  （2）OutOfMemoryError：</p></li><li><p><strong>Java堆</strong><br>  Java堆算是虚拟机中内存最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建</p><p>  唯一目的就是存放对象的实例，几乎所有的对象实例在这分配内存</p><p>  Java堆是垃圾收集器管理的主要区域，因此也可以称之为GC堆。从回收的角度看，Java堆还可以细分为新生代和老年代，再细致一点可以分为Eden空间、From Survivor空间、To Survivor空间等。从内存分配角度，可以划分出多个线程私有的分配缓冲区（TLAB）</p><p>  有一种异常情况：<br>  OutOfMemoryError：当堆中没有内存完成实例分配且堆无法扩展时，抛出</p></li><li><p><strong>方法区</strong><br>  与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机记载的类信息、常量、静态常量、即时编译器编译后的代码等数据</p><p>  在虚拟机规范中这是Java堆的一个逻辑部分，但也叫Non-Heap（非堆）。</p><p>  一种异常情况：<br>  OutOfMemoryError：当方法区无法满足内存分配需求时，抛出</p></li><li><p><strong>运行时常量池</strong><br>  是方法区的一部分，用于存放类加载后进入方法区的Class文件中的常量池信息，存放了编译器生成的各种字面量和符号引用</p><p>  一种异常情况：<br>  OutOfMemoryError：当常量池无法再申请到内存时，抛出</p></li></ul></li><li><p>类加载的过程，加载、验证、准备、解析、初始化。每个部分详细描述。</p><ul><li><p>加载</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><p> 非数组类的加载（获取类的二进制字节流的动作）可以使用系统提供的引导类加载器来完成，也可以通过用于自定义的类加载器完成</p><p> 数组类由虚拟机直接创建的，不通过加载器，创建遵循规则：<br> （1）如果数组的组件类型（去掉一个维度的类型）是引用类型（如MyClass[]），那就递归采用加载器去加载，数组类将在加载该组件类型的类加载器的类名称空间上被标识<br> （2）如果数组的组件类型不是引用类型（如int[]），Java虚拟机会把这个数组类标记为与引导类加载器关联<br> （3）数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，可见性则默认public</p><p> 加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区的外部接口</p><p> 加载阶段和连接阶段是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始</p></li></ol></li><li><p>验证<br>  验证是连接的第一步，确保Class文件的字节流中包含的信息符号当前虚拟机的要求且不会危害虚拟机自身的安全</p><ol><li>文件格式验证<br> 验证字节流是否符合Class文件格式的规范，且能被当前虚拟机处理</li><li>元数据验证<br> 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范</li><li>字节码验证<br> 是整个验证过程最复杂的阶段，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的<br> 如果一个类方法体的字节码没有通过字节码验证，那肯定有问题，但如果通过了，也不能说明一定安全</li><li>符号引用验证<br> 在虚拟机将符号引用转化为直接引用的时候验证，这个转化动作在连接的第三阶段——解析阶段发生<br> 是对类自身以外的信息进行匹配性校验</li></ol></li><li><p>准备<br>  正式为类变量分配内存并设置类变量初始值的阶段，在方法区中进行内存分配。<br>  进行分配的仅包括类变量（static修饰的变量）而不包括实例变量，实例变量将会在对象实例化时伴随对戏那个一起分配在堆中，这里的初值是数据类型的零值。<br>  如果类字段的字段属性表中存在ConstantValue属性，那就在这个阶段进行初始化赋值，如<code>public static final int value = 123;</code>就会在准备阶段直接赋值为123而不是零值</p></li><li><p>解析<br>  虚拟机将常量池内的符号引用替换为直接引用的过程<br>  符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量。引用的目标不一定已经加载到内存中<br>  直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</p><p>  主要针对以下符号引用解析：</p><ol><li><p>类或接口的解析<br> 假设当前代码所处的类为D，符号引用N解析为一个类或接口C的直接引用；<br> （1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载C<br> （2）如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“|[Ljava/land/Integer”的形式，就会按照（1）加载数组元素类型；如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象<br> （3）如果（1）（2）没有任何异常，那么C在虚拟机中实际上就是一个类或接口了，但在解析完成之前之前还要进行符号引用验证，确认D是否具备对C的访问权限</p></li><li><p>字段解析<br> 首先将对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用，C解析成功后，对C后续字段的搜索<br> （1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束<br> （2）否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束<br> （3）否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束<br> （4）否则查找失败</p><p> 查找过程成功返回了引用后，还将对这个字段进行权限验证</p></li><li><p>类方法解析<br> 第一个步骤与字段解析的第一个步骤一样，也需要先解析出方法表类的class_index项中索引的方法所属的类或接口的符号引用，解析成功后进行类方法搜索<br> （1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就抛出异常<br> （2）如果通过了（1），在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束<br> （3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束<br> （4）否则，在类C实现的接口列表及它们的父接口中递归查找是否有简单名称和描述符都与目标想匹配的方法，如果存在，则说明类C是一个抽象类，查找结束，抛出异常<br> （5）否则，宣告方法查找失败，抛出异常</p></li><li><p>接口方法解析<br> 先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，进行后续的接口方法搜索<br> （1）如果在接口方法表中发现class_index中的索引C是个类不是接口，直接抛出异常<br> （2）否则，在接口C中查找是否有简单名称和符号引用都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束<br> （3）否则，在接口C的父接口中递归查找，知道java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束<br> （4）否则，宣告查找失败</p></li></ol></li><li><p>初始化<br>  类加载过程的最后一步。<br>  在这个阶段，根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，初始化阶段是执行类构造器&lt;clinit&gt;()方法（不是实例构造器，平时所说的是实例构造器）的过程</p><p>  &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量前面的静态语句块可以赋值但不能访问</p><p>  &lt;clinit&gt;()方法与类的构造函数（类的实例构造函数&lt;init&gt;）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法执行完毕，因此虚拟机上第一个执行的类是Object</p><p>  &lt;clinit&gt;()方法对类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产&lt;clinit&gt;()</p><p>  接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口和类一样都会生成&lt;clinit&gt;()方法，但执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法，只有当父接口中定一个的变量使用时，父接口才会初始化。接口的实现类在初始化的时候也一样不会执行接口的&lt;clinit&gt;()方法</p><p>  虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地枷锁、同步，如果多个线程同时初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，知道活动线程执行&lt;clinit&gt;()方法完毕</p></li></ul></li><li><p>加载阶段读入.class文件，class文件是二进制吗，为什么需要使用二进制的方式？<br>是二进制字节流流，至于为什么，应该二进制是机器码，相对于其他格式效率更高速度更快</p></li><li><p>验证过程是防止什么问题？验证过程是怎样的？加载和验证的执行顺序？符号引用的含义？<br>确保Class文件的字节流中包含的信息符号当前虚拟机的要求且不会危害虚拟机自身的安全</p><p>（1）文件格式验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">验证字节流是否符合Class文件格式的规范，且能被当前虚拟机处理</span><br></pre></td></tr></table></figure><p>（2）元数据验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范</span><br></pre></td></tr></table></figure><p>（3）字节码验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是整个验证过程最复杂的阶段，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的  </span><br><span class="line">如果一个类方法体的字节码没有通过字节码验证，那肯定有问题，但如果通过了，也不能说明一定安全</span><br></pre></td></tr></table></figure><p>（4）符号引用验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在虚拟机将符号引用转化为直接引用的时候验证，这个转化动作在连接的第三阶段——解析阶段发生  </span><br><span class="line">是对类自身以外的信息进行匹配性校验</span><br></pre></td></tr></table></figure><p>加载和验证是交互进行的</p><p>符号引用的含义：以一组符号来描述所引用的目标，符号可以是任何形式的字面量。引用的目标不一定已经加载到内存中，编译原理概念，包括：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p></li><li><p>准备过程的静态成员变量分配空间和设置初始值问题。<br>进行分配的仅包括类变量（static修饰的变量）而不包括实例变量，实例变量将会在对象实例化时伴随对戏那个一起分配在堆中，这里的初值是数据类型的零值。<br>如果类字段的字段属性表中存在ConstantValue属性，那就在这个阶段进行初始化赋值，如<code>public static final int value = 123;</code>就会在准备阶段直接赋值为123而不是零值</p></li><li><p>解析过程符号引用替代为直接引用细节相关。<br>主要针对以下符号引用解析：</p><ol><li><p>类或接口的解析<br> 假设当前代码所处的类为D，符号引用N解析为一个类或接口C的直接引用；<br> （1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载C<br> （2）如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“|[Ljava/land/Integer”的形式，就会按照（1）加载数组元素类型；如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象<br> （3）如果（1）（2）没有任何异常，那么C在虚拟机中实际上就是一个类或接口了，但在解析完成之前之前还要进行符号引用验证，确认D是否具备对C的访问权限</p></li><li><p>字段解析<br> 首先将对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用，C解析成功后，对C后续字段的搜索<br> （1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束<br> （2）否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束<br> （3）否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束<br> （4）否则查找失败</p><p> 查找过程成功返回了引用后，还将对这个字段进行权限验证</p></li><li><p>类方法解析<br> 第一个步骤与字段解析的第一个步骤一样，也需要先解析出方法表类的class_index项中索引的方法所属的类或接口的符号引用，解析成功后进行类方法搜索<br> （1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就抛出异常<br> （2）如果通过了（1），在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束<br> （3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束<br> （4）否则，在类C实现的接口列表及它们的父接口中递归查找是否有简单名称和描述符都与目标想匹配的方法，如果存在，则说明类C是一个抽象类，查找结束，抛出异常<br> （5）否则，宣告方法查找失败，抛出异常</p></li><li><p>接口方法解析<br> 先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，进行后续的接口方法搜索<br> （1）如果在接口方法表中发现class_index中的索引C是个类不是接口，直接抛出异常<br> （2）否则，在接口C中查找是否有简单名称和符号引用都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束<br> （3）否则，在接口C的父接口中递归查找，知道java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回方法的直接引用，查找结束<br> （4）否则，宣告查找失败</p></li></ol></li><li><p>初始化过程jvm的显式初始化相关。<br>在这个阶段，根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，初始化阶段是执行类构造器&lt;clinit&gt;()方法（不是实例构造器，平时所说的是实例构造器）的过程</p><p>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量前面的静态语句块可以赋值但不能访问</p><p>&lt;clinit&gt;()方法与类的构造函数（类的实例构造函数&lt;init&gt;）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法执行完毕，因此虚拟机上第一个执行的类是Object</p><p>&lt;clinit&gt;()方法对类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产&lt;clinit&gt;()</p><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口和类一样都会生成&lt;clinit&gt;()方法，但执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法，只有当父接口中定一个的变量使用时，父接口才会初始化。接口的实现类在初始化的时候也一样不会执行接口的&lt;clinit&gt;()方法</p><p>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地枷锁、同步，如果多个线程同时初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，知道活动线程执行&lt;clinit&gt;()方法完毕</p></li><li><p>类卸载的过程及触发条件。<br>只有由用户自定义的类加载器加载的类是可以被卸载的。<br><a href="https://images0.cnblogs.com/i/325852/201403/111825528931093.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/325852/201403/111825528931093.png" alt="举个例子"></a>举个例子<br>loader1变量和obj变量间接应用代表Sample类的Class对象，而objClass变量则直接引用它。</p><p>如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期， MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。</p><p>当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载； 如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例(可以通过哈希码查看是否是同一个实例)</p><p>在类使用完之后，满足下面的情形，会被卸载：<br>（1）该类在堆中的所有实例都已被回收，即在堆中不存在该类的实例对象。<br>（2）加载该类的classLoader已经被回收。<br>（3）该类对应的Class对象没有任何地方可以被引用，通过反射访问不到该Class对象。<br>如果类满足卸载条件，JVM就在GC的时候，对类进行卸载，即在方法区清除类的信息。</p></li><li><p>三种类加载器，如何自定义一个类加载器？<br>（1）启动类加载器：负责将存放在&lt;JAVA_HOME&gt;\lib目录中的或者被-Xbootclasspath参数所指定的路径中的且是虚拟机识别的类库加载到虚拟机内存中。无法被Java程序直接引用<br>（2）扩展类加载器：负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的或者被java.ext.dirs系统变量所指定的路径中的所有类库。开发者可以直接使用<br>（3）应用程序类加载器：是ClassLoader的getSystemClassLoader()方法的返回值，一般也称为系统类加载器</p><p>自定义类加载器：自定义的ClassLoader继承自java.lang.ClassLoader并且只重写findClass方法</p><p><a href="https://www.cnblogs.com/xrq730/p/4847337.html" target="_blank" rel="noopener">自定义一个类加载器</a></p></li><li><p>JVM内存分配策略，优先放于eden区、动态对象年龄判断、分配担保策略等。</p><ul><li>对象优先在Eden分配<br>  大多数情况下，对象在新生代Eden区分配，当Eden不够时，会触发一次Minor GC（新生代GC），也可能直接将新对象直接分配到老年代</li><li>大对象直接进入老年代<br>  需要大量连续内存空间的Java对象（长字符串、数组）很容易导致内存还有不少空间就提前触发GC，所以可以直接在老年代分配</li><li>长期存活的对象将进入老年代<br>  每个对象有一个对象年龄计数器（经过的GC次数，仍存活），当这个年龄到达一定的次数（默认15），这个对象就进入老年代</li><li>动态对象年龄判定<br>  如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须达到最大限制次数（比如年龄为5，但是有多个，并且占用内存很大，它们的总和大于了Survivor的一半，那么它们中大于或等于5的都可以直接进入老年代）</li><li>控件分配担保<br>  在新生代GC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么新生代GC是安全的，如果不成立，虚拟机会查看是否允许担保失败。如果允许，就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次新生代GC，如果小于，则不允许冒险，就进行一次老年代GC（Full GC）</li></ul></li><li><p>四种垃圾回收算法标记-清除、复制、标记-整理、分代收集。<br>（1）标记-擦除：<br>分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象<br>标记过程就是对象判定死亡过程<br><a href="https://upload-images.jianshu.io/upload_images/4061843-46c2b3f0a1fb2c7b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-46c2b3f0a1fb2c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标记擦除算法"></a>标记擦除算法<br>（2）复制：<br>将内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完后，就将存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。<br>这样使得每一次都是对整个半区进行内存回收，内存分配时就不用考虑碎片的情况了，只要一动栈顶指正，按顺序分配即可<br><a href="https://upload-images.jianshu.io/upload_images/4061843-333edfae62095428.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-333edfae62095428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复制算法"></a>复制算法<br>（3）标记-整理：<br>针对老年代的算法，标记后，不是直接清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存<br><a href="https://upload-images.jianshu.io/upload_images/4061843-9a35d0b36faee56a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-9a35d0b36faee56a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标记整理算法"></a>标记整理算法<br>（4）分代收集：<br>根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后根据不同的特点采用最恰当的算法<br>新生代中采用复制算法，老年代中采用标记-清理或标记-整理算法</p></li><li><p>JVM中的垃圾回收器，新生代回收器、老年代回收器、stop-the-world概念及解决方法。<br>新生代收集器：Serial收集器、ParNew收集器、Parallel Scavenge收集器<br>老年代收集器：Serial Old收集器、Parallel Old收集器</p><p>stop-the-world：在可达性分析枚举根节点时，在整个分析期间整个执行系统看起来就像被冻结在某个时间点，不可以出现分析过程中对象引用关系还在不断变化的情况，导致GC进行时必须停顿所有的执行线程<br>这个是无法避免的，只有尽量减少停顿的时间，现在使用CMS收集器采用并发，所以用户感觉不到这个停顿</p></li><li><p>java虚拟机的特性<br>特点：<br>java语言的重要特点是与平台无关性，java虚拟机是实现这一特点的关键。</p><p>对比高级语言<br>一般高级语言要想在不同平台运行，至少需要生成不同目标代码。而java虚拟机屏蔽了与具体系统平台信息，只要编译生成在java虚拟机运行的字节码，就可以在多种平台运行，不需要重复编译。</p><p>解释字节码<br>java虚拟机在执行字节码时，把字节码解释成具体平台的机器指令执行。</p></li><li><p>JVM的引用树，什么变量能作为GCRoot?GC垃圾回收的几种方法<br>通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索的路径成为引用链，当一个对象到GC Roots对象没有任何引用链相连，则说明此对象是不可用的<br><a href="https://upload-images.jianshu.io/upload_images/4061843-c17f6016a79cee8b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-c17f6016a79cee8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可达性分析算法"></a>可达性分析算法</p><p>Java语言中，可以作为GC Roots对象有：<br>（1）虚拟机栈中引用的对象<br>（2）方法区中类静态属性引用的对象<br>（3）方法区中常量引用的对象<br>（4）本地方法栈中JNI引用的对象</p><p>回收算法：标记-擦除、复制、标记-整理、分代收集</p></li><li><p>简述字节码文件的组成<br>任何一个Class文件都对应着唯一一个类或接口的定义信息，但类或接口不一定都得定义在文件里</p><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按顺序紧凑地排列在文件中，中间没有添加任何分隔符。当遇到占用8位字节以上空间的数据会按照高位在前的方式分割成若干个8位字节。包含了魔数、Class文件版本、常量池、访问标志、类索引、父类索引、接口索引集合、字段表集合、方法表集合、属性表集合</p></li><li><p>关于JAVA内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法<br>一个对象，两个属性，四个方法<br>只会在主内存中实例化对象，所有的变量都会存储在主内存中，其他工作线程的只会拷贝这些数据使用，且修改后要同步回来</p></li><li><p>GC内存泄露<br>判断对象是否可以回收，资源对象没关闭造成的内存泄露</p><p><a href="https://blog.csdn.net/zmissm/article/details/38725681" target="_blank" rel="noopener">android GC内存泄露问题</a><br><a href="https://blog.csdn.net/wfeii/article/details/60870233" target="_blank" rel="noopener">GC可达性实践-内存泄露分析</a></p></li><li><p>你能手动调用垃圾回收吗<br>可以，System.gc()</p></li><li><p>软引用、弱引用区别<br>弱引用的强度比软引用更弱一些，弱引用关联的对象只能生存到下一次GC之前，第二次一定会回收；软引用是将其列进第二次回收的范围中但不一定回收，当内存不足才会回收</p></li><li><p>java四中引用<br>强引用、软引用、弱引用、虚引用</p></li><li><p>Java对象的引用方法<br>四种引用：强引用、软引用、弱引用、虚引用</p></li><li><p>简单说说 Java 为什么需要不同的引用类型<br>Java 的内存回收是虚拟机垃圾回收器来主动触发的，我们基本无法直接像 C 语言一样控制内存的实时申请释放操作，而在 Java 中有时候我们需要适当的控制对象被回收的时机，所以就诞生了引用类型，可以认为不同引用类型的诞生实际是对 GC 回收时机不可控的一种矛盾妥协；譬如我们可以利用软引用和弱引用解决 OOM 问题，通过软引用实现 Java 对象的高速缓存（即我们创建一个类，如果每次频繁操作都重新构建一个实例就会引起大量对象的消耗和 GC，如果通过软引用和 HashMap 结合实现高速缓存就能显著提供性能）</p><p><a href="https://www.jianshu.com/p/a3754030f5c1" target="_blank" rel="noopener">Java 几种引用类型</a></p></li><li><p>简单说说 Java PhantomReference(虚引用/幽灵引用)的作用<br>Java 垃圾收集过程中对象的可触及状态改变时垃圾收集器会把要回收的对象添加到引用队列 ReferenceQueue，这样在可触及性发生变化的时候上层代码就能得到通知，因为在 Java 中 finalize 方法本来是用来在对象被回收的时候来做一些操作的，但是对象被 GC 垃圾收集器什么时候回收是不固定的，所以 finalize 方法就很尴尬，故虚引用就可以解决这个问题，虚引用的作用就是在 GC 要回收时 GC 收集器把这个对象添加到 ReferenceQueue 中，这样我们如果检测到 ReferenceQueue 中有我们感兴趣的对象时则说明 GC 将要回收这个对象了，此时我们可以在 GC 回收之前做一些其他事情</p></li><li><p>Class文件结构</p><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u4</td><td align="center">magic</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">minor_version</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">major_version</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">constant_pool_count</td><td align="center">1</td></tr><tr><td align="center">cp_info</td><td align="center">constant_pool</td><td align="center">constant_pool_count - 1</td></tr><tr><td align="center">u2</td><td align="center">access_flags</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">this_class</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">super_class</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">interfaces_count</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">interfaces</td><td align="center">interfaces_count</td></tr><tr><td align="center">u2</td><td align="center">fields_count</td><td align="center">1</td></tr><tr><td align="center">field_info</td><td align="center">fields</td><td align="center">fields_count</td></tr><tr><td align="center">u2</td><td align="center">methods_count</td><td align="center">1</td></tr><tr><td align="center">method_info</td><td align="center">methods</td><td align="center">methods_count</td></tr><tr><td align="center">u2</td><td align="center">attributes_count</td><td align="center">1</td></tr><tr><td align="center">attribute_info</td><td align="center">attributes</td><td align="center">attributes_count</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>如果想不被 GC 怎么办<br>保持与GC Root保持引用链</p></li><li><p>java内存模型、导致线程不安全的原因。及操作，原子性可见性和有序性等。<br>当无法保证操作变量的原子性、可见性、有序性等，容易导致线程不安全</p><p>原子性：<br>Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write，大致可以认为基本数据类型的访问读写具有原子性，lock、unlock也是，synchronized也具有原子性</p><p>可见性：<br>当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。<br>Java内存模型通过变量修改后同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现<br>volatile、synchronized、final都可以实现可见性</p><p>有序性：<br>Java提供了volatile（本身禁止指令重排序）和synchronized（一个变量在同一时刻只允许一条线程对其进行lock操作）来保证线程间操作的有序性</p></li><li><p>描述一下进程回收的过程<br>Android进程与Linux进程根据OOM_ADJ阈值进行区分，当Android系统察觉设备内存不足时，会按照阈值从大到小杀死进程</p><p>（1）首先移除package被移走的无用进程.<br>（2）基于进程当前状态,更新oom_adj值,然后进行以下操作.<br>移除没有activity在运行的进程<br>如果AP已经保存了所有的activity状态,结束这个AP.<br>（3）最后,如果目前还是有很多activities 在运行,那么移除那些activity状态已经保存好的activity.<br>当系统内存短缺时Android的Low Memory Killer根据需要杀死进程释放其内存</p></li><li><p>为什么现在流行分代？好处和优势在哪里？<br>降低单次GC的时间长度，、提高GC的工作效率。内存管理可以以尽可能小的计算代价（20%）来维持内存的低碎片化（80% goal），尽量推迟要消耗更大的计算（80%）来整理最后那一点碎片问题（20%，因为老生代相对比较稳定）</p><p>（1）分代回收可以对堆中对象采用不同的gc策略。在实际程序中，对象的生命周期有长有短。进行分代垃圾回收，能针对这个特点做很好的优化<br>（2）分代以后，gc时进行可达性分析的范围能大大降低</p></li><li><p>简单说说 dexopt 与 dex2oat 的区别(JVM)<br><a href="http://mmbiz.qpic.cn/mmbiz_png/iarMRfJHmKibXpd0BeaonPXb54EicnNuu6icCgIB1hyvMssD3plNX68qEVkXP5dlnDmSmGoxN2cPyvL6Lpg6iceRjGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1" target="_blank" rel="noopener"><img src="http://mmbiz.qpic.cn/mmbiz_png/iarMRfJHmKibXpd0BeaonPXb54EicnNuu6icCgIB1hyvMssD3plNX68qEVkXP5dlnDmSmGoxN2cPyvL6Lpg6iceRjGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1" alt="jvm"></a>jvm<br>通过上图可以很明显的看出 dexopt 与 dex2oat 的区别，前者针对 Dalvik 虚拟机，后者针对 Art 虚拟机。</p><p>dexopt 是对 dex 文件 进行 verification 和 optimization 的操作，其对 dex 文件的优化结果变成了 odex 文件，这个文件和 dex 文件很像，只是使用了一些优化操作码（譬如优化调用虚拟指令等）。</p><p>dex2oat 是对 dex 文件的 AOT 提前编译操作，其需要一个 dex 文件，然后对其进行编译，结果是一个本地可执行的 ELF 文件，可以直接被本地处理器执行。</p><p>除此之外在上图还可以看到 Dalvik 虚拟机中有使用 JIT 编译器，也就是说其也能将程序运行的热点 java 字节码编译成本地 code 执行。所以其与 Art 虚拟机还是有区别的，Art 虚拟机的 dex2oat 是提前编译所有 dex 字节码，而 Dalvik 虚拟机只编译使用启发式检测中最频繁执行的热点字节码</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android实现滑动返回的几种方法总结</title>
      <link href="/2020/02/07/Android%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Android%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="关于Android实现滑动返回的几种方法总结"><a href="#关于Android实现滑动返回的几种方法总结" class="headerlink" title="关于Android实现滑动返回的几种方法总结"></a>关于Android实现滑动返回的几种方法总结</h1><p>标签（空格分隔）： 此博客若要转载，请注明出处</p><hr><p>关于Android实现滑动返回的方法，网上有很多种，实现的方式也都各不一样。有用SwipeBackLayout开源库的，有用SlidingPaneLayout控件的，有通过使用GestureDetector手势识别的类的，也有写一个基类的，还有一些其他的实现方法。总之，实现滑动返回的方法各种各样，但同样也各有千秋。在这里，我主要对以下几种方法进行了学习，并一一实现。（注意：我这次Demo是在MaterialsDesign的基础上进行编写代码的，不过这并不影响这几种方法的实现，你可以到这个地址下载源代码进行查看学习：<a href="https://github.com/PengHesheng/ToolBar-BackActivity" target="_blank" rel="noopener">https://github.com/PengHesheng/ToolBar-BackActivity</a>）</p><ul><li>SwipeBackLayout开源库</li><li>GestureDetector</li><li>SlidingPaneLayout</li></ul><hr><p>在这里先声明一下，由于有些方法需要重新设置style，对theme的要求也不尽相同，我在Demo中统一使用了下面一个Theme，所以讲解方法的开始，我先把要新建的style/theme的代码贴出来，还有滑动返回的其中一种动画的设置也贴出来，当然，这主题的设置和动画的设置是在网上找的，在博客的最后我会贴出相关的博客</p><p>style</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">         <span class="comment">&lt;!--Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--新建一个主题，设置为透明样式，保证滑动的时候能看到下面的Activity--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"JK.SwipeBack.Transparent.Theme"</span> <span class="attr">parent</span>=<span class="string">"AppTheme"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsTranslucent"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowAnimationStyle"</span>&gt;</span>@style/JK.Animation.SlidingBack<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:actionBarStyle"</span>&gt;</span>@style/JKActionBar.Custom<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"JKActionBar.Custom"</span> <span class="attr">parent</span>=<span class="string">"@style/Widget.AppCompat.Light.ActionBar.Solid.Inverse"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"displayOptions"</span>&gt;</span>showCustom<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"background"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:displayOptions"</span> <span class="attr">tools:ignore</span>=<span class="string">"NewApi"</span>&gt;</span>showCustom<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:height"</span>&gt;</span>?actionBarSize<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"JK.Animation.SlidingBack"</span> <span class="attr">parent</span>=<span class="string">"@android:style/Animation.Activity"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:activityOpenEnterAnimation"</span>&gt;</span>@anim/in_from_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:activityOpenExitAnimation"</span>&gt;</span>@anim/out_to_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:activityCloseEnterAnimation"</span>&gt;</span>@anim/in_from_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:activityCloseExitAnimation"</span>&gt;</span>@anim/out_to_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:wallpaperOpenEnterAnimation"</span>&gt;</span>@anim/in_from_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:wallpaperOpenExitAnimation"</span>&gt;</span>@anim/out_to_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:wallpaperCloseEnterAnimation"</span>&gt;</span>@anim/in_from_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:wallpaperCloseExitAnimation"</span>&gt;</span>@anim/out_to_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:wallpaperIntraOpenEnterAnimation"</span>&gt;</span>@anim/in_from_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:wallpaperIntraOpenExitAnimation"</span>&gt;</span>@anim/out_to_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:wallpaperIntraCloseEnterAnimation"</span>&gt;</span>@anim/in_from_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:wallpaperIntraCloseExitAnimation"</span>&gt;</span>@anim/out_to_right<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>滑动返回的动画设置</p><p>in_form_left：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"400"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXDelta</span>=<span class="string">"100%p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXDelta</span>=<span class="string">"0%p"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>in_from_right：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:shareInterpolator</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:zAdjustment</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">"100.0%p"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">"0.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>out_to_left：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"400"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">"0%p"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">"-100%p"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>out_to_right：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:shareInterpolator</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:zAdjustment</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">"100.0%p"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="SwipeBackLayout"><a href="#SwipeBackLayout" class="headerlink" title="SwipeBackLayout"></a><a href="https://github.com/liuguangqiang/SwipeBack" target="_blank" rel="noopener">SwipeBackLayout</a></h2><p>效果图：（为设置为透明和没有设置为透明）</p><p><a href="http://ojplrudb4.bkt.clouddn.com/SwipeBackLayout.gif" target="_blank" rel="noopener"><img src="http://ojplrudb4.bkt.clouddn.com/SwipeBackLayout.gif" alt="此处输入图片的描述"></a>此处输入图片的描述</p><p>这个开源库的讲解我就不必要过多的陈述，在这里我只提一部分实现时需要注意的事项以及我踩到的坑，想详细了解的，直接到<a href="https://github.com/liuguangqiang/SwipeBack" target="_blank" rel="noopener">SwipeBackLayout</a>开源库查看代码和详解。也可看一下这篇博客<a href="http://skykai521.github.io/2016/03/04/SwipeBackLayout源代码分析/" target="_blank" rel="noopener">SwipeBackLayout源代码分析</a>。</p><p><strong>原理：</strong>这种实现的重点在于将Activity的属性设置为透明的，然后上方的Activity就可以在跟随手指移动时候放一个半透明的层表示那种渐变的阴影效果，全部滑动完成后再把上方Activity销毁掉。<br>向右滑动销毁（finish）Activity。</p><p><strong>注意：</strong>由于设置为了全透明，所以当我使用4.0.3版本进行开发的时候，由于活动默认的是白色的，所以当我继承这个类时，运行后的结果效果不太好，在新建的活动中能看见上一个活动的布局，这个体验感非常差，在后面的调试中，发现只要把新建的活动设置一个其他颜色的背景就行了，比如我设置为了gray，这样就没有了那个BUG。我们现在主要讨论的是向右滑动返回，所以在继承该类的时候，一定要有setDragEdge(SwipeBackLayout.DragEdge.LEFT); 这一行代码，原因代码中也说了。</p><p>在这里，我们需要先导入<a href="https://github.com/liuguangqiang/SwipeBack" target="_blank" rel="noopener">SwipeBackLayout</a>开源库，最新版本在开源库上自行查看，我得Demo用的是<code>compile &#39;com.github.liuguangqiang.swipeback:library:1.0.2@aar&#39;</code>，导入成功后直接在你需要用到滑动返回的Activity继承SwipeBackActivity就行了，在这里还需要注意的是Activity的属性设置为透明的，就跟前面的原理一样，这里是需要着重注意的，在后面几个方法中，这一点同样很重要，几乎所有的方法都需要设置一下Activity的属性。</p><p>实现时如代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hp.toolbartest.Activity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.design.widget.CollapsingToolbarLayout;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.ActionBar;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.Toolbar;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.Glide;</span><br><span class="line"><span class="keyword">import</span> com.example.hp.toolbartest.R;</span><br><span class="line"><span class="keyword">import</span> com.liuguangqiang.swipeback.SwipeBackActivity;</span><br><span class="line"><span class="keyword">import</span> com.liuguangqiang.swipeback.SwipeBackLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitActivity</span> <span class="keyword">extends</span> <span class="title">SwipeBackActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FRUIT_NAME = <span class="string">"fruit_name"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FRUIT_IMAGE_ID = <span class="string">"fruit_image_id"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_fruit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于设置向右滑动为返回，该库默认是向上滑动为返回</span></span><br><span class="line">        setDragEdge(SwipeBackLayout.DragEdge.LEFT);</span><br><span class="line"></span><br><span class="line">        Intent intent = getIntent();</span><br><span class="line">        String fruitName = intent.getStringExtra(FRUIT_NAME);</span><br><span class="line">        <span class="keyword">int</span> fruitImageId = intent.getIntExtra(FRUIT_IMAGE_ID, <span class="number">0</span>);</span><br><span class="line">        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar1);</span><br><span class="line">        CollapsingToolbarLayout collapsingToolbarLayout = (CollapsingToolbarLayout)</span><br><span class="line">                findViewById(R.id.collapsing_toolbar);</span><br><span class="line">        ImageView fruitImageView = (ImageView) findViewById(R.id.fruit_image_view);</span><br><span class="line">        TextView fruitContentText = (TextView) findViewById(R.id.fruit_content_text);</span><br><span class="line">        setSupportActionBar(toolbar);</span><br><span class="line">        ActionBar actionBar = getSupportActionBar();</span><br><span class="line">        <span class="keyword">if</span> (actionBar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        collapsingToolbarLayout.setTitle(fruitName);</span><br><span class="line">        Glide.with(<span class="keyword">this</span>).load(fruitImageId).into(fruitImageView);</span><br><span class="line">        String fruitContent = generateFruitContent(fruitName);</span><br><span class="line">        fruitContentText.setText(fruitContent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环生成一个字符串作为内容详解</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateFruitContent</span><span class="params">(String fruitName)</span> </span>&#123;</span><br><span class="line">        StringBuilder fruitContent = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500</span>; i++) &#123;</span><br><span class="line">            fruitContent.append(fruitName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fruitContent.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> android.R.id.home:</span><br><span class="line">                finish();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的关键就只有继承该类和设置一下滑动返回的方向，其他的是我ToolBar的代码的实现，与此次讨论无关。</p><hr><h2 id="利用GestureDetector类"><a href="#利用GestureDetector类" class="headerlink" title="利用GestureDetector类"></a>利用<a href="https://developer.android.google.cn/reference/android/view/GestureDetector.html" target="_blank" rel="noopener">GestureDetector</a>类</h2><p>效果图：</p><p><a href="http://ojplrudb4.bkt.clouddn.com/GestureBackActivity.gif" target="_blank" rel="noopener"><img src="http://ojplrudb4.bkt.clouddn.com/GestureBackActivity.gif" alt="此处输入图片的描述"></a>此处输入图片的描述</p><p>对于GestureDetector这个类，涉及的内容相对比较复杂一点，详细的了解就看官方文档<a href="https://developer.android.google.cn/reference/android/view/GestureDetector.html" target="_blank" rel="noopener">GestureDetector</a>。对于我们要如何实现滑动返回，我们首先需要建一个Activity的管理类AppManager，这样方便我们对Activity的生命周期进行管理，并安全退出，所以我们需要在主活动里对每启动一个Activity，就往AppManager里添加。<br>为了方便，同样构建了一个GestureBackActivity的基类，继承AppCompatActivity，重写AppCompatActivity的一些基本方法，然后重写dispatchTouchEvent事件机制，随着又写了手势监听器，用来监听滑动的手势，并重写GestureDetector.OnGestureListener，在重写的方法里面加入相应的逻辑处理，详细的解释我会写在代码里。多余的话就不用说了，直接给出代码。</p><p>MainActivity类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动活动时，添加到AppManager，并设置返回时的动画</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setClass(<span class="keyword">this</span>, cls);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">    overridePendingTransition(R.anim.in_from_left, R.anim.out_to_left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppManager类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个Activity管理类，对所有的Activity的生命周期进行管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Activity&gt; activityStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单一实例</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getAppManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加Activity到堆栈中</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activityStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">            activityStack = <span class="keyword">new</span> Stack&lt;Activity&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        activityStack.add(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前Activity（堆栈中最后压入的）</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">currentActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Activity activity = activityStack.lastElement();</span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束当前Activity（堆栈中最后压入的）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Activity activity = activityStack.lastElement();</span><br><span class="line">        finishActivity(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 结束指定的Activity</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishActivity</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activityStack.remove(activity);</span><br><span class="line">            activity.finish();</span><br><span class="line">            activity.overridePendingTransition(R.anim.in_from_right,</span><br><span class="line">                    R.anim.out_to_right);</span><br><span class="line">            activity = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 结束指定类名的Activity</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishActivity</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Activity activity : activityStack) &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity.getClass().equals(cls)) &#123;</span><br><span class="line">                finishActivity(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 结束所有Activity</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishAllActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, size = activityStack.size(); i&lt;size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != activityStack.get(i)) &#123;</span><br><span class="line">                activityStack.get(i).finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activityStack.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 彻底退出应用程序，安全退出</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppExit</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            finishAllActivity();</span><br><span class="line">            ActivityManager activityManager = (ActivityManager) context</span><br><span class="line">                    .getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">            activityManager.restartPackage(context.getPackageName());</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">            android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GestureBackActivity基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个手势滑动返回的基类，需要使用滑动返回的Activity只需继承该类就行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GestureBackActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GestureDetector myDectector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"GestureBackActivity"</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flingFinishEnabled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        initGestureDetector();</span><br><span class="line">        AppManager.getAppManager().addActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGestureDetector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (myDectector == <span class="keyword">null</span>) &#123;</span><br><span class="line">            myDectector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>, (GestureDetector.OnGestureListener) <span class="keyword">new</span> MyGestureListener());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flingFinishEnabled) &#123;</span><br><span class="line">            <span class="keyword">return</span> myDectector.onTouchEvent(ev) || <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手势监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGestureListener</span> <span class="keyword">implements</span> <span class="title">GestureDetector</span>.<span class="title">OnGestureListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Toast.makeText(getApplicationContext(),"down",Toast.LENGTH_SHORT).show();</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Toast.makeText(getApplicationContext(),"onSingleTapUp",Toast.LENGTH_SHORT).show();</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//对滑动距离的监听及判断</span></span><br><span class="line">            <span class="keyword">if</span> (e1.getX() - e2.getX() &gt; <span class="number">100</span> &amp;&amp; Math.abs(velocityX) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"向左滑动"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e2.getX() - e1.getX() &gt; <span class="number">100</span> &amp;&amp; Math.abs(velocityX) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"向右滑动"</span>);</span><br><span class="line">                AppManager.getAppManager().finishActivity();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式相对于SwipeBack来说相对较好一点，不需要更改布局的背景，不过我在一开始出现了闪屏的问题，原因目前我还没找到，有懂得大佬欢迎指教。</p><hr><h2 id="SlidingPaneLayout"><a href="#SlidingPaneLayout" class="headerlink" title="SlidingPaneLayout"></a><a href="https://developer.android.google.cn/reference/android/support/v4/widget/SlidingPaneLayout.html" target="_blank" rel="noopener">SlidingPaneLayout</a></h2><p>效果图：</p><p><a href="http://ojplrudb4.bkt.clouddn.com/SlidingPaneLayout.gif" target="_blank" rel="noopener"><img src="http://ojplrudb4.bkt.clouddn.com/SlidingPaneLayout.gif" alt="此处输入图片的描述"></a>此处输入图片的描述</p><p>相对于前面两种实现方式，我个人比较喜欢这一种，因为这一种方式并不是很复杂，而且效果相对是最好的一个，但是理解的难度相对要大一点，在我看来的话，不过也不是很难，都还是比较容易学的,先给出官方文档<a href="https://developer.android.google.cn/reference/android/support/v4/widget/SlidingPaneLayout.html" target="_blank" rel="noopener">SlidingPaneLayout</a>。这个基类BaseActivity是根据SlidingPaneLayout来构造的，当然也需要继承AppCompatActivity，这是当我们直接继承该类时所必须的。在initSwipeBackFinish()初始化时，通过反射机制来改变通过反射改变mOverhangSize的值为0，这个mOverhangSize值为菜单到右边屏幕的最短距离，默认是32dp，现在给它改成0，然后通过slidingPaneLayout来设置视图，下面直接上代码。</p><p>BaseActivity类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by HP on 2017/3/21.</span></span><br><span class="line"><span class="comment"> * 利用slidingPaneLayout构造一个基类，来实现滑动返回，继承该类，便可实现滑动返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">SlidingPaneLayout</span>.<span class="title">PanelSlideListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = BaseActivity.class.getCanonicalName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    FrameLayout mContainerFl;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        initSwipeBackFinish();</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化滑动返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSwipeBackFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSupportSwipeBack()) &#123;</span><br><span class="line">            SlidingPaneLayout slidingPaneLayout = <span class="keyword">new</span> SlidingPaneLayout(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//通过反射改变mOverhangSize的值为0，这个mOverhangSize值为菜单到右边屏幕的最短距离，默认</span></span><br><span class="line">            <span class="comment">//是32dp，现在给它改成0</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//mOverhangSize属性，意思就是左菜单离右边屏幕边缘的距离</span></span><br><span class="line">                Field f_overHang = SlidingPaneLayout.class.getDeclaredField(<span class="string">"mOverhangSize"</span>);</span><br><span class="line">                f_overHang.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//设置左菜单离右边屏幕边缘的距离为0，设置全屏</span></span><br><span class="line">                f_overHang.set(slidingPaneLayout, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            slidingPaneLayout.setPanelSlideListener(<span class="keyword">this</span>);</span><br><span class="line">            slidingPaneLayout.setSliderFadeColor(getResources().getColor(android.R.color.transparent));</span><br><span class="line">            <span class="comment">// 左侧的透明视图</span></span><br><span class="line">            View leftView = <span class="keyword">new</span> View(<span class="keyword">this</span>);</span><br><span class="line">            leftView.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));</span><br><span class="line">            slidingPaneLayout.addView(leftView, <span class="number">0</span>);  <span class="comment">//添加到SlidingPaneLayout中</span></span><br><span class="line">            <span class="comment">// 右侧的内容视图</span></span><br><span class="line">            ViewGroup decor = (ViewGroup) getWindow().getDecorView();</span><br><span class="line">            ViewGroup decorChild = (ViewGroup) decor.getChildAt(<span class="number">0</span>);</span><br><span class="line">            decorChild.setBackgroundColor(getResources().getColor(android.R.color.white));</span><br><span class="line">            decor.removeView(decorChild);</span><br><span class="line">            decor.addView(slidingPaneLayout);</span><br><span class="line">            <span class="comment">// 为 SlidingPaneLayout 添加内容视图</span></span><br><span class="line">            slidingPaneLayout.addView(decorChild, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持滑动返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isSupportSwipeBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPanelClosed</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPanelOpened</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        finish();</span><br><span class="line">        <span class="keyword">this</span>.overridePendingTransition(<span class="number">0</span>, R.anim.out_to_right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPanelSlide</span><span class="params">(View view, <span class="keyword">float</span> v)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法算是最方便的，没有前面两种方法的BUG，只要你看懂了SlidingPaneLayout，这种方法你基本上就算会了。</p><hr><p>还有一种滑动返回的实现是直接在Activity里面实现的，在中间Activity里通过手势监听来实现的，但我觉得这样并没有什么兼容性，没有上面的三种方法扩展性强，所以我这里就不阐述了，给出一篇博客，有兴趣的自己看看<a href="http://blog.csdn.net/ff20081528/article/details/17845753" target="_blank" rel="noopener">android实现向右滑动返回功能</a>。还有看见网上有提到用ViewDragHelper来实现的，暂时我还没不太了解，我会在以后的博客中写出自己实现后的一些想法，这里就暂时先搁着。</p><p>关于滑动返回的还有其他我没怎么了解的方法，但肯定还有，知道的人欢迎推荐！谢谢！</p><hr><h2 id="推荐博客区"><a href="#推荐博客区" class="headerlink" title="推荐博客区"></a>推荐博客区</h2><p>下面先给出与本博客相关的额博客并感谢这些博主：</p><p><a href="http://blog.csdn.net/finddreams/article/details/44678171" target="_blank" rel="noopener">仿手机QQ聊天列表滑动菜单删除和手势滑动返回的两种方式</a><br><a href="http://www.jianshu.com/p/67ce59c9e747" target="_blank" rel="noopener">SlidingPaneLayout详解</a></p><p>给出一些博客自行参考：</p><p><a href="http://www.jianshu.com/p/5104a6a53716#" target="_blank" rel="noopener">Activity滑动返回操作</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0729/3241.html" target="_blank" rel="noopener">一步一步教你150行代码实现简书滑动返回效果</a><br><a href="https://github.com/bingoogolapple/BGASwipeBackLayout-Android" target="_blank" rel="noopener">BGASwipeBackLayout-Android</a></p><hr><p>若要转载，请注明<a href="http://penghesheng.cn/" target="_blank" rel="noopener">出处</a></p><p>最后，欢迎到<a href="https://github.com/PengHesheng/ToolBar-BackActivity" target="_blank" rel="noopener">代码源地址</a>进行下载学习，也欢迎大佬们指教！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Window源码分析——DecorView为例</title>
      <link href="/2020/02/07/Android%20Window%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94DecorView%E4%B8%BA%E4%BE%8B/"/>
      <url>/2020/02/07/Android%20Window%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94DecorView%E4%B8%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Window源码分析——DecorView为例"><a href="#Window源码分析——DecorView为例" class="headerlink" title="Window源码分析——DecorView为例"></a>Window源码分析——DecorView为例</h1><p>在Activity创建完成后，通过<code>attach()</code>方法将Context、Application等绑定到Activity中，同时实例化一个PhoneWindow，并建立和WindowManager的关联，接着回调<code>onCreate()</code>方法，同时我们这里设置的<code>setContentView()</code>会调用到Activity的<code>setContentView()</code>，接着会调用其Window的<code>setContentView()</code>，最后就调用到PhoneWindow中，在PhoneWindow如果没有初始化DecorView就会先进行初始化DecorView，然后通过LayoutInflater去<code>inflate()</code>我们设置的view，在LayoutInflater中通过xml解析器，根据标签递归解析我们的布局，然后生成对应的view添加到DecorView中的parentView（这个是用于放置我们设置的view的地方），这样就得到了整个View树保存在DecorView中（DecorView保存在Windows中）；</p><p>在ActivityThread的handleResumeActivity方法中，通过获取到WindowManager，然后在后面通过addView方法，将decor添加进去，WindowManager的实现类是WindowManagerImpl</p><h2 id="window的添加"><a href="#window的添加" class="headerlink" title="window的添加"></a>window的添加</h2><p>通过WindowManager的addView实现添加过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mGlobal是WindowManagerGlobal对象，从这里看出addView并不是WindowManagerImpl来做的，而是交给了WindowManagerGlobal（典型的桥接模式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"><span class="comment">//存储那些正在被删除的View对象（已经调用removeView方法但是删除操作还未完成）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> ArraySet&lt;View&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查参数是否合法</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//创建一个ViewRootImpl的实例</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="comment">//mViews存储的是所有Window对应的View</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        <span class="comment">//mRoots存储的是所有Window对应的ViewRootImpl</span></span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        <span class="comment">//mParams存储的是所有Window对应的布局参数</span></span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过setView建立关联</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里就将ViewRootImpl对象和DecorView对象建立关联</p><p>接着看ViewRootImpl的setView方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mView = view;</span><br><span class="line"></span><br><span class="line">                mAttachInfo.mDisplayState = mDisplay.getState();</span><br><span class="line">                mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line"></span><br><span class="line">                mViewLayoutDirectionInitial = mView.getRawLayoutDirection();</span><br><span class="line">                mFallbackEventHandler.setView(view);</span><br><span class="line">                mWindowAttributes.copyFrom(attrs);</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (view <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">                    mSurfaceHolderCallback =</span><br><span class="line">                            ((RootViewSurfaceTaker)view).willYouTakeTheSurface();</span><br><span class="line">                    <span class="keyword">if</span> (mSurfaceHolderCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mSurfaceHolder = <span class="keyword">new</span> TakenSurfaceHolder();</span><br><span class="line">                        mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);</span><br><span class="line">                        mSurfaceHolder.addCallback(mSurfaceHolderCallback);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                mAttachInfo.mRootView = view;</span><br><span class="line">                mAttachInfo.mScalingRequired = mTranslator != <span class="keyword">null</span>;</span><br><span class="line">                mAttachInfo.mApplicationScale =</span><br><span class="line">                        mTranslator == <span class="keyword">null</span> ? <span class="number">1.0f</span> : mTranslator.applicationScale;</span><br><span class="line">                <span class="keyword">if</span> (panelParentView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mAttachInfo.mPanelParentWindowToken</span><br><span class="line">                            = panelParentView.getApplicationWindowToken();</span><br><span class="line">                &#125;</span><br><span class="line">                mAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">int</span> res; <span class="comment">/* = WindowManagerImpl.ADD_OKAY; */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">                <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">                <span class="comment">// any other events from the system.</span></span><br><span class="line">                <span class="comment">//请求layout</span></span><br><span class="line">                requestLayout();</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                    mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">                    collectViewAttributes();</span><br><span class="line">                    <span class="comment">//通过WindowSession去完成添加</span></span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法很长，后面要看的代码可能都比较长，所以要耐心。先看看<code>requestLayout();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//View绘制的入口</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有View绘制的入口，里面就是View的三大流程了。接着回到上一个setView方法，在requestLayout方法后面，会通过WindowSession最终来完成Window的添加过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">    mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">    collectViewAttributes();</span><br><span class="line">    <span class="comment">//通过WindowSession去完成添加</span></span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">            mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mWindowSession的类型是IWindowSession，是一个Binder对象，真正的实现类是Session，所以Window的添加过程是一次IPC调用</p><p>接着看Session的addToDisplay方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mService的类型是WMS（WindowManagerService），Window的添加请求就交给WMS处理了，在WMS内部会为每一个应用保留一个单独的Session</p><h2 id="window的删除"><a href="#window的删除" class="headerlink" title="window的删除"></a>window的删除</h2><p>window的删除过程跟添加过程一样，先是通过WindowManagerImpl，最后交给WindowManagerGlobal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    mGlobal.removeView(view, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看WindowManagerGlobal的removeView方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">        View curView = mRoots.get(index).getView();</span><br><span class="line">        removeViewLocked(index, immediate);</span><br><span class="line">        <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Calling with view "</span> + view</span><br><span class="line">                + <span class="string">" but the ViewAncestor is attached to "</span> + curView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是通过findViewLocked查找待删除的View的索引，再调用removeViewLocked做进一步删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是通过ArrayList遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findViewLocked</span><span class="params">(View view, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = mViews.indexOf(view);</span><br><span class="line">    <span class="keyword">if</span> (required &amp;&amp; index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"View="</span> + view + <span class="string">" not attached to window manager"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    ViewRootImpl root = mRoots.get(index);</span><br><span class="line">    View view = root.getView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">        <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> deferred = root.die(immediate);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.assignParent(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">            mDyingViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeViewLocked是通过ViewRootImpl来完成删除操作的，在WindowManager中提供了两种删除接口removeView和removeViewImmediate，分别表示异步和同步删除（主要使用异步删除）。先是拿去添加的时候存储的对应的ViewRootImpl，接着通过ViewRootImpl的die方法来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span></span><br><span class="line">    <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span></span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">        doDie();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsDrawing) &#123;</span><br><span class="line">        destroyHardwareRenderer();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.e(mTag, <span class="string">"Attempting to destroy the window while drawing!\n"</span> +</span><br><span class="line">                <span class="string">"  window="</span> + <span class="keyword">this</span> + <span class="string">", title="</span> + mWindowAttributes.getTitle());</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异步删除的情况下，die方法只是发送了一个请求删除的消息，最后通过ViewRootImpl的Handler处理此消息并调用doDie方法；如果是同步删除，就直接调用doDie方法</p><p>先看看这个消息的处理吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> MSG_DIE:</span><br><span class="line">            doDie();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看看doDie方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="keyword">if</span> (LOCAL_LOGV) Log.v(mTag, <span class="string">"DIE in "</span> + <span class="keyword">this</span> + <span class="string">" of "</span> + mSurface);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoved) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRemoved = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAdded) &#123;</span><br><span class="line">            <span class="comment">//通过此方法进行真正的删除逻辑</span></span><br><span class="line">            dispatchDetachedFromWindow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123;</span><br><span class="line">            destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> viewVisibility = mView.getVisibility();</span><br><span class="line">                <span class="keyword">boolean</span> viewVisibilityChanged = mViewVisibility != viewVisibility;</span><br><span class="line">                <span class="keyword">if</span> (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                    <span class="comment">// If layout params have been changed, first give them</span></span><br><span class="line">                    <span class="comment">// to the window manager to make sure it has the correct</span></span><br><span class="line">                    <span class="comment">// animation info.</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((relayoutWindow(mWindowAttributes, viewVisibility, <span class="keyword">false</span>)</span><br><span class="line">                                &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//windowSessin的结束</span></span><br><span class="line">                            mWindowSession.finishDrawing(mWindow);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//surface的释放</span></span><br><span class="line">                mSurface.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//刷新mRoots、mParams、mDyingViews中的数据</span></span><br><span class="line">    WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里除了真正删除的逻辑，还有一些其他删除后的操作，接着看看这个dispatchDetachedFromWindow真正删除的地方吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span> &amp;&amp; mView.mAttachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//调用View的dispatchDetachedFromWindow，在内部会调用View的onDetachedFromWindow以及onDetachedFromWindowwInternal方法</span></span><br><span class="line">        mView.dispatchDetachedFromWindow();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//垃圾回收的相关工作</span></span><br><span class="line">    mAccessibilityInteractionConnectionManager.ensureNoConnection();</span><br><span class="line">    mAccessibilityManager.removeAccessibilityStateChangeListener(</span><br><span class="line">            mAccessibilityInteractionConnectionManager);</span><br><span class="line">    mAccessibilityManager.removeHighTextContrastStateChangeListener(</span><br><span class="line">            mHighContrastTextManager);</span><br><span class="line">    removeSendWindowContentChangedCallback();</span><br><span class="line"></span><br><span class="line">    destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">    setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    mView.assignParent(<span class="keyword">null</span>);</span><br><span class="line">    mView = <span class="keyword">null</span>;</span><br><span class="line">    mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mSurface.release();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span> &amp;&amp; mInputQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputQueueCallback.onInputQueueDestroyed(mInputQueue);</span><br><span class="line">        mInputQueue.dispose();</span><br><span class="line">        mInputQueueCallback = <span class="keyword">null</span>;</span><br><span class="line">        mInputQueue = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mInputEventReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventReceiver.dispose();</span><br><span class="line">        mInputEventReceiver = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过Session的remove方法删除Window，这同样是一个IPC过程，最终调用WMS的removeWindow方法</span></span><br><span class="line">        mWindowSession.remove(mWindow);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispose the input channel after removing the window so the Window Manager</span></span><br><span class="line">    <span class="comment">// doesn't interpret the input channel being closed as an abnormal termination.</span></span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputChannel.dispose();</span><br><span class="line">        mInputChannel = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDisplayManager.unregisterDisplayListener(mDisplayListener);</span><br><span class="line"></span><br><span class="line">    unscheduleTraversals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="window的更新"><a href="#window的更新" class="headerlink" title="window的更新"></a>window的更新</h2><p>WindowMangerImpl的updateViewLayout方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.updateViewLayout(view, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着WindowManagerGlobal的updateViewLayout方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">        ViewRootImpl root = mRoots.get(index);</span><br><span class="line">        mParams.remove(index);</span><br><span class="line">        mParams.add(index, wparams);</span><br><span class="line">        root.setLayoutParams(wparams, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要更新View的LayoutParams并替换掉旧的，接着再更新ViewRootImpl中的LayoutParams，通过ViewRootImpl的setLayoutParams来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(WindowManager.LayoutParams attrs, <span class="keyword">boolean</span> newView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldInsetLeft = mWindowAttributes.surfaceInsets.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldInsetTop = mWindowAttributes.surfaceInsets.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldInsetRight = mWindowAttributes.surfaceInsets.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldInsetBottom = mWindowAttributes.surfaceInsets.bottom;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldSoftInputMode = mWindowAttributes.softInputMode;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> oldHasManualSurfaceInsets = mWindowAttributes.hasManualSurfaceInsets;</span><br><span class="line">        ...</span><br><span class="line">        applyKeepScreenOnFlag(mWindowAttributes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newView) &#123;</span><br><span class="line">            mSoftInputMode = attrs.softInputMode;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mWindowAttributesChanged = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ViewRootImpl中会通过scheduleTraversals来进行重绘，ViewRootImpl还会通过WindowSession来更新Window的视图，最终由WMS的relayoutWindow实现，也是一个IPC过程</p><h2 id="Window、DecorView、Activity的关系"><a href="#Window、DecorView、Activity的关系" class="headerlink" title="Window、DecorView、Activity的关系"></a>Window、DecorView、Activity的关系</h2><p>通过类加载器创建Activity后，设置了一个null的Window，然后通过attach方法，将相关的东西跟Activity关联（包括Application、Window等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过类加载器实例化一个Activity</span></span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//声明一个Window</span></span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//Activity创建后，由于前面没有设置mPendingRemoveWindow这些东西，所以下面的判断不会执行</span></span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            <span class="comment">//通过Activity的attach方法进行关联</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                <span class="comment">//回调onCreate方法</span></span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                        <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                        <span class="string">" did not call through to super.onPostCreate()"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Activity的attach方法中，会实例化一个PhoneWindow，通过<code>context.getSystemService(Context.WINDOW_SERVICE)</code>获取WindowManager的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line">    <span class="comment">//实例化PhoneWindow</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    <span class="comment">//window的一些设置</span></span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line">    mReferrer = referrer;</span><br><span class="line">    mComponent = intent.getComponent();</span><br><span class="line">    mActivityInfo = info;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    mParent = parent;</span><br><span class="line">    mEmbeddedID = id;</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    <span class="keyword">if</span> (voiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNonConfigurationInstances != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mVoiceInteractor = <span class="keyword">new</span> VoiceInteractor(voiceInteractor, <span class="keyword">this</span>, <span class="keyword">this</span>,</span><br><span class="line">                    Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给Window设置WindowManager，通过context来获取WindowManager的实例</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下怎么获取WindowManager实例的，ContextImpl中的getSystemService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回了SystemServiceRegistry的getSystemService方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServiceRegistry</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//HashMap缓存，，Service</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sServiceCacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not instantiable.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SystemServiceRegistry</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        registerService(Context.ACTIVITY_SERVICE, ActivityManager.class,</span><br><span class="line">                <span class="keyword">new</span> CachedServiceFetcher&lt;ActivityManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ActivityManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class="line">                <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">                <span class="keyword">new</span> CachedServiceFetcher&lt;WindowManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> WindowManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(ctx);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据字段获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class="line">        ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">        <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">            ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//缓存</span></span><br><span class="line">        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先getSystemService只是根据对应的name字符串从缓存SYSTEM_SERVICE_FETCHERS中获取对应的服务，而在这个类中，后面又有一个registerService方法，将注册的Service都放进了缓存。通过查看这个类发现，首先SystemServiceRegistry是一个静态类，其次，有一个static块，在这个static块中，你会发现很多registerService方法，而这些注册的Service是很多的Manager，慢慢看这个static块，你会发现，有很多的熟悉的Manager，例如ActivityManager、BatteryManager、AudioManager、BluetoothManager等等，很多你都在日常开发中用到过，当然了，这里面也有我们要找的WindowManager，在这个registerService方法中，各种Manager都进行了实例化（new）。所以最后通过getSystemService和字段获取的就是对应的Service，那么我们这里就获取了WindowManagerImpl（WindowManager的实现类）</p><p>有点跑题了，回到Activity的attach方法，在这里有了PhoneWindow的实例、WindowManager的实例，但是还并没有将DecorView和PhoneWindow进行关联（DecorView是系统内置的一个布局，这个有问题的自己查咯），那我们接着看ActivityThread中创建完Activity后干了什么吧</p><p>在ActivityThread的performLaunchActivity后，回到上一个方法handleLaunchActivity方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        <span class="comment">//创建完后，接着调用了resume方法，这就是要调用的onResume哦</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">            ...</span><br><span class="line">            performPauseActivityIfNeeded(r, reason);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                        Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建Activity完后，又调用了ActivityThread的handleResumeActivity，这个方法其实就会onResume方法的，那么来看看吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取缓存的ActivityClientRecord（记录Activity相关的信息咯）</span></span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//如果是第一次创建Activity，那么这个Window肯定是null的咯，还记得之前创建的时候，说了ActivityClientRecord基本没什么设置了吗</span></span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//既然是null，那就获取Activity的Window吧，这个就是attach的时候实例化的PhoneWindow哦</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//这里获取DecorView，可是前面好像没有创建DecorView啊？接着看后面的源码哦</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//获取WindowManager，没错，这就是我们前面跑题去看的Manager，获取了WindowManagerImpl的实例</span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="comment">//由于PhoneWindow中的Window是null，这里肯定不会执行这个判断的啦</span></span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class="line">                <span class="comment">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class="line">                <span class="comment">// the decor view we have to notify the view root that the</span></span><br><span class="line">                <span class="comment">// callbacks may have changed.</span></span><br><span class="line">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//哎呀，addView了哦</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    a.onWindowAttributesChanged(l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                TAG, <span class="string">"Launch "</span> + r + <span class="string">" mStartedActivity set"</span>);</span><br><span class="line">            r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// The window is now visible if it has been added, we are not</span></span><br><span class="line">        <span class="comment">// simply finishing, and we are not starting another activity.</span></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">            ...</span><br><span class="line">            r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">            mNumVisibleActivities++;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="comment">//最终会通过调用Activity的makeVisible进行显示，才能被看见</span></span><br><span class="line">                r.activity.makeVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If an exception was thrown when trying to resume, then</span></span><br><span class="line">        <span class="comment">// just end this activity.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                .finishActivity(token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                        Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要记得抓重点哦，这个方法代码很多，但逻辑很简单，直接看<code>if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible)</code>这个判断咯，其实就是根据是否已经添加了Window来判断，执行的就是两个逻辑（两种情况），第一次肯定还没有添加Window，那么就需要添加，就先获取PhoneWindow实例，然后获取DecorView，最后通过WindowManager的addView方法添加；另一种就是已经添加的情况，就是单纯的resume了</p><p>好了，我们先来看看怎么获取DecorView的吧（毕竟我们前面并没有去创建它）</p><p>我们知道，我们在一个Activity的onCreate方法中通常都要写这么一行<code>setContentView()</code>，通过这行代码就将我们要设置的布局显示出来，我们知道，我们设置的这个布局是DecorView中contentParent的一个子View；而在Activity创建后，resume之前，是先会调用onCreate方法的，所以我们看看Activity的setContentView方法（注意一点，AppCompateActivity的setContentView要多几个过程）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到window，来设置View</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    <span class="comment">//初始化window的actionBar</span></span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里获取的Window就是前面通过attach时，创建的PhoneWindow，那么接着看PhoneWindow的setContentView方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">    <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">    <span class="comment">// before this happens.</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//通过LayoutInflater加载资源布局，添加到DecorView的mContentParent中</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mContentParent是一个ViewGroup类型对象，当它为空，就执行installDecor方法创建DecorView，这个mContentParent可能是DecorView，也可能是它的子View（没太懂）</p><p>那么接着看看这个installDecor方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//通过generateDecor获取通常的DecorView</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//通过generateLayout获取mContentParent</span></span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，进行mDecor判断，为null的时候调用generateDecor创建一个，接着由于mContentParent，也会调用generateLayout创建一个，后面部分可以看到对默认标题、菜单等的一些设置处理。</p><p>接着看generateDecor方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, getContext().getResources());</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取Context，然后实例化了一个DecorView，同时也将PhoneWindow和DecorView关联起来，在DecorView的构造方法中会进行这个操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">DecorView(Context context, <span class="keyword">int</span> featureId, PhoneWindow window,</span><br><span class="line">        WindowManager.LayoutParams params) &#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    mFeatureId = featureId;</span><br><span class="line"></span><br><span class="line">    mShowInterpolator = AnimationUtils.loadInterpolator(context,</span><br><span class="line">            android.R.interpolator.linear_out_slow_in);</span><br><span class="line">    mHideInterpolator = AnimationUtils.loadInterpolator(context,</span><br><span class="line">            android.R.interpolator.fast_out_linear_in);</span><br><span class="line"></span><br><span class="line">    mBarEnterExitDuration = context.getResources().getInteger(</span><br><span class="line">            R.integer.dock_enter_exit_duration);</span><br><span class="line">    mForceWindowDrawsStatusBarBackground = context.getResources().getBoolean(</span><br><span class="line">            R.bool.config_forceWindowDrawsStatusBarBackground)</span><br><span class="line">            &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= N;</span><br><span class="line">    mSemiTransparentStatusBarColor = context.getResources().getColor(</span><br><span class="line">            R.color.system_bar_background_semi_transparent, <span class="keyword">null</span> <span class="comment">/* theme */</span>);</span><br><span class="line"></span><br><span class="line">    updateAvailableWidth();</span><br><span class="line">    <span class="comment">//将DecorView添加到PhoneWindow</span></span><br><span class="line">    setWindow(window);</span><br><span class="line"></span><br><span class="line">    updateLogTag(params);</span><br><span class="line"></span><br><span class="line">    mResizeShadowSize = context.getResources().getDimensionPixelSize(</span><br><span class="line">            R.dimen.resize_shadow_size);</span><br><span class="line">    initResizingPaints();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWindow</span><span class="params">(PhoneWindow phoneWindow)</span> </span>&#123;</span><br><span class="line">    mWindow = phoneWindow;</span><br><span class="line">    Context context = getContext();</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> DecorContext) &#123;</span><br><span class="line">        DecorContext decorContext = (DecorContext) context;</span><br><span class="line">        decorContext.setPhoneWindow(mWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DecorContext就是DecorView的不依赖于活动的上下文</p><p>创建好DecorView并将之于PhoneWindow关联，然后回创建mContentParent，接着看PhoneWindow的generateDecor方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Apply data from current theme.</span></span><br><span class="line"></span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    <span class="comment">//很多标签检查，设置标签等等</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inflate the window decor.</span></span><br><span class="line">    <span class="comment">//开始加载默认的布局</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="comment">// System.out.println("Features: 0x" + Integer.toHexString(features));</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">        setCloseOnSwipeEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleIconsDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title_icons;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// XXX Remove this once action bar supports these features.</span></span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">        <span class="comment">// System.out.println("Title Icons!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_PROGRESS) | (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; (features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Special case for a window with only a progress bar (and title).</span></span><br><span class="line">        <span class="comment">// XXX Need to have a no-title version of embedded windows.</span></span><br><span class="line">        layoutResource = R.layout.screen_progress;</span><br><span class="line">        <span class="comment">// System.out.println("Progress!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_CUSTOM_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Special case for a window with a custom title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogCustomTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_custom_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// XXX Remove this once action bar supports these features.</span></span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If no other features and not embedded, only need a title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) != <span class="number">0</span>) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                    R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                    R.layout.screen_action_bar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println("Title!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Embedded, so no decoration is needed.</span></span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">        <span class="comment">// System.out.println("Simple!");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.startChanging();</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining setup -- of background and title -- that only applies</span></span><br><span class="line">    <span class="comment">// to top-level windows.</span></span><br><span class="line">    <span class="comment">//顶级Window的标题和背景设置</span></span><br><span class="line">    <span class="keyword">if</span> (getContainer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable background;</span><br><span class="line">        <span class="keyword">if</span> (mBackgroundResource != <span class="number">0</span>) &#123;</span><br><span class="line">            background = getContext().getDrawable(mBackgroundResource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            background = mBackgroundDrawable;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setWindowBackground(background);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Drawable frame;</span><br><span class="line">        <span class="keyword">if</span> (mFrameResource != <span class="number">0</span>) &#123;</span><br><span class="line">            frame = getContext().getDrawable(mFrameResource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            frame = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setWindowFrame(frame);</span><br><span class="line"></span><br><span class="line">        mDecor.setElevation(mElevation);</span><br><span class="line">        mDecor.setClipToOutline(mClipToOutline);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setTitle(mTitle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mTitleColor == <span class="number">0</span>) &#123;</span><br><span class="line">            mTitleColor = mTextColor;</span><br><span class="line">        &#125;</span><br><span class="line">        setTitleColor(mTitleColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看方法返回的是一个ViewGroup，说明mContentParent是ViewGroup类型的，然后在代码中我们看到了很多默认的资源文件的加载和设置，这就是顶级Window的默认设置，你自己修改后也是在这里生效的</p><p>然后我们回过头看看ActivityThread的handleResumeActivity方法中，通过<code>View decor = r.window.getDecorView();</code>来获取到我们前面创建的DecorView，那么看看PhoneWindow的getDecorView方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span> || mForceDecorInstall) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中先进行了是否为null的判断，所以不管我们前面有没有成功创建DecorView，最后获取到的都不会是null，（所以这里的DecorView到底是前面创建还是后面创建的呢）</p><p>好了，到这里呢，DecorView有了，Window也有了，两者也进行了关联，那么我们就回到ActivityThread中的handleResumeActivity方法，在<code>View decor = r.window.getDecorView();</code>这行代码后，我们又是获取到了WindowManager，然后在后面通过addView方法，将decor添加进去，这就是Window的添加过程了</p><p>然后我们看看Activity的makeVisible方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也进行了判断，是否添加了Window，然后将DecorView显示</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Window相关总结</title>
      <link href="/2020/02/07/Android%20Window%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Android%20Window%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Window相关总结"><a href="#Window相关总结" class="headerlink" title="Window相关总结"></a>Window相关总结</h1><h2 id="Window概念"><a href="#Window概念" class="headerlink" title="Window概念"></a>Window概念</h2><h2 id="几种Window的用法"><a href="#几种Window的用法" class="headerlink" title="几种Window的用法"></a>几种Window的用法</h2><h2 id="Window的原理及源码分析"><a href="#Window的原理及源码分析" class="headerlink" title="Window的原理及源码分析"></a>Window的原理及源码分析</h2><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li><p>AlertDialog,popupWindow,Activity区别<br> AlertDialog builder：用来提示用户一些信息,用起来也比较简单,设置标题类容和按钮即可,如果是加载的自定义的view ,调用 dialog.setView(layout);加载布局即可<br> popupWindow：就是一个悬浮在Activity之上的窗口，可以用展示任意布局文件。<br> activity：Activity是Android系统中的四大组件之一，可以用于显示View。Activity是一个与用记交互的系统模块，几乎所有的Activity都是和用户进行交互的</p><p> 区别：AlertDialog是非阻塞式对话框：AlertDialog弹出时，后台还可以做事情；而PopupWindow是阻塞式对话框：PopupWindow弹出时，程序会等待，在PopupWindow退出前，程序一直等待，只有当我们调用了dismiss方法的后，PopupWindow退出，程序才会向下执行。这两种区别的表现是：AlertDialog弹出时，背景是黑色的，但是当我们点击背景，AlertDialog会消失，证明程序不仅响应AlertDialog的操作，还响应其他操作，其他程序没有被阻塞，这说明了AlertDialog是非阻塞式对话框；PopupWindow弹出时，背景没有什么变化，但是当我们点击背景的时候，程序没有响应，只允许我们操作PopupWindow，其他操作被阻塞。我们在写程序的过程中可以根据自己的需要选择使用Popupwindow或者是Dialog</p><p> （1）Popupwindow在显示之前一定要设置宽高，Dialog无此限制。<br> （2）Popupwindow默认不会响应物理键盘的back，除非显示设置了popup.setFocusable(true);而在点击back的时候，Dialog会消失。<br> （3）Popupwindow不会给页面其他的部分添加蒙层，而Dialog会。<br> （4）Popupwindow没有标题，Dialog默认有标题，可以通过dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);取消标题<br> （5）二者显示的时候都要设置Gravity。如果不设置，Dialog默认是Gravity.CENTER。<br> （6）二者都有默认的背景，都可以通过setBackgroundDrawable(new ColorDrawable(android.R.color.transparent));去掉</p></li><li><p>Activity-Window-View三者的差别<br> Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图） LayoutInflater像剪刀，Xml配置像窗花图纸。<br> 1.在Activity中调用attach，创建了一个Window<br> 2.创建的window是其子类PhoneWindow，在attach中创建PhoneWindow<br> 3.在Activity中调用setContentView(R.layout.xxx)<br> 4.其中实际上是调用的getWindow().setContentView()<br> 5.调用PhoneWindow中的setContentView方法<br> 6.创建ParentView： 作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）<br> 7.将指定的R.layout.xxx进行填充 通过布局填充器进行填充【其中的parent指的就是DecorView】<br> 8.调用到ViewGroup<br> 9.调用ViewGroup的removeAllView()，先将所有的view移除掉添加新的view：addView()</p></li><li><p>Window的添加过程<br> <a href="https://blog.csdn.net/itachi85/article/details/78025485" target="_blank" rel="noopener">Android解析WindowManager（三）Window的添加过程</a><br> <a href="https://blog.csdn.net/u011494285/article/details/80979047" target="_blank" rel="noopener">【源码学习】window 添加 view</a></p></li><li><p>Window的删除过程<br> <a href="https://blog.csdn.net/itachi85/article/details/79134490" target="_blank" rel="noopener">Android解析WindowManagerService（三）Window的删除过程</a></p></li><li><p>Window的更新过程<br> <a href="https://blog.csdn.net/u011494285/article/details/81091213" target="_blank" rel="noopener">【源码学习】window 的删除及更新过程</a></p><p> <a href="https://juejin.im/post/5a5c440cf265da3e5033bcdf" target="_blank" rel="noopener">理解Window的添加，删除，刷新内部机制</a></p></li><li><p>Activity、Window、DecorView、ViewRootImpl之间的区别与联系<br> Activity：<br> Activity并不负责视图控制，它只是控制生命周期和处理事件。真正控制视图的是Window。一个Activity包含了一个Window，Window才是真正代表一个窗口。Activity就像一个控制器，统筹视图的添加与显示，以及通过其他回调方法，来与Window、以及View进行交互。</p><p> Window：<br> Window是视图的承载器，内部持有一个 DecorView，而这个DecorView才是 view的根布局。Window是一个抽象类，实际在Activity中持有的是其子类PhoneWindow。PhoneWindow中有个内部类DecorView，通过创建DecorView来加载Activity中设置的布局 R.layout.activity_main 。Window 通过WindowManager将DecorView加载其中，并将DecorView交给ViewRoot，进行视图绘制以及其他交互。</p><p> DecorView：<br> DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下三个部分，上面是个ViewStub,延迟加载的视图（应该是设置ActionBar,根据Theme设置），中间的是标题栏(根据Theme设置，有的布局没有)，下面的是内容栏。</p><p> ViewRoot：<br> ViewRoot可能比较陌生，但是其作用非常重大。所有View的绘制以及事件分发等交互都是通过它来执行或传递的。ViewRoot对应ViewRootImpl类，它是连接WindowManagerService和DecorView的纽带，View的三大流程(测量（measure），布局（layout），绘制（draw）)均通过ViewRoot来完成。ViewRoot并不属于View树的一份子。从源码实现上来看，它既非View的子类，也非View的父类，但是，它实现了ViewParent接口，这让它可以作为View的名义上的父视图。RootView继承了Handler类，可以接收事件并分发，Android的所有触屏事件、按键事件、界面刷新等事件都是通过ViewRoot进行分发的。</p><p> <a href="https://img-blog.csdn.net/20171122172245272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDczMjEwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener"><img src="https://img-blog.csdn.net/20171122172245272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDczMjEwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="比较"></a>比较</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android View系列(一)——View源码分析——DecorView</title>
      <link href="/2020/02/07/Android%20View%E7%B3%BB%E5%88%97(%E4%B8%80)%E2%80%94%E2%80%94View%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94DecorView/"/>
      <url>/2020/02/07/Android%20View%E7%B3%BB%E5%88%97(%E4%B8%80)%E2%80%94%E2%80%94View%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94DecorView/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="View源码分析——DecorView为例"><a href="#View源码分析——DecorView为例" class="headerlink" title="View源码分析——DecorView为例"></a>View源码分析——DecorView为例</h1><p><strong>基本概念</strong>：ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带。View的三大流程measure、layout、draw都是通过ViewRoot来完成。在ActivityThread中，当Activity对象被创建，会将DecorView添加到Window，同时会创建ViewRootImpl对象，并将两个关联</p><p>在Activity创建完成后，通过<code>attach()</code>方法将Context、Application等绑定到Activity中，同时实例化一个PhoneWindow，并建立和WindowManager的关联，接着回调<code>onCreate()</code>方法，同时我们这里设置的<code>setContentView()</code>会调用到Activity的<code>setContentView()</code>，接着会调用其Window的<code>setContentView()</code>，最后就调用到PhoneWindow中，在PhoneWindow如果没有初始化DecorView就会先进行初始化DecorView，然后通过LayoutInflater去<code>inflate()</code>我们设置的view，在LayoutInflater中通过xml解析器，根据标签递归解析我们的布局，然后生成对应的view添加到DecorView中的parentView（这个是用于放置我们设置的view的地方），这样就得到了整个View树保存在DecorView中（DecorView保存在Windows中）；</p><p>在ActivityThread的handleResumeActivity方法中，通过获取到WindowManager，然后在后面通过addView方法，将decor添加进去，WindowManager的实现类是WindowManagerImpl，这又是Window的添加过程，在这个过程中，有一个requestLayout方法（相关过程参考我的<a href="http://penghesheng.cn/?p=162" target="_blank" rel="noopener">Window源码分析</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//这就是View绘制的入口</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看内部的scheduleTraversals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//这里通过</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//mTraversalRunnable是一个Runnable</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码看着可能就有点迷茫了，目前也没看太懂，只知道mTraversalRunnable是一个Runnable对象，而在它的run方法呢看到我们后续要分析的方法，所以这里的分析就暂时放放（感觉是通过mChoreographer来调用mTraversalRunnable中的run方法，但是不知道mChoreographer是用来干什么的），<strong>好吧，遇到问题就先放放，欢迎知道的人答疑（期待您的看法）</strong>。</p><p>那就接着看mTraversalRunnable中的run方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个对象还是final的哦</span></span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br></pre></td></tr></table></figure><p>run方法中就只有一行代码，就是调用了ViewRootImpl中的doTraversal方法，接着看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ...</span><br><span class="line">        performTraversals();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中呢，重点就只是performTraversals咯，接着看ViewRootImpl中内部的performTraversals方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cache mView since it is used so much below...</span></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        <span class="keyword">final</span> Resources res = mView.getContext().getResources();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">        <span class="comment">//在测量的开始，会去询问到底要多大的空间，对于DecorView来说，就是屏幕的尺寸，desiredWindowWidth、desiredWindowHeight是屏幕的宽和高</span></span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                    || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                    updatedConfiguration) &#123;</span><br><span class="line">                ...</span><br><span class="line">                 <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                ....</span><br><span class="line">                <span class="comment">//是否需要重新测量</span></span><br><span class="line">                <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        ...</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View的绘制流程是从ViewRoot的performTraversals开始的，这个就是我们View绘制流程的开始（我知道这个方法很关键，但是也不用这么多吧），代码很长，就跟你改不完的bug一样多。好了，赶紧抓重点，在这个方法中我们找到了performMeasure、performLayout、performDraw这三个方法，这好像就是View绘制的三大流程（但好像还有点不像啊），<strong>这三个方法分别完成顶级View（DecorView）的measure、layout、draw过程，在performMeasure中回调用measure方法，在measure方法中又会调用onMeasure方法，在onMeasure方法中则会对所有子View进行measure过程，这时候measure流程就从父容器传到子View中了，这样就完成了一次measure过程。接着子View会重复父容器的过程。performLayout和performDraw的传递流程跟performMeasure基本类似，唯一不同的是performDraw在draw方法是通过dispatchDraw实现的</strong></p><p>接下来就一一分析measure、layout、draw吧</p><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><p>在分析measure之前，先来了解MeasureSpec是做什么的把</p><p>MeasureSpec决定了View的测量过程，是measure过程重要的一个类</p><blockquote><p>MeasureSpec是一个32位int值，高2位代表SpecMode（测量模式），低30位代表SpecSize（在某种测量模式下的测量大小）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="meta">@IntDef</span>(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> MeasureSpecMode &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">    <span class="comment">//构建MeasureSpec</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></span><br><span class="line"><span class="function">                                      @MeasureSpecMode <span class="keyword">int</span> mode) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">            <span class="keyword">return</span> size + mode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeMeasureSpec(size, mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MeasureSpecMode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//noinspection ResourceType</span></span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> measureSpec, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> size = getSize(measureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mode == UNSPECIFIED) &#123;</span><br><span class="line">            <span class="comment">// No need to adjust size for UNSPECIFIED mode.</span></span><br><span class="line">            <span class="keyword">return</span> makeMeasureSpec(size, UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        size += delta;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Log.e(VIEW_LOG_TAG, <span class="string">"MeasureSpec.adjust: new size would be negative! ("</span> + size +</span><br><span class="line">                    <span class="string">") spec: "</span> + toString(measureSpec) + <span class="string">" delta: "</span> + delta);</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeMeasureSpec(size, mode);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MeasureSpec是View的内部类，里面代码并不多。MeasureSpec通过makeMeasureSpec方法将SpecMode和SpecSize打包成一个int值类避免过多的对象内存分配，然后也提供了解包的方法getMode、getSize来分别获取SpecMode和SpecSize。所以MeasureSpec这个类就是一个工具类，用来将SpecMode和SpecSize打包成一个int值，然后通过这个int值和对应的方法，可以获取对应的SpecMode和SpecSize</p><p><strong>SpecMode有三类</strong>:</p><ul><li>UNSPECIFIED<br>  父容器对View不会有任何限制，要多大给多大，一般用于系统内部，表示一种测量状态</li><li>EXACTLY<br>  父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize指定的值，对应于LayoutParams中的match_parent和具体的数值这两种模式</li><li>AT_MOST<br>  父容器指定了一个可用大小的SpecSize，View的大小不能大于这个值，具体是什么看不同View的具体实现。对应于LayoutParams中的wrap_content</li></ul><p><strong>MeasureSpec和LayoutParams的关系</strong>：系统内部是通过MeasureSpec来进行View测量，但我们可以给View设置LayoutParams，在View测量的时候，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后再根据这个MeasureSpec来确定View测量后的宽/高。（注意：自身的LayoutParams和父容器一起才能决定View的MeasureSpec，从而决定View的宽/高；有一个例外就是顶级View——DecorView的MeasureSpec是由窗口的尺寸和自身的LayoutParams来决定的），MeasureSpec确定后，onMeasure中就可以确定View的宽/高了</p><p>对于DecorView来说，通过performMeasure(childWidthMeasureSpec, childHeightMeasureSpec)来进行测量的，在这之前，会通过<code>windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight);</code>这行代码先询问要多大的空间，屏幕的尺寸是否修改，传进的参数是屏幕的尺寸和lp，lp是WindowManager.LayoutParams类型，是窗口的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">    <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">            <span class="string">"Measuring "</span> + host + <span class="string">" in display "</span> + desiredWindowWidth</span><br><span class="line">            + <span class="string">"x"</span> + desiredWindowHeight + <span class="string">"..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!goodMeasure) &#123;</span><br><span class="line">        <span class="comment">//根据屏幕的尺寸获取自身的MeasureSpec</span></span><br><span class="line">        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> windowSizeMayChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>childWidthMeasureSpec和childHeightMeasureSpec的赋值是通过getTootMeasureSpec方法得到的，根据屏幕的尺寸来获取的，那接着看看这个getRootMeasureSpec方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是产生MeasureSpec的地方了，LayoutParams.MATCH_PARENT对应就是窗口的大小；LayoutParams.WRAP_CONTENT就是最大模式，大小不定，不能超过窗口的大小；固定大小就是指定大小。</p><p>对于DecorView这个顶级View来说，就是通过屏幕的尺寸和窗口的LayoutParams来获取MeasureSpec的</p><h2 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h2><h3 id="ViewGroup的测量，这里以DecorView为例"><a href="#ViewGroup的测量，这里以DecorView为例" class="headerlink" title="ViewGroup的测量，这里以DecorView为例"></a>ViewGroup的测量，这里以DecorView为例</h3><p>measure过程从ViewRootImpl的performMeasure开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//final WindowManager.LayoutParams mWindowAttributes = new WindowManager.LayoutParams();</span></span><br><span class="line">    WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看一下传进来的参数是什么？</p><p>childWidthMeasureSpec和childHeightMeasureSpec都是通过<code>getRootMeasureSpec()</code>方法来获取的，这个方法前面我们讲过了（[MeasureSpec](<a href="http://blog.penghesheng.cn/2019/04/25/Android" target="_blank" rel="noopener">http://blog.penghesheng.cn/2019/04/25/Android</a> View系列(一)——View源码分析/#MeasureSpec)），就是根据传入的size来判定对应的mode，然后组装成一个MeasureSpec。以childWidthMeasureSpec来讲，那么这里我们传递的参数<code>mWidth</code>和<code>lp.width</code>是什么呢？<code>mWidth</code>是通过<code>mWidth = frame.width();</code>来获取的，其实就是Window的最大值；<code>lp.width</code>是WindowAttributes，代码中注释了具体来源，就是WindowManager.LayoutParams；总的来说，这里由于是DecorView，所以自然就是根据屏幕来获取的这个MeasureSpec</p><p>接着看<code>performMeasure()</code>，mView是在ViewRootImpl实例化的时候传进的DecorView，DecorView本身也是一个View，接着调用View的measure方法测量child的width和height</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">            <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">            <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">            setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>measure方法是一个final方法，就意味着子类不能重写，在View的measure方法中，会去调用onMeasure方法测量自己本身，由于这里分析的View是DecorView，它是一个ViewGroup，所以会调用自己重写的onMeasure方法，然后会去测量子View</p><h3 id="子View的测量（普通View）"><a href="#子View的测量（普通View）" class="headerlink" title="子View的测量（普通View）"></a>子View的测量（普通View）</h3><p><strong>注意</strong>：因为这里分析的DecorView，DecorView也是一个ViewGroup，会在onMeasure方法中对所有子View进行测量</p><p>DecorView的onMeasure方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DisplayMetrics metrics = getContext().getResources().getDisplayMetrics();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPortrait =</span><br><span class="line">            getResources().getConfiguration().orientation == ORIENTATION_PORTRAIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> widthMode = getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> fixedWidth = <span class="keyword">false</span>;</span><br><span class="line">    mApplyFloatingHorizontalInsets = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果SpecMode不是EXACTLY的，则需要在这里调整为EXACTLY</span></span><br><span class="line">    <span class="keyword">if</span> (widthMode == AT_MOST) &#123;</span><br><span class="line">        <span class="keyword">final</span> TypedValue tvw = isPortrait ? mWindow.mFixedWidthMinor : mWindow.mFixedWidthMajor;</span><br><span class="line">        <span class="keyword">if</span> (tvw != <span class="keyword">null</span> &amp;&amp; tvw.type != TypedValue.TYPE_NULL) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> w;</span><br><span class="line">            <span class="comment">//根据DecorView属性，计算出DecorView需要的宽度</span></span><br><span class="line">            <span class="keyword">if</span> (tvw.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">                w = (<span class="keyword">int</span>) tvw.getDimension(metrics);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tvw.type == TypedValue.TYPE_FRACTION) &#123;</span><br><span class="line">                w = (<span class="keyword">int</span>) tvw.getFraction(metrics.widthPixels, metrics.widthPixels);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                w = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MEASURE) Log.d(mLogTag, <span class="string">"Fixed width: "</span> + w);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">            <span class="keyword">if</span> (w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//根据上面计算出来的需要的宽度生成新的MeasureSpec用于DecorView的测量流程</span></span><br><span class="line">                widthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.min(w, widthSize), EXACTLY);</span><br><span class="line">                fixedWidth = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                widthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        widthSize - mFloatingInsets.left - mFloatingInsets.right,</span><br><span class="line">                        AT_MOST);</span><br><span class="line">                mApplyFloatingHorizontalInsets = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mApplyFloatingVerticalInsets = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果SpecMode不是EXACTLY的，则需要在这里调整为EXACTLY</span></span><br><span class="line">    <span class="keyword">if</span> (heightMode == AT_MOST) &#123;</span><br><span class="line">        <span class="keyword">final</span> TypedValue tvh = isPortrait ? mWindow.mFixedHeightMajor</span><br><span class="line">                : mWindow.mFixedHeightMinor;</span><br><span class="line">        <span class="keyword">if</span> (tvh != <span class="keyword">null</span> &amp;&amp; tvh.type != TypedValue.TYPE_NULL) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> h;</span><br><span class="line">            <span class="keyword">if</span> (tvh.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">                h = (<span class="keyword">int</span>) tvh.getDimension(metrics);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tvh.type == TypedValue.TYPE_FRACTION) &#123;</span><br><span class="line">                h = (<span class="keyword">int</span>) tvh.getFraction(metrics.heightPixels, metrics.heightPixels);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MEASURE) Log.d(mLogTag, <span class="string">"Fixed height: "</span> + h);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">            <span class="keyword">if</span> (h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                heightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.min(h, heightSize), EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mWindow.getAttributes().flags &amp; FLAG_LAYOUT_IN_SCREEN) == <span class="number">0</span>) &#123;</span><br><span class="line">                heightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        heightSize - mFloatingInsets.top - mFloatingInsets.bottom, AT_MOST);</span><br><span class="line">                mApplyFloatingVerticalInsets = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在DecorView的onMeasure方法中，会先进行SpecMode的调整，调整为EXACTLY，然后回创建出新的MeasureSpec（宽高都一样的逻辑），接着就调用了父类的onMeasure方法</p><p>接着看父类FrameLayout的onMeasure方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="comment">// 如果测量规格有一个不是精确值，这里就为true</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有子View</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="comment">// 测量子view</span></span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="comment">//由于子布局占用的尺寸除了自身宽高之外，还包含了其距离父布局的边界的值，所以需要加上左右Margin值</span></span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            <span class="comment">//当前的FrameLayout的MeasureSpec不都是EXACTLY,且其子View为MATCH_PARENT，</span></span><br><span class="line">　　　　　　　　　 <span class="comment">//则子View保存到mMatchParentChildren中，后面重新测量</span></span><br><span class="line">　　　　　　　　   <span class="comment">//DecorView不会走这个逻辑，因为进过了DecorView的onMeasure()流程，MeasureSpec一定都为EXACTLY</span></span><br><span class="line">　　　　　　　　　　<span class="comment">//会走到下面流程的情况举例：用户自布局一个FrameLayout属性为WRAP_CONTENT是，但子布局为MATCH_PARENT</span></span><br><span class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后计算得到的maxWidth和maxHeight的值需要保证能够容纳下当前Layout下所有子View，所以需要对各类情况进行处理</span></span><br><span class="line">　　　　　<span class="comment">//所以有以下的加上Padding值，用户设置的Mini尺寸值的对比，设置了背景图片情况的图片大小对比</span></span><br><span class="line">    <span class="comment">// Account for padding too</span></span><br><span class="line">    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum height and width</span></span><br><span class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our foreground's minimum height and width</span></span><br><span class="line">    <span class="keyword">final</span> Drawable drawable = getForeground();</span><br><span class="line">    <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                    childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    <span class="comment">// 这里有值表明了两点：</span></span><br><span class="line">    <span class="comment">// 1 当前FrameLayout的宽和高的建议规格有不是精确值的</span></span><br><span class="line">    <span class="comment">// 2 子view有含有match_parent的地方</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameLayout的测量很简单，首先遍历所有子View，然后调用measureChildWithMargins进行子View的测量，这个方法是在ViewGroup中的，FrameLayout也是继承自ViewGroup。后面就是相关FrameLayout的测量了</p><p>那接着看ViewGroup的measureChildWithMargins方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是ViewGroup测量子View提供方法的一种，另一个是measureChildren，区别就是有没有Margins，在这里获取子View的MeasureSpec，然后调用子View自身的measure方法进行测量</p><p>取出子View的LayoutParams，然后通过getChildMeasureSpec创建子View的MeasureSpec，接着直接传递给View进行测量；<strong>在获取子View的MeasureSepc时，是通过父布局的MeasureSpec和子View本身的LayoutParams共同来决定的</strong>，这点可以直接从代码中直到</p><p>先看看getChildMeasureSpec方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取父容器的SpecMode和SpecSize</span></span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line">    <span class="comment">//父容器减去已经占用的空间，就是子View可用的空间大小</span></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//具体的大小</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">            <span class="comment">// be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">            <span class="comment">// big it should be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通View根据父容器的MeasureSpec来判断是哪一种测量模式，接着同时结合View本身的LayoutParams来确定子元素的MeasureSpec，padding指父容器中已占用的空间大小，因此子View可用的大小是父容器减去padding<code>int size = Math.max(0, specSize - padding);</code></p><p>普通View的MeasureSpec的创建规则：<br>| | | | |<br>|:-:|:-:|:-:|:-:|<br>| childLayoutParams\parentSpecMode | EXACTLY | AT_MOST | UNSPECIFIED |<br>| dp/px | EXACTLY(childSize) | EXACTLY(childSize) | EXACTLY(childSize) |<br>| match_parent | EXACTLY(parentSize) | AT_MOST(parentSize) | UNSPECIFIED(0) |<br>| wrap_content | AT_MOST(parentSize) | AT_MOST(parentSize) | UNSOECIFIED(0) |<br>| | | | |</p><p>回到之前，通过父容器的MeasureSpec和自身的LayoutParams确定了子View的MeasureSpec，那接着就会调用子View自己的measure方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">            <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">            <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">            setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>measure方法是一个final方法，就意味着子类不能重写，在View的measure方法中，会去调用onMeasure方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setMeasuredDimension方法会设置View的宽、高的测量值，所以我们先看getDefaultSize方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于我们来说，只需要看AT_MOST和EXACTLY两种情况，实际上这个方法返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，而最终的大小是由layout确定的（尽管这样，几乎所有情况，测量大小和最终大小是相等的）。</p><p>UNSPECIFIED这种情况一般用于系统内部的测量过程，这种情况下，View的大小为getDefaultSize的第一个参数size，即getSuggestedMinimumWidth、getSuggestedMinimumHeight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;          <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果View没有设置背景，那么View的宽度、高度为mMinWidth、mMinHeight，这两个对应<code>android:minWidth</code>、<code>android:minHeight</code>这个两个属性指定的值，如果不指定默认为0；如果设置了背景，则为<code>max(mMinWidth, mBackground.getMinimumWidth());</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">final</span> <span class="keyword">int</span> intrinsicWidth = getIntrinsicWidth();</span><br><span class="line">&gt;         <span class="keyword">return</span> intrinsicWidth &gt; <span class="number">0</span> ? intrinsicWidth : <span class="number">0</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">final</span> <span class="keyword">int</span> intrinsicHeight = getIntrinsicHeight();</span><br><span class="line">&gt;         <span class="keyword">return</span> intrinsicHeight &gt; <span class="number">0</span> ? intrinsicHeight : <span class="number">0</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>getMinimumWidth返回的就是Drawable的原始宽度、高度，如果Drawable没有原始值，则为0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">        Insets insets = getOpticalInsets();</span><br><span class="line">        <span class="keyword">int</span> opticalWidth  = insets.left + insets.right;</span><br><span class="line">        <span class="keyword">int</span> opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">        measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">        measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将测量的宽高设置，子View的测量就结束了</p><p>同样，我们看看ViewGroup中单独提供了一个measureChildren方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过循环遍历所有的子View，然后调用measureChild方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line">    <span class="comment">//调用自身的measure方法，普通View都是通过View的measure方法进行测量</span></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后都是在View中进行自身的测量（对于普通View来说）</p><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><h3 id="ViewGroup的layout"><a href="#ViewGroup的layout" class="headerlink" title="ViewGroup的layout"></a>ViewGroup的layout</h3><p>layout过程是从ViewRootImpl中的<code>performLayout(lp, mWidth, mHeight);</code>开始的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">        Log.v(mTag, <span class="string">"Laying out "</span> + host + <span class="string">" to ("</span> +</span><br><span class="line">                host.getMeasuredWidth() + <span class="string">", "</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"layout"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//对自身进行layout</span></span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// requestLayout() was called during layout.</span></span><br><span class="line">            <span class="comment">// If no layout-request flags are set on the requesting views, there is no problem.</span></span><br><span class="line">            <span class="comment">// If some requests are still pending, then we need to clear those flags and do</span></span><br><span class="line">            <span class="comment">// a full request/measure/layout pass to handle this situation.</span></span><br><span class="line">            ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Set this flag to indicate that any further requests are happening during</span></span><br><span class="line">                <span class="comment">// the second pass, which may result in posting those requests to the next</span></span><br><span class="line">                <span class="comment">// frame instead</span></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process fresh layout requests, then measure and layout</span></span><br><span class="line">                <span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                    Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                            <span class="string">" during layout: running second layout pass"</span>);</span><br><span class="line">                    view.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="keyword">true</span>;</span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check the valid requests again, this time without checking/clearing the</span></span><br><span class="line">                <span class="comment">// layout flags, since requests happening during the second pass get noop'd</span></span><br><span class="line">                validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                    <span class="comment">// Post second-pass requests to the next frame</span></span><br><span class="line">                    getRunQueue().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                <span class="keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                                Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                                        <span class="string">" during second layout pass: posting in next frame"</span>);</span><br><span class="line">                                view.requestLayout();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，通过<code>host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</code>来对自身进行layout，host是mView，在这里也就是DecorView。<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>获取的是前面Measure后的值，而这个layout方法就是View中的layout方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mRoundScrollbarRenderer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRoundScrollbarRenderer = <span class="keyword">new</span> RoundScrollbarRenderer(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRoundScrollbarRenderer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">        <span class="comment">//可以通过ListenerInfo中的OnLayoutChangeListener来获取Layout修改的值</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;</span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会通过setFrame方法来设定View的四个顶点的位置，即初始化mLeft、mRight、mTop、mBottom四个值（<strong>需要注意的是：</strong>这些值都是针对于父View来说的），View四个顶点确定了，那么在父容器的位置也就确定了，接着会调用onLayout方法，这个方法是父容器确定子View的位置（类似onMeasure），onLayout方法是一个空的方法，说明最后都是View自己实现的</p><p>那么我们这里是DecorView，传进的参数是<code>host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</code>，host.getMeasuredWidth()和host.getMeasuredHeight()获取的宽高就是整个屏幕的宽高，那么也就意味着我们的DecorView就是占满了整个屏幕空间</p><h3 id="子View的layout（普通View）"><a href="#子View的layout（普通View）" class="headerlink" title="子View的layout（普通View）"></a>子View的layout（普通View）</h3><p>DecorView是一个ViewGroup，它的子View的layout过程会在onLayout方法中开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    getOutsets(mOutsets);</span><br><span class="line">    <span class="comment">//当有偏移的时候就调整</span></span><br><span class="line">    <span class="keyword">if</span> (mOutsets.left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        offsetLeftAndRight(-mOutsets.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOutsets.top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        offsetTopAndBottom(-mOutsets.top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mApplyFloatingVerticalInsets) &#123;</span><br><span class="line">        offsetTopAndBottom(mFloatingInsets.top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mApplyFloatingHorizontalInsets) &#123;</span><br><span class="line">        offsetLeftAndRight(mFloatingInsets.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the application changed its SystemUI metrics, we might also have to adapt</span></span><br><span class="line">    <span class="comment">// our shadow elevation.</span></span><br><span class="line">    updateElevation();</span><br><span class="line">    mAllowUpdateElevation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed &amp;&amp; mResizeMode == RESIZE_MODE_DOCKED_DIVIDER) &#123;</span><br><span class="line">        getViewRootImpl().requestInvalidateRootRenderNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DecorView中的onLayout方法并没有做太多的事情，但是在方法中的第一行就调用了父类的onLayout方法。我们知道DecorView是继承自FrameLayout的，所以布局是在FrameLayout中完成的，接着看看FrameLayout的onLayout方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FrameLayout的onLayout方法直接调用了layoutChildren方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取子View的数量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="comment">//获取各个方向的padding值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line">    <span class="comment">//遍历所有的子View</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="comment">//获取LayoutParams</span></span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="comment">//获取测量后的宽高</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> childLeft;</span><br><span class="line">            <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取布局方向，可能的值为rtl、ltr,分别为从右至左、从左至右布局</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="comment">// 结合layoutDirection和View的layout_gravity计算出真正的gravity</span></span><br><span class="line">            <span class="comment">// Gravity.getAbsoluteGravity是一个静态方法</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="comment">// 水平方向如果为从左到右，那么，Gratity为START会被设置成LEFT，END会被设置成RIGHT</span></span><br><span class="line">            <span class="comment">// 水平方向如果为从右到左，那么，Gratity为START会被设置成RIGHT，END会被设置成LEFT</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">            <span class="comment">// 根据不同的水平比重计算View的水平坐标</span></span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据垂直比重计算View的垂直坐标</span></span><br><span class="line">            <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用子View的layout方法进行子View的layout</span></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这个方法会遍历所有的子View，计算出它的位置，最后调用子View自身的layout进行layout过程</p><p>View的layout方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;</span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在View自身的layout过程中，最终就调用其onLayout方法（又是一个递归的过程）</p><h2 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h2><h3 id="ViewGroup的绘制"><a href="#ViewGroup的绘制" class="headerlink" title="ViewGroup的绘制"></a>ViewGroup的绘制</h3><p>从ViewRootImpl的performDraw方法开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fullRedrawNeeded = mFullRedrawNeeded;</span><br><span class="line">    mFullRedrawNeeded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    mIsDrawing = <span class="keyword">true</span>;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"draw"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中的重点就是draw方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    <span class="keyword">if</span> (!surface.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FPS) &#123;</span><br><span class="line">        trackFPS();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是第一次绘制，则会回调到sFirstDrawHandlers中的事件</span></span><br><span class="line">    <span class="comment">//在ActivityThread.attch()方法中有将回调事件加入该队列</span></span><br><span class="line">    <span class="comment">//回调时会执行ActivityThread.ensureJitEnable来确保即时编译相关功能</span></span><br><span class="line">    <span class="keyword">if</span> (!sFirstDrawComplete) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sFirstDrawHandlers) &#123;</span><br><span class="line">            sFirstDrawComplete = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = sFirstDrawHandlers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; count; i++) &#123;</span><br><span class="line">                mHandler.post(sFirstDrawHandlers.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//滚动相关处理，如果scroll发生改变，则回调dispatchOnScrollChanged()方法</span></span><br><span class="line">    scrollToRectOrFocus(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mViewScrollChanged) &#123;</span><br><span class="line">        mAttachInfo.mViewScrollChanged = <span class="keyword">false</span>;</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnScrollChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//窗口当前是否有动画需要执行</span></span><br><span class="line">    <span class="keyword">boolean</span> animating = mScroller != <span class="keyword">null</span> &amp;&amp; mScroller.computeScrollOffset();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="comment">//mAttachInfo.mHardwareRenderer不为null，则表示该Window使用硬件加速进行绘制</span></span><br><span class="line">        <span class="comment">//执行ViewRootImpl.set()方法会判断是否使用硬件加速</span></span><br><span class="line">        <span class="comment">//若判断使用会调用ViewRootImpl.enableHardwareAcceleration()来初始化mHardwareRenderer</span></span><br><span class="line">　　　　　　　<span class="comment">//该View设置为使用硬件加速，且当前硬件加速处于可用状态</span></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//使用硬件加速绘制方式</span></span><br><span class="line">            mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If we get here with a disabled &amp; requested hardware renderer, something went</span></span><br><span class="line">            <span class="comment">// wrong (an invalidate posted right before we destroyed the hardware surface</span></span><br><span class="line">            <span class="comment">// for instance) so we should just bail out. Locking the surface with software</span></span><br><span class="line">            <span class="comment">// rendering at this point would lock it forever and prevent hardware renderer</span></span><br><span class="line">            <span class="comment">// from doing its job when it comes back.</span></span><br><span class="line">            <span class="comment">// Before we request a new frame we must however attempt to reinitiliaze the</span></span><br><span class="line">            <span class="comment">// hardware renderer if it's in requested state. This would happen after an</span></span><br><span class="line">            <span class="comment">// eglTerminate() for instance.</span></span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    !mAttachInfo.mThreadedRenderer.isEnabled() &amp;&amp;</span><br><span class="line">                    mAttachInfo.mThreadedRenderer.isRequested()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//尝试重新初始化当前window的硬件加速</span></span><br><span class="line">                    mAttachInfo.mThreadedRenderer.initializeIfNeeded(</span><br><span class="line">                            mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OutOfResourcesException e) &#123;</span><br><span class="line">                    handleOutOfResourcesException(e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">                scheduleTraversals();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用软件渲染绘制方式</span></span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有动画进行重绘</span></span><br><span class="line">    <span class="keyword">if</span> (animating) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mDirty表示的是当前需要更新的区域，即脏区域。经过一些scroll相关的处理后，如果脏区域不为空或者有动画需要执行时，便会执行重绘窗口的工作。有两种绘制方式，硬件加速绘制方式和软件渲染绘制方式，在创建窗口流程的ViewRootImpl.setView()中，会根据不同情况，来选择是否创mAttachInfo.mHardwareRenderer对象。如果该对象不为空，则会进入硬件加速绘制方式，即调用到ThreadedRenderer.draw()，这个ThreadedRenderer是不会block住UI线程，但是UI线程可以block住它，主要是在UI线程构建试图然后交给单独的线程通过OpenGL去绘制；否则则会进入软件渲染的绘制方式，调用到ViewRootImpl.drawSoftware()方法。但是无论哪种方式，都会走到mView.draw()方法，即DecorView.draw()方法。</p><p>主要看看drawSoftWare方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line">        <span class="comment">//获取canvas</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，会获取canvas，然后进行一系列的操作，最终会调用mView的draw方法</p><p>在这里mView就是DecorView，实际上就是View中的draw方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">     * in the appropriate order:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      1. Draw the background</span></span><br><span class="line"><span class="comment">     *      2. If necessary, save the canvas' layers to prepare for fading</span></span><br><span class="line"><span class="comment">     *      3. Draw view's content</span></span><br><span class="line"><span class="comment">     *      4. Draw children</span></span><br><span class="line"><span class="comment">     *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">     *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        <span class="comment">//绘制背景</span></span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    <span class="comment">//判断是否需要绘制边缘渐变效果（水平方向、垂直方向）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果不需要绘制边缘渐变效果，跳过了step5</span></span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        <span class="comment">// Step 3, draw the content</span></span><br><span class="line">        <span class="comment">//绘制自己View的内容</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4, draw the children</span></span><br><span class="line">        <span class="comment">//通过dispatchDraw来绘制子View</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">        drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debugDraw()) &#123;</span><br><span class="line">            debugDrawFocus(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we're done...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Here we do the full fledged routine...</span></span><br><span class="line"><span class="comment">     * (this is an uncommon case where speed matters less,</span></span><br><span class="line"><span class="comment">     * this is why we repeat some of the tests that have been</span></span><br><span class="line"><span class="comment">     * done above)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> drawTop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawBottom = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawLeft = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> topFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> bottomFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> leftFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> rightFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2, save the canvas' layers</span></span><br><span class="line">    <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> offsetRequired = isPaddingOffsetRequired();</span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        paddingLeft += getLeftPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = mScrollX + paddingLeft;</span><br><span class="line">    <span class="keyword">int</span> right = left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">    <span class="keyword">int</span> top = mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">    <span class="keyword">int</span> bottom = top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        right += getRightPaddingOffset();</span><br><span class="line">        bottom += getBottomPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ScrollabilityCache scrollabilityCache = mScrollCache;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> fadeHeight = scrollabilityCache.fadingEdgeLength;</span><br><span class="line">    <span class="keyword">int</span> length = (<span class="keyword">int</span>) fadeHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip the fade length if top and bottom fades overlap</span></span><br><span class="line">    <span class="comment">// overlapping fades produce odd-looking artifacts</span></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">        length = (bottom - top) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also clip horizontal fades if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">        length = (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges) &#123;</span><br><span class="line">        topFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getTopFadingEdgeStrength()));</span><br><span class="line">        drawTop = topFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        bottomFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getBottomFadingEdgeStrength()));</span><br><span class="line">        drawBottom = bottomFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges) &#123;</span><br><span class="line">        leftFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getLeftFadingEdgeStrength()));</span><br><span class="line">        drawLeft = leftFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        rightFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getRightFadingEdgeStrength()));</span><br><span class="line">        drawRight = rightFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> solidColor = getSolidColor();</span><br><span class="line">    <span class="keyword">if</span> (solidColor == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">            canvas.saveLayer(left, bottom - length, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, left + length, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">            canvas.saveLayer(right - length, top, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line">    <span class="keyword">final</span> Paint p = scrollabilityCache.paint;</span><br><span class="line">    <span class="keyword">final</span> Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">    <span class="keyword">final</span> Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * bottomFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">180</span>);</span><br><span class="line">        matrix.postTranslate(left, bottom);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * leftFadeStrength);</span><br><span class="line">        matrix.postRotate(-<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * rightFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(right, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">    drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugDraw()) &#123;</span><br><span class="line">        debugDrawFocus(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在draw方法中，根据上面注释可以知道draw的过程分为5步</p><ol><li>画出背景background</li><li>判断是否需要画边缘的渐变效果</li><li>画出当前View需要显示的内容，调用onDraw()来实现</li><li>调用dispatchDraw()方法，进入子视图的draw逻辑</li><li>如果需要花边缘渐变效果，则在这里画</li><li>绘制装饰（如滚动条）</li></ol><p>在绘制自己的时候，是调用onDraw方法，这个方法是个空实现，是由具体的View自己实现的，我们这里是DecorView，那么就会回到DecorView的onDraw方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When we are resizing, we need the fallback background to cover the area where we have our</span></span><br><span class="line">    <span class="comment">// system bar background views as the navigation bar will be hidden during resizing.</span></span><br><span class="line">    mBackgroundFallback.draw(isResizing() ? <span class="keyword">this</span> : mContentRoot, mContentRoot, c,</span><br><span class="line">            mWindow.mContentParent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子View的绘制"><a href="#子View的绘制" class="headerlink" title="子View的绘制"></a>子View的绘制</h3><p>View绘制过程的传递时通过dispatchDraw来实现的，dispatchDraw会遍历所有子元素的draw方法，这样draw事件就一层层的传递下去</p><p>dispatchDraw方法是在ViewGroup中实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">int</span> flags = mGroupFlags;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//此处不分析具体流程，需要了解的可查看相关博客</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">            <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                    transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历所有子View进行子View的绘制</span></span><br><span class="line">                more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">            transientIndex++;</span><br><span class="line">            <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                transientIndex = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在dispatch中会遍历当前ViewGroup的子视图，然后调用drawChild()方法来依次调起子视图的绘制过程，进入ViewGroup.drawChild()代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这就又回到了View中的draw方法了</p><p><strong>注意</strong><br>View中有一个特殊的方法setWillNotDraw方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If this view doesn't do any drawing on its own, set this flag to</span></span><br><span class="line"><span class="comment"> * allow further optimizations. By default, this flag is not set on</span></span><br><span class="line"><span class="comment"> * View, but could be set on some View subclasses such as ViewGroup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Typically, if you override &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125;</span></span><br><span class="line"><span class="comment"> * you should clear this flag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> willNotDraw whether or not this View draw on its own</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释中可以看出，如果一个View不需要绘制任何内容，那个设置这个标记为true后，系统会进行相应的优化。默认情况下View没有启动这个优化标记位，但是ViewGroup会默认启动这个优化标记位。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Measure总结"><a href="#Measure总结" class="headerlink" title="Measure总结"></a>Measure总结</h3><p>顶层View向子View递归调用<code>View.measure()</code>方法，measure中又会回调<code>onMeasure()</code>方法</p><ul><li><p>MeasureSpec：测量模式和size的一个组合体，其中SpecMode只有三种</p><blockquote><p>MeasureSpec.EXACTLY:：父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize指定的值，对应于LayoutParams中的match_parent和具体的数值这两种模式</p><p>MeasureSpec.AT_MOST：父容器指定了一个可用大小的SpecSize，View的大小不能大于这个值，具体是什么看不同View的具体实现。对应于LayoutParams中的wrap_content</p><p>MeasureSpec.UNSPECIFIED：父容器对View不会有任何限制，要多大给多大，一般用于系统内部，表示一种测量状态</p></blockquote></li><li><p>View的measure方法是final的，View子类只能在onMeasure方法中完成自己测量逻辑</p></li><li><p>最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的（LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize为物理屏幕大小）</p></li><li><p>ViewGroup类提供了measureChild，measureChild和measureChildWithMargins方法，简化了父子View的尺寸计算</p></li><li><p>只要是ViewGroup的子类就必须要求LayoutParams继承子MarginLayoutParams，否则无法使用layout_margin参数</p></li><li><p>View布局的大小由父布局和子view共同决定（父布局的MeasureSpec和子View的LayoutParams）</p></li></ul><h3 id="Layout总结"><a href="#Layout总结" class="headerlink" title="Layout总结"></a>Layout总结</h3><p>类似Measure，都是从顶层View向子View递归调用<code>View.layoutt()</code>方法，在layout中又会回调<code>onLayout()</code>方法</p><ul><li>View.layout方法可被重载，ViewGroup.layout为final的不可重载，ViewGroup.onLayout为abstract的，子类必须重载实现自己的位置逻辑</li><li>measure操作完成后得到的是对每个View经测量过的measuredWidth和measuredHeight，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的</li><li>使用View的getWidth()和getHeight()方法来获取View测量的宽高，必须保证这两个方法在onLayout流程之后被调用才能返回有效值</li></ul><h3 id="Draw总结"><a href="#Draw总结" class="headerlink" title="Draw总结"></a>Draw总结</h3><ul><li>6个步骤：<ol><li>画出背景background</li><li>判断是否需要画边缘的渐变效果</li><li>画出当前View需要显示的内容，调用onDraw()来实现</li><li>调用dispatchDraw()方法，进入子视图的draw逻辑</li><li>如果需要花边缘渐变效果，则在这里画</li><li>绘制装饰（如滚动条）</li></ol></li><li>View默认不会绘制任何内容，真正的绘制都需要自己在子类中实现。</li><li>View默认不会绘制任何内容，真正的绘制都需要自己在子类中实现</li><li>默认情况下子View的ViewGroup.drawChild绘制顺序和子View被添加的顺序一致，但是你也可以重载ViewGroup.getChildDrawingOrder()方法提供不同顺序</li></ul><h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p><strong>Android开发艺术探索</strong></p><p><a href="https://www.cnblogs.com/tiger-wang-ms/p/6543418.html" target="_blank" rel="noopener">源码分析篇 - Android绘制流程（二）measure、layout、draw流程</a><br><a href="https://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="noopener">Android应用层View绘制流程与源码分析</a></p><p><a href="https://blog.csdn.net/asdgbc/article/details/48139233" target="_blank" rel="noopener">FrameLayout布局绘制流程解析</a></p><p><a href="https://blog.csdn.net/qibin0506/article/details/49245601" target="_blank" rel="noopener">View测量机制详解—从DecorView说起</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android View事件分发分析</title>
      <link href="/2020/02/07/Android%20View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/07/Android%20View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="View事件分发源码"><a href="#View事件分发源码" class="headerlink" title="View事件分发源码"></a>View事件分发源码</h1><p>这次没有脑图，因为涉及不到很多方法，因为就那么几个方法</p><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><p>事件分发的三个重要方法：</p><ol><li><code>public boolean dispatchTouchEvent(MotionEvent event)</code><br> 用来进行事件的分发，如果事件能够传到当前View，此方法一定调用，返回结果受当前View的onTouchEvent和下级View（子View）的dispatchTouchEvent方法的影响</li><li><code>public boolean onInterceptTouchEvent(MotionEvent event)</code><br> 在dispatchTouchEvent方法的内部调用，用来判断是否拦截这个事件，如果当前View拦截了这个事件，那么在同一个事件序列中，此方法不会再被调用。返回结果表示是否拦截当前事件</li><li><code>public boolean onTouchEvent(MotionEvent event)</code><br> 在dispatchTouchEvent方法中调用，用来处理点击事件。返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件</li></ol><h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><p>对于一个点击事件来说，传递顺序是Activity-&gt;Window-&gt;View，也就是事件总是先传给Activity，然后给Window，最后到达View，Activity和Window都是默认不处理的，到达View后，先是根View，再是ViewGroup、子View，当前面都不拦截处理，最后会到达最后一个子View，如果这个子View不消耗这个事件，事件又会往回传，最终又回到Activity。</p><p>先看<strong>Activity中的dispatchTouchEvent方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将事件默认交付给所附属的Window进行分发，如果返回true，事件循环结束</span></span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//附属Window的dispatch方法返回false（事件没有被处理），则事件交由Activity的onTouchEvent方法处理，Window时不会处理这个事件的，只会传递</span></span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWindow.shouldCloseOnTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">        finish();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity默认调用了所附属Window的Dispatch方法，由于Window只是个抽象类，所以这里调用的也就是个抽象方法<code>public abstract boolean superDispatchTouchEvent(MotionEvent event);</code>，所以看Window的唯一实现类PhoneWindow（原因如下）</p><blockquote><p>The only existing implementation of this abstract class is<br>android.view.PhoneWindow, which you should instantiate when needing a<br>Window.</p></blockquote><p>所以接着看PhoneWindow中的superDispatchTouchEvent方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the top-level view of the window, containing the window decor.</span></span><br><span class="line"><span class="keyword">private</span> DecorView mDecor;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Window并没有做什么事情，就直接进行了事件的分发，通过源码知道mDecor是一个DecorView对象，而且还是这个Window最顶层的View</p><p>接着看DecorView中的superDispatchTouchEvent方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DecorView也是什么都不做，直接调用了父类的dispatchTouchEvent方法，那么DecorView的父类到底是什么？</p><p><code>public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks</code><br>通过源码知道，DecorView是一个继承FrameLayout，FrameLayout就是一个View的子类，所以事件最后到了View。其实DecorView是Window的顶层View，这个View就是我们系统为Window内置的View，而我们在Activity中通过setContentView方法设置的Activity的布局就是DecorView的一个子View。</p><p>言归正传，DecorView中调用了父类的dispatchTouchEvent方法，那么我们接着看它父类中的dispatch方法。</p><p>DecorView是继承FrameLayout的，到FrameLayout中发现，这里面并没有dispatchTouchEvent方法，那么DecorView是调用的哪里的呢？其实FrameLayout这个View是继承于ViewGroup的，在FrameLayout中并没有重写这个dispatchTouchEvent方法，所以DecorView调用父类的dispatchTouchEvent方式其实就是ViewGroup中的</p><p>那好，接着看这个ViewGroup中的dispatchTouchEvent方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个成员变量在ViewGroup中没找到定义，最后看到View源码时，其实是来自View的</span></span><br><span class="line">    <span class="comment">//mInputEventConsistencyVerifier是否为null，通过查找这个类，它其实是用来检查事件是否是通过输入传进的，这个不是View事件分发的重点，就先不管了</span></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the event targets the accessibility focused view and this is it, start</span></span><br><span class="line">    <span class="comment">// normal event dispatch. Maybe a descendant is what will handle the click.</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认返回值是false</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//这里也是个检查，一般返回的是true</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle an initial down.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            <span class="comment">//重置FLAG_DISALLOW_INTERCEPT这个标记位</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查是否拦截</span></span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="comment">//事件类型为ACTION_DOWN或者mFirstTouchTarget不为null执行，</span></span><br><span class="line">        <span class="comment">//API27，2617行处mFirstTouchTarget进行了赋值操作</span></span><br><span class="line">        <span class="comment">//从赋值那里可以看出，当事件由ViewGroup的子View成功处理时，mFirstTouchTarget就会被赋值并指向子View，就是说当ViewGroup不拦截事件并交由子view处理，mFirstTouchTarget就不为null，反之就为null</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//判断ViewGroup自己是否需要拦截这个事件</span></span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                <span class="comment">//需要拦截时，调用自己的onInterceptTouchEvent方法</span></span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If intercepted, start normal event dispatch. Also if there is already</span></span><br><span class="line">        <span class="comment">// a view that is handling the gesture, do normal event dispatch.</span></span><br><span class="line">        <span class="comment">//如果要拦截，且有正常的处理，那就处理了吧（自己翻译吧）</span></span><br><span class="line">        <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for cancelation.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果事件没有被取消，并且ViewGroup也没有拦截</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the event is targeting accessiiblity focus we give it to the</span></span><br><span class="line">            <span class="comment">// view that has accessibility focus and if it does not handle it</span></span><br><span class="line">            <span class="comment">// we clear the flag and dispatch the event to all children as usual.</span></span><br><span class="line">            <span class="comment">// We are looking up the accessibility focused host to avoid keeping</span></span><br><span class="line">            <span class="comment">// state since these events are very rare.</span></span><br><span class="line">            <span class="comment">//这个注释可以翻译翻译，当获取焦点的view不处理这个事件时，就分发给所有的子View</span></span><br><span class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                    ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                <span class="comment">//清除之前的事件</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line">                <span class="comment">//获取子View数量</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="comment">//选择那些可以收到这个事件的View</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="comment">//遍历所有子View，进行分发</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="comment">//子View的下标，在有事件之前，ViewGroup已经有了所有的子View的信息（不然怎么绘制呢）</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">                        <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">                        <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">                        <span class="comment">// safer given the timeframe.</span></span><br><span class="line">                        <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//子View是否能够接收事件，判断子View是否在播动画，点击事件是否在子View区域内</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">//进行具体的分发，后面会看看这个方法，当子View确定要接收处理这个事件时，会返回true，这样事件就交给这个子View处理了并且跳出遍历子View这个循环；如果返回false，就继续下一个循环，分发给下一个子View</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">//在addTouchTarget对mFirstTouchTarget的赋值，前面有提到判断它是否位null的哦</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            <span class="comment">//当没有子View进行分发的时候，注意传入child的参数为null</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//后续同一系列的事件都交由这一个子View处理，或者要取消事件的时候</span></span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewGroup中这个方法代码很多（我也不知道有多少行），不要慌，慢慢分析</p><p>首先，我们先看ViewGroup到达是什么<br><code>public abstract class ViewGroup extends View implements ViewParent, ViewManager</code><br>毫无疑问，这是继承子View的一个类，而且是一个抽象类，通过名字就大概可以猜出这个类是干嘛的了，就是一个View组，包含View的。通俗的来说，View嵌套View的时候，最外层的那个View就可以叫ViewGroup。好了，接下来好好分析这个ViewGroup中重写View的dispatchTouchEvent方法吧</p><p>注意看注释哦！！！</p><p>首先我们看<code>if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)</code>这个判断，当事件类型为ACTION_DOWN或者mFirstTouchTarget不为null执行（mFirstTouchTarget是什么，看注释哦），那么若是事件为MOVE或UP的时候，这个条件判断就是false，将导致ViewGroup的onTnterceptTouchEvent不会再被调用，且同一序列中的其他事件都会默认交给它处理。还有一种特殊情况就是FLAG_DISALLOW_INTERCEPT标记位，通过requestDisallowInterceptTouchEvent方法设置，一般用于子View中。这个标记位一旦设置后，ViewGroup将无法拦截处理ACTION_DOWN以外的其他点击事件。（ViewGroup在分发事件时，如果事件是ACTION_DOWN就会重置这个标记位，将导致子View中设置的这个标记位无效，因此在面对DOWN事件，ViewGroup总会调用onInterceptTouchEvent来询问自己是否要拦截）这也就意味着ViewGroup的onInterceptTouchEvent不是总是会调用。</p><p>在注释中我们提高过mFirstTouchTarget是通过内部的addTouchTarget方法进行赋值的，我们先看看这个函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mFirstTouchTarget其实是一种单链表结构，是否被赋值影响到ViewGroup对事件的拦截策略</span></span><br><span class="line">    <span class="keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，接着看重点提到的分发给子View，不管是分发给了子View，还是没有子View接收，都是调用了dispatchTransformedTouchEvent方法，那就看看这个私有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></span><br><span class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="comment">//取消事件的处理</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the number of pointers to deliver.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If for some reason we ended up in an inconsistent state where it looks like we</span></span><br><span class="line">    <span class="comment">// might produce a motion event with no pointers in it, then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the number of pointers is the same and we don't need to perform any fancy</span></span><br><span class="line">    <span class="comment">// irreversible transformations, then we can reuse the motion event for this</span></span><br><span class="line">    <span class="comment">// dispatch as long as we are careful to revert any changes we make.</span></span><br><span class="line">    <span class="comment">// Otherwise we need to make a copy.</span></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">    <span class="comment">//真正分发的地方</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//没有子View进行分发时，就会直接调用ViewGroup的父类的dispatchTouchEvent方法（也就是View）</span></span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有子View，就分发给子View</span></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接看到方法的最后，对child进行了是否为null的判断，这个值就决定了是分发给子View还是ViewGroup自己处理这个事件，通过前面的分析，我们知道这两种情况就是分发给子View和ViewGroup没有子View的情况。当ViewGroup没有子View进行分发时，传进的child是null值，然后就调用了自己父类View的dispatchTouchEvent方法；有子View的时候就进行了子View的分发，调用子View的dispatchTouchEvent</p><p>其实不管有没有子View，最后都调用了View的dispatchTouchEvent方法（因为有子View进行分发的时候，就交给子View进行分发，然后循环调用，最后一个子View时也就没有了子View），那么就看看View的dispatchTouchEvent方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        <span class="comment">//ListenerInfo就是那些onClik、onLongClick，等会可以看看</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="comment">//检查ListenerInfo、其中的OnTouchListener是否为null，onTouchListener是否返回true</span></span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有当OnTouchListener返回false才会调用onTouchEvent方法</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class="line">    <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span></span><br><span class="line">    <span class="comment">// of the gesture.</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法虽然看着代码多，但是逻辑很简单，因为到了这里就是纯粹的View，就没ViewGroup那么多事了，它无法再往下传递事件，就只有处不处理事件</p><p>首先判断ListenerInfo是否为null、有没有设置OnTouchListener，如果OnTouchListenter中的onTouch方法返回true，那么onTouchEvent就不会被调用（说明OnTouchListener优先级高于onTouchEvent），ListenerInfo就是很多监听接口集合类，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> OnFocusChangeListener mOnFocusChangeListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;OnLayoutChangeListener&gt; mOnLayoutChangeListeners;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> OnScrollChangeListener mOnScrollChangeListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; mOnAttachStateChangeListeners;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OnClickListener mOnClickListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> OnLongClickListener mOnLongClickListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> OnContextClickListener mOnContextClickListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> OnCreateContextMenuListener mOnCreateContextMenuListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnKeyListener mOnKeyListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnTouchListener mOnTouchListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnHoverListener mOnHoverListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnGenericMotionListener mOnGenericMotionListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnDragListener mOnDragListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnSystemUiVisibilityChangeListener mOnSystemUiVisibilityChangeListener;</span><br><span class="line"></span><br><span class="line">    OnApplyWindowInsetsListener mOnApplyWindowInsetsListener;</span><br><span class="line"></span><br><span class="line">    OnCapturedPointerListener mOnCapturedPointerListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中就有OnTouchListener、OnClickListener、OnLongClickListener这些常用的监听接口</p><p>接着看onTouchEvent方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是View不可用状态下的点击事件</span></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">        <span class="comment">// events, it just doesn't respond to them.</span></span><br><span class="line">        <span class="keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果设置有代理，会调用mTouchDelegate.onTouchEvent(event)</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//clickable为true就会消耗事件了</span></span><br><span class="line">    <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        <span class="comment">//具体处理</span></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    ....</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Only perform take click actions if we were in the pressed state</span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                            <span class="comment">// performClick directly. This lets other visual state</span></span><br><span class="line">                            <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                <span class="comment">//UP的时候出发performClick方法，如果设置了OnClickListener，内部就会调用onClick方法</span></span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="comment">//DOWN事件处理</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                <span class="comment">//取消事件的处理</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">//MOVE事件处理</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是判断View是否处于不可用的状态（比如disable），这种情况下照样会消耗点击事件，尽管看起来不可用。接着看View是否有代理。然后就是onTouchEvent的具体处理了，当clickable为true和(viewFlags &amp; TOOLTIP) == TOOLTIP的时候，就可以消耗事件了。其中clickable是这样定义的<code>final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</code>也就是当View的CLICKABLE、LONG_CLICKABLE、CONTEXT_CLICKABLE为true就可以消耗了（这些可以通过setClickable、setLongClickable来设置），而TOOLTIP是表示事件的显示的（悬浮、长停）</p><p>当ACTION_UP发生时，会出发performClick方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        <span class="comment">//当设置了OnClickListener时，对调用其onClick方法</span></span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">    notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这就是点击事件分发的整个流程了。其实点击事件分发没有什么难的，就是一层一层往下传递，交给下面的，如果处理不了再返回来，整个传递过程Window只是参数传递，不会处理，而Activity在View不处理的时候会自己处理（重写onTouchEvent方法），而到了View，先是根View（DecorView)是一个ViewGroup，你自己的通过setContentView设置的布局只是它的一个子View（但也是个ViewGroup），所以从DecorView开始，就先是ViewGroup的事件分发，然后子View进行分发，一直到最后一个子View不能进行分发为止</p><h2 id="感谢任玉刚大神的Android开发艺术探索"><a href="#感谢任玉刚大神的Android开发艺术探索" class="headerlink" title="感谢任玉刚大神的Android开发艺术探索"></a>感谢任玉刚大神的<strong>Android开发艺术探索</strong></h2>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Service相关总结</title>
      <link href="/2020/02/07/Android%20Service%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Android%20Service%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Service相关总结"><a href="#Service相关总结" class="headerlink" title="Service相关总结"></a>Service相关总结</h1><h2 id="Service的用法"><a href="#Service的用法" class="headerlink" title="Service的用法"></a>Service的用法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>Service是Android中实现程序后台运行的解决方案，适合执行那些不需要和用户进行交互而且要求长期运行的任务</li><li>服务不依赖于任何用户界面</li><li>服务不是运行在一个独立的进程，而是依赖于创建服务时所在的应用程序进程，当应用程序被杀掉，服务也会停止运行</li><li>服务默认运行在主线程</li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>首先新建一个MyService继承自Service，重写父类的onCreate、onStartCommand、onDestroy</p><h2 id="Service的生命周期"><a href="#Service的生命周期" class="headerlink" title="Service的生命周期"></a>Service的生命周期</h2><h2 id="Service的源码分析"><a href="#Service的源码分析" class="headerlink" title="Service的源码分析"></a>Service的源码分析</h2><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li><p>service生命周期<br> <a href="https://upload-images.jianshu.io/upload_images/4061843-bdf0da877481143a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-bdf0da877481143a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两种启动方式的比较"></a>两种启动方式的比较</p><p> 不管哪种方法，onCreate只执行一次；在单独的startService的时候，onStartCommand可以执行多次（每次starService都会调用）；在stopService的时候，onDestroy会直接调用，（但是如果使用了bindService，必须先取消绑定unbindService，否则无法销毁服务）；在单独的bindService的时候，bindService会调用onBind，onBind只会调用一次，且onBind会返回一个IBind接口实例，用于操作服务；在unbindService的时候，onDestory也会调用</p><p> 如果一个服务同时使用了startService和bindService，那么就必须同时调用stopService、unbindService，onDestroy才会调用。此时是startService、onCreate、onStartCommand、bindService、onBind、unbindService、onUnbind、stopService、onDestroy</p><p> 在Service每一次的开启关闭过程中，只有onStart可被多次调用(通过多次startService调用)，其他onCreate，onBind，onUnbind，onDestory在一个生命周期中只能被调用一次</p></li><li><p>说说Activity、Intent、Service 是什么关系<br> Activity用于和用户交互的界面，是看得见的，每一个Activity都被实现为一个单独的类，这些类都是从Activity基类中继承来的，Activity类会显示由视图控件组成的用户接口，并对视图控件的事件做出响应。</p><p> Intent的调用是用来进行架构屏幕之间的切换的。Intent是描述应用想要做什么。Intent数据结构中两个最重要的部分是动作和动作对应的数据，一个动作对应一个动作数据，Intent主要用于组件之间的通信和数据传递</p><p> Service用于后台服务和一些前台的服务，是运行在后台的代码，不能与用户交互，可以运行在自己的进程，也可以运行在其他应用程序进程的上下文里。需要通过某一个Activity或者其他Context对象来调用。</p><p> Activity跳转到Activity，Activity启动Service，Service打开Activity都需要Intent表明跳转的意图，以及传递参数，Intent是这些组件间信号传递的承载，Activity和Service都是Conttext类的子类ContextWrapper的子类，都不能进行耗时操作，都运行在主线程之间。</p></li><li><p>IntentService原理以及应用场景<br> IntentService相比父类Service而言，最大特点是其回调函数onHandleIntent中可以直接进行耗时操作，不必再开线程。在onCreate的时候，初始化了一个HandlerThread（工作线程或子线程），通过HandlerThread的消息队列Looper来初始化ServiceHandler（就是一个Handler），之后handleMessage，包括onHandleIntent等函数都运行在工作线程中，每次启动的时候都会执行onStartCommand方法，而onStartCommand又会调用onStart，发送消息到ServiceHandler中处理（ServiceHandler是拥有HandlerThread的Looper的），handleMessage中onHandleIntent处理完了后，就会自我销毁，回调onDestroy。如果多次调用onHandleIntent函数（也就是有多个耗时任务要执行），多个耗时任务会按顺序依次执行。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在子线程中执行</span></span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            <span class="comment">//然后自我结束服务</span></span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">//会创建一个HandlerThread，持有Looper的线程，初始化的时候指定线程名</span></span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        <span class="comment">//用线程的Looper来初始化ServiceHandler</span></span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每次onStart的时候就会发送一条消息到Handler的Looper中，这样就保证了有序执行</span></span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//销毁的时候退出队列</span></span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> IntentService是一种无状态的Service，不支持binService（支持的话就违背了IntentService的设计规范）。例如在之前做的app中，有一个需求是下载某段时间用户保存的图片，下载完成后显示在imageView中；一般需要下载的图片有很多，每下一个图片就是一个线程，下载完后立即显示出来，所以肯定希望下载是按顺序依次下载，这样用户体验就比较好。当时的处理方式欠妥，直接开多个线程去下载，在前一个图片下载完成之前，其他线程必须等待；这样虽然也可以实现功能，但效率上不高，甚至可能出现ANR（具体代码逻辑是，如果后面的线程获得了cpu,而前面的图片还没下完，则等待；假设前一张图片没下完，而后面的线程一直获得cpu，就有问题）。</p></li><li><p>Service的开启方式 （1）startService()，（2）bindService()<br> startService和bindService是启动Service的两种方式，不同之处在于startService只能通知服务启动，只能通过stopService来停止服务，但是bindService可以通过IBind接口获取Service实例，来进行Activity和Service的通信，以及对Service的一些管理操作，可以多个Activity绑定Service。当没有Activity绑定才会自动销毁。两者都只会调用一次onCreate，但两者的模式都是独立的。</p></li><li><p>如何保证Service不被杀死？比较省电的方式是什么<br> （1）提升Service的优先级</p><p> ​            intent-filter中可以设置<code>android:priority=&quot;1000&quot;</code>来提升优先级，1000是最高值  </p><p> （2）提升Service的进程优先级，提升进程优先级，来防止进程的回收  </p><p> （3）在onDestroy中重启Service<br> （4）onStartCommand中手动返回START_STICKY，进程被杀死的时候没有效果  </p><p> （5）Application加上Persistent属性<br> （6）监听系统广播判断Service状态<br> （7）修改权限为系统应用（流氓）<br> （8）双进程Service： 让2个进程互相保护**，其中一个Service被清理后，另外没被清理的进程可以立即重启进程<br> （9）加上两个类似于守护进程的Service， 分别检查Service的运行状态，注册响应的广播，对其进行守护,一旦发现没有运行就将其启动.<br> （10）QQ黑科技: 在应用退到后台后，另起一个只有 1 像素的页面停留在桌面上，让自己保持前台状态，保护自己不被后台清理工具杀死</p><p> 省电方式：不知道</p></li><li><p>怎么在Service中创建Dialog对话框<br> 以系统对话框的形式弹出</p><p> <code>dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);</code></p><p> 提升为系统级的对话框</p></li><li><p>Service 与 IntentService 的区别<br> Service既不是线程，也不是进程，而是依附于主线程的一个组件。Service用于在后台处理一些逻辑业务，不需要和用户进行交互。</p><p> IntentService继承于Service，用于处理异步请求，调用startService（intent）方法后，将请求通过intent传递给intentService，intentService在onCreate方法中构建一个HandlerThread的子线程，用于处理传递过来的请求。通过HandlerThread单独开启一个线程来依次处理所有Intent请求对象所对应的任务。这样以免事务处理阻塞主线程（ＡＮＲ）。执行完所一个Intent请求对象所对应的工作之后，如果没有新的Intent请求达到，则自动停止Service；否则执行下一个Intent请求所对应的任务。</p><p> IntentService在处理事务时，还是采用的Handler方式，创建一个名叫ServiceHandler的内部Handler，并把它直接绑定到HandlerThread所对应的子线程。 ServiceHandler把处理一个intent所对应的事务都封装到叫做onHandleIntent的虚函数；因此我们直接实现虚函数onHandleIntent，再在里面根据Intent的不同进行不同的事务处理就可以了。另外，IntentService默认实现了Onbind（）方法，返回值为null</p></li><li><p>简单说说 CompletionService 的作用和使用场景及原理<br> CompletionService 是一个泛型接口，其实现类是 ExecutorCompletionService，其主要解决的场景是：主线程提交多个任务然后希望有任务完成就处理结果，并且按照任务完成顺序逐个处理（譬如并发请求返回刷新UI的操作，就可以谁请求成功就开始刷而不用等待所有OK才刷等）</p><p> ExecutorCompletionService 实现类依赖于 Executor 完成实际的任务提交执行，自己主要负责结果的排队处理，AbstractExecutorService 的 invokAny 实现就依赖此类，ExecutorCompletionService 内部有一个额外的队列，每个提交给 Executor 的任务都是通过继承 FutureTask 封装过的，FutureTask 在任务结束后会回调 done 方法，所以 ExecutorCompletionService 就在继承 FutureTask 封装重写的 done 方法中将当前 FutureTask 加入额外队列，然后我们通过其 take 或者 poll 方法获取的实质就是从这个额外队列中取数据</p></li><li><p>Service有没有隐式启动方式，（从某一个版本开始）为什么没有<br> 现在没有，5.0之前有</p><p> 可能会引发安全性问题，如果是隐式启动service，可能会导致系统进程挂掉，出现不断重启的现象。所以在5.0之后，Google在隐式启动Service的时候抛出了异常</p></li></ol><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Service源码分析</title>
      <link href="/2020/02/07/Android%20Service%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/07/Android%20Service%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Service源码分析"><a href="#Service源码分析" class="headerlink" title="Service源码分析"></a>Service源码分析</h1><p><a href="http://naotu.baidu.com/file/2b9806029008a9bbead841f4893d12d3?token=f34d86e3c5c4eaf2" target="_blank" rel="noopener">Service脑图</a></p><h2 id="Service的启动过程"><a href="#Service的启动过程" class="headerlink" title="Service的启动过程"></a>Service的启动过程</h2><p>我们通过<code>startService(Intent service);</code>方法来启动一个Service，跟进源码。调用的是ContextWrapper.startService()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.startService(service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并没有做什么事情，ContextWrapper是这里用到的一种桥接模式，所有相关函数（Activity相关、Service等）的调用都会先到这个类，但实际还是Context来实现的。调用mBase的startService方法，mBase是一个Context对象，而ContextImpl才是Context的具体实现类，是在Activity创建的时候通过attach关联起来的。</p><p>接下来看看ContextImpl的startService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果系统进程直接调用该方法，就会抛出警告</span></span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="comment">//false，不需要前台进程；mUser是一个UserHandle</span></span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, <span class="keyword">false</span>, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, <span class="keyword">boolean</span> requireForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Service的验证</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        <span class="comment">//离开进程准备</span></span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//重点，通过AMS来startService，返回需要的ComPonentName</span></span><br><span class="line">        <span class="comment">//mMainThread.getApplicationThread()主线程的ApplicationThread</span></span><br><span class="line">        ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), requireForeground,</span><br><span class="line">                        getOpPackageName(), user.getIdentifier());</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextImpl的startService方法调用后，会接着调用内部的startServiceCommon方法，在startServiceCommon中先进行了一些少数的准备，接着调用ActivityManager.getService().startService()方法，ActivityManager.getService()是IActivityManager，其实例就是ActivityManagerService对象</p><p>接着看AMS（ActivityManagerService)的startService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">boolean</span> requireForeground, String callingPackage, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//一些检验</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//进程id</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//mServices是一个ActivityServices对象</span></span><br><span class="line">            res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                    resolvedType, callingPid, callingUid,</span><br><span class="line">                    requireForeground, callingPackage, userId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AMS的startService方法中，在一个synchronized代码块中，获取了需要用到的进程id、Binder标识等，然后通过mServices这个ActivityServices对象，调用了其startServiceLocked()方法，ActivityServices跟ActivityStarter的作用是类似的，用来辅助AMS管理Service的类，例如缓存、启动、绑定、停止等</p><p>接着看ActivityServices的startServiceLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">boolean</span> fgRequired, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//检索Service</span></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg, <span class="keyword">false</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取ServiceRecord，一个Service的记录，一直贯穿整个启动过程</span></span><br><span class="line">    ServiceRecord r = res.record;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限检查</span></span><br><span class="line">    <span class="keyword">if</span> (mAm.mPermissionReviewRequired) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r, callingPackage,</span><br><span class="line">                callingUid, service, callerFg, userId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ServiceMap smap = getServiceMapLocked(r.userId);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//接着调用内部的startServiceInnerLocked方法</span></span><br><span class="line">    ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startServiceLocked方法前面基本都是一些检查、检索，到最后又调用了内部的startServiceInnerLocked方法</p><p>接着看ActivityServices的startServiceInnerLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ServiceState stracker = r.getTracker();</span><br><span class="line">    <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stracker.setStarted(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    r.callStart = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">        r.stats.startRunningLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后续的工作完成</span></span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!!"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要为前台Service的处理</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; addToStarting) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callerFg || r.fgRequired) &#123;</span><br><span class="line">        smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面并没有做太多的工作，具体的启动过程也没有</p><p>所以要接着看ActivityServices的bringUpServiceLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//检验，其他情况的处理</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Service is now being launched, its package can't be stopped.</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    String hostingType = <span class="string">"service"</span>;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"bringUpServiceLocked: appInfo.uid="</span> + r.appInfo.uid</span><br><span class="line">                    + <span class="string">" app="</span> + app);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                <span class="comment">//真正启动的地方</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not running -- get it started, and enqueue this service record</span></span><br><span class="line">    <span class="comment">// to be executed when the app comes up.</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bringUpServiceLocked方法中做了一些其他情况的处理，但真正启动Service却是在realStartServiceLocked方法中</p><p>接着看ActivityServices.realStartServiceLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.services.add(r);</span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);</span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    updateServiceForegroundLocked(r.app, <span class="comment">/* oomAdj= */</span> <span class="keyword">false</span>);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">            String nameTerm;</span><br><span class="line">            <span class="keyword">int</span> lastPeriod = r.shortName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            nameTerm = lastPeriod &gt;= <span class="number">0</span> ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">            EventLogTags.writeAmCreateService(</span><br><span class="line">                    r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        <span class="comment">//通过ApplicationThread来创建一个Service</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Application dead when creating service "</span> + r);</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!created) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            <span class="comment">//出错时停止Service的一些操作</span></span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cleanup.</span></span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Retry.</span></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里就是后面要分析的绑定过程</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the service is in the started state, and there are no</span></span><br><span class="line">    <span class="comment">// pending arguments, then fake up one so its onStartCommand() will</span></span><br><span class="line">    <span class="comment">// be called.</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通过该方法来调用Service其他的方法，如onStartCommand()</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>realStartServiceLocked包括了Service的很多操作，先是通过ApplicationThread.scheduleCreateService来创建了Service，接着通过requestServiceBindingsLocked方法进行绑定，再通过sendServiceArgsLocked方法进行其他方法的调用，如onStartCommand()。在sendServiceArgsLocked方法中，又会调用ActivityServices.sendServiceArgsLocked()方法，接着通过ApplicationThread.scheduleServiceArgs()方法，最后调用了Service的onStartCommand方法。</p><p>由于分析的是启动过程，所以这里主要看<code>app.thread.scheduleCreateService(r, r.serviceInfo， mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState);</code>这行代码，app.thread是IApplicationThread，它的实现类是ApplicationThread，这个类是ActivityThread的内部类</p><p>接着在ActivityThread中看ApplicationThread的scheduleCreateService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">        updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">        CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">        s.token = token;</span><br><span class="line">        s.info = info;</span><br><span class="line">        s.compatInfo = compatInfo;</span><br><span class="line">        <span class="comment">//发送CREATE_SERVICE的消息创建Service</span></span><br><span class="line">        sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>scheduleCreateService方法代码很少也很简单，创建了一个CreateServiceData的对象，这个对象就是创建Service时需要的信息，然后调用sendMessage方法</p><p>接着看ActivityThread的sendMessage方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">        TAG, <span class="string">"SCHEDULE "</span> + what + <span class="string">" "</span> + mH.codeToString(what)</span><br><span class="line">        + <span class="string">": "</span> + arg1 + <span class="string">" / "</span> + obj);</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个sendMessage方法没啥，后面又重载了一个，所以重点在第二个sendMessage方法，基本上四大组件最后都会在ActivityThread中通过这个函数发送消息。这里，就是重新打包了一下Message，然后通过mH来发送。mH是一个Handler，是ActivityThread内部的一个类，继承自Hanlder。发送完消息后，自然要在H中的来处理消息。</p><p>接着看H.handleMessage方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">//这里主要留着关于Service的，包括create、bind、unbind、stop等</span></span><br><span class="line">            <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">"serviceCreate: "</span> + String.valueOf(msg.obj)));</span><br><span class="line">                handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BIND_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"serviceBind"</span>);</span><br><span class="line">                handleBindService((BindServiceData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UNBIND_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"serviceUnbind"</span>);</span><br><span class="line">                handleUnbindService((BindServiceData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SERVICE_ARGS:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">"serviceStart: "</span> + String.valueOf(msg.obj)));</span><br><span class="line">                handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOP_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"serviceStop"</span>);</span><br><span class="line">                handleStopService((IBinder)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们发送的消息是CREATE_SERVICE，所以就会调用<code>handleCreateService((CreateServiceData)msg.obj);</code><br>在这里可以看见，处理了很多消息，关于Activity、Window等各种的，所以这个H很重要。</p><p>接着看ActivityThread的handleCreateService()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        <span class="comment">//这里就创建了Service对象，通过类加载器</span></span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Creating service "</span> + data.info.name);</span><br><span class="line">        <span class="comment">//创建了ContextImpl对象</span></span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        <span class="comment">//和Application等关联</span></span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManager.getService());</span><br><span class="line">        <span class="comment">//create</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        <span class="comment">//放入Service的列表缓存</span></span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过AMS来通知创建完成</span></span><br><span class="line">            ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to create service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，终于看见了Service的创建了，这里的代码很简单。拿到类加载器器，接着通过类加载器创建了Serivce，然后创建ContextImpl对象通过Service的attach关联，最后调用Service的onCreate。</p><h2 id="Service的绑定过程"><a href="#Service的绑定过程" class="headerlink" title="Service的绑定过程"></a>Service的绑定过程</h2><p>首先<code>bindService(Intent service, ServiceConnection conn, int flags);</code>，接着就是ContentWrapper中bindService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.bindService(service, conn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没啥看的，跟Service创建讲的一样，最终还是在ContextImpl中</p><p>接着看ContentImpl中的bindService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, mMainThread.getHandler(),</span><br><span class="line">            Process.myUserHandle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这里面并没有什么太多的东西，需要注意的一点就是mMainThread.getHandler()，mMainThread是一个ActivityThread对象，getHandler返回的是ActivityThread中的H，返回了bindServiceCommon()</p><p>接着看ContextImpl.bindServiceCommon方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags, Handler</span></span></span><br><span class="line"><span class="function"><span class="params">        handler, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//在这里将ServiceConnection转换为了ServiceDispatcher.InnerConnection对象，且初始化了ServiceDispatcher对象</span></span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//还是通过AMS来绑定</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManager.getService().bindService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，首先是将客户端的ServiceConnection对象转换为ServiceDispatcher.InnerConnection对象，之所以不能直接使用ServiceConnection对象是因为服务的绑定有可能是跨进程的，跨进程必须借助Binder，而ServiceDispatcher.InnerConnection刚好充当了Binder的角色。ServiceDispatcher起着链接ServiceConnection和InnerConnection的作用（在取消绑定的时候ServiceDispatcher也会用到）这个过程是由LoadedApk的getServiceDispatcher方法完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title">getServiceDispatcher</span><span class="params">(ServiceConnection c,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, Handler handler, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//ServiceConnection和ServiceDispatcher是一一对应的</span></span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Returning existing dispatcher "</span> + sd + <span class="string">" for conn "</span> + c);</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个ServiceConnection对应的ServiceDispathcer没有就创建一个</span></span><br><span class="line">            sd = <span class="keyword">new</span> ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Creating new dispatcher "</span> + sd + <span class="string">" for conn "</span> + c);</span><br><span class="line">            <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统会首先查找是否存在相同的ServiceConnection，不存在就重新创建一个ServiceDispathcer对象并存储在mServices（<code>private final ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices = new ArrayMap&lt;&gt;();</code>）中，在SerivceDispatcher的内部又保存了ServiceConnection和InnerConnection。当Service和客户端建立连接后，会通过InnerConnection来调用ServiceConnection中的onServiceConnected方法，又可能跨进程</p><p>言归正传，最后还是得通过AMS来进行绑定</p><p>接着看AMS的bindService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里AMS并没有做什么实际的事，交给了mServices，mServices是一个ActivityServices对象，调用了其bindServiceLocked方法</p><p>接着看ActivityServices的bindServiceLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ActivityRecord activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">        activity = ActivityRecord.isInStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Binding with unknown activity: "</span> + token);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//检索Service，获取其状态</span></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType, callingPackage, Binder.getCallingPid(),</span><br><span class="line">                Binder.getCallingUid(), userId, <span class="keyword">true</span>, callerFg, isBindExternal);</span><br><span class="line">    ...</span><br><span class="line">    ServiceRecord s = res.record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> permissionsReviewRequired = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run,</span></span><br><span class="line">    <span class="comment">// we schedule binding to the service but do not start its process, then</span></span><br><span class="line">    <span class="comment">// we launch a review activity to which is passed a callback to invoke</span></span><br><span class="line">    <span class="comment">// when done to start the bound service's process to completing the binding.</span></span><br><span class="line">    <span class="keyword">if</span> (mAm.mPermissionReviewRequired) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                s.packageName, s.userId)) &#123;</span><br><span class="line"></span><br><span class="line">            permissionsReviewRequired = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Show a permission review UI only for binding from a foreground app</span></span><br><span class="line">            <span class="keyword">if</span> (!callerFg) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"u"</span> + s.userId + <span class="string">" Binding to a service in package"</span></span><br><span class="line">                        + s.packageName + <span class="string">" requires a permissions review"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ServiceRecord serviceRecord = s;</span><br><span class="line">            <span class="keyword">final</span> Intent serviceIntent = service;</span><br><span class="line"></span><br><span class="line">            RemoteCallback callback = <span class="keyword">new</span> RemoteCallback(</span><br><span class="line">                    <span class="keyword">new</span> RemoteCallback.OnResultListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Bundle result)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> identity = Binder.clearCallingIdentity();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!mPendingServices.contains(serviceRecord)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// If there is still a pending record, then the service</span></span><br><span class="line">                            <span class="comment">// binding request is still valid, so hook them up. We</span></span><br><span class="line">                            <span class="comment">// proceed only if the caller cleared the review requirement</span></span><br><span class="line">                            <span class="comment">// otherwise we unbind because the user didn't approve.</span></span><br><span class="line">                            <span class="keyword">if</span> (!mAm.getPackageManagerInternalLocked()</span><br><span class="line">                                    .isPermissionsReviewRequired(</span><br><span class="line">                                            serviceRecord.packageName,</span><br><span class="line">                                            serviceRecord.userId)) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">//接着调用该方法进行绑定</span></span><br><span class="line">                                    bringUpServiceLocked(serviceRecord,</span><br><span class="line">                                            serviceIntent.getFlags(),</span><br><span class="line">                                            callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                                    <span class="comment">/* ignore - local call */</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//取消绑定</span></span><br><span class="line">                                unbindServiceLocked(connection);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            Binder.restoreCallingIdentity(identity);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line">            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK</span><br><span class="line">                    | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">            intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName);</span><br><span class="line">            intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PERMISSIONS_REVIEW) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"u"</span> + s.userId + <span class="string">" Launching permission review for package "</span></span><br><span class="line">                        + s.packageName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mAm.mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mAm.mContext.startActivityAsUser(intent, <span class="keyword">new</span> UserHandle(userId));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (unscheduleServiceRestartLocked(s, callerApp.info.uid, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"BIND SERVICE WHILE RESTART PENDING: "</span></span><br><span class="line">                    + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (!s.hasAutoCreateConnections()) &#123;</span><br><span class="line">                <span class="comment">// This is the first binding, let the tracker know.</span></span><br><span class="line">                ServiceState stracker = s.getTracker();</span><br><span class="line">                <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stracker.setBound(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                            s.lastActivity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAm.startAssociationLocked(callerApp.uid, callerApp.processName, callerApp.curProcState,</span><br><span class="line">                s.appInfo.uid, s.name, s.processName);</span><br><span class="line">        <span class="comment">// Once the apps have become associated, if one of them is caller is ephemeral</span></span><br><span class="line">        <span class="comment">// the target app should now be able to see the calling app</span></span><br><span class="line">        mAm.grantEphemeralAccessLocked(callerApp.userId, service,</span><br><span class="line">                s.appInfo.uid, UserHandle.getAppId(callerApp.uid));</span><br><span class="line"></span><br><span class="line">        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent);</span><br><span class="line"></span><br><span class="line">        IBinder binder = connection.asBinder();</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">        <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">            s.connections.put(binder, clist);</span><br><span class="line">        &#125;</span><br><span class="line">        clist.add(c);</span><br><span class="line">        b.connections.add(c);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity.connections == <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.connections = <span class="keyword">new</span> HashSet&lt;ConnectionRecord&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            activity.connections.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        b.client.connections.add(c);</span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            b.client.hasAboveClient = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        clist = mServiceConnections.get(binder);</span><br><span class="line">        <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">            mServiceConnections.put(binder, clist);</span><br><span class="line">        &#125;</span><br><span class="line">        clist.add(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>,</span><br><span class="line">                    permissionsReviewRequired) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                s.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.whitelistManager) &#123;</span><br><span class="line">                s.app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// This could have made the service more important.</span></span><br><span class="line">            mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities</span><br><span class="line">                    || s.app.treatLikeActivity, b.client);</span><br><span class="line">            mAm.updateOomAdjLocked(s.app, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bind "</span> + s + <span class="string">" with "</span> + b</span><br><span class="line">                + <span class="string">": received="</span> + b.intent.received</span><br><span class="line">                + <span class="string">" apps="</span> + b.intent.apps.size()</span><br><span class="line">                + <span class="string">" doRebind="</span> + b.intent.doRebind);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">            <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">            <span class="comment">// publish the connection.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.conn.connected(s.name, b.intent.binder, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failure sending service "</span> + s.shortName</span><br><span class="line">                        + <span class="string">" to connection "</span> + c.conn.asBinder()</span><br><span class="line">                        + <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is the first app connected back to this binding,</span></span><br><span class="line">            <span class="comment">// and the service had previously asked to be told when</span></span><br><span class="line">            <span class="comment">// rebound, then do so.</span></span><br><span class="line">            <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;</span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里又调用了bringUpServiceLocked方法，这个方法是不是很眼熟？在前面启动Service的时候，也会调用到这个方法，所以后面的就跟Service的启动一样了。但是我们前面讲创建的时候留了一个东西，就是Service创建成功后，绑定的方法我们并没有讲。那么就这前面的讲。</p><p>调用了ActivityServices的bringUpServiceLocked方法后，又会接着调用ActivityServices.realStartServiceLocked()，这个方法前面启动Service时也讲到过</p><p>我们再看看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    r.app = app;</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.services.add(r);</span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);</span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    updateServiceForegroundLocked(r.app, <span class="comment">/* oomAdj= */</span> <span class="keyword">false</span>);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//创建Service</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Application dead when creating service "</span> + r);</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是我们前面留着的绑定Service</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通过该方法来调用Service其他的方法，如onStartCommand()</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很熟悉了吧，但是接下来我们就不去看Service怎么创建的了。我们这里主要看Service怎样绑定的</p><p>接着ActivityServices的requestServiceBindingsLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">requestServiceBindingsLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> execInFg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=r.bindings.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!requestServiceBindingLocked(r, ibr, execInFg, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面并没有做太多的事，遍历所有的IntentBindRecord，接着还是调用重载的requestServiceBindingsLocked方法</p><p>接着看这个重载的requestServiceBindingsLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || r.app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If service is not currently running, can't yet bind.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.d(TAG_SERVICE, <span class="string">"requestBind "</span> + i + <span class="string">": requested="</span> + i.requested</span><br><span class="line">            + <span class="string">" rebind="</span> + rebind);</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            <span class="comment">//熟悉的app.thread又来了</span></span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">            <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                i.requested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = <span class="keyword">true</span>;</span><br><span class="line">            i.doRebind = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Crashed while binding "</span> + r, e);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Crashed while binding "</span> + r);</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，从ServiceRecord中拿到ApplicationThread，然后调用scheduleBindService方法</p><p>接着看ActivityThread.ApplicationThread.scheduleBindService()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleBindService</span><span class="params">(IBinder token, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> rebind, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">        updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">        BindServiceData s = <span class="keyword">new</span> BindServiceData();</span><br><span class="line">        s.token = token;</span><br><span class="line">        s.intent = intent;</span><br><span class="line">        s.rebind = rebind;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">            Slog.v(TAG, <span class="string">"scheduleBindService token="</span> + token + <span class="string">" intent="</span> + intent + <span class="string">" uid="</span></span><br><span class="line">                    + Binder.getCallingUid() + <span class="string">" pid="</span> + Binder.getCallingPid());</span><br><span class="line">        sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>熟悉的一切，跟Service的创建是一样的。在这里会调用ActivityThread的sendMessage()方法，然后重载一次，通过mH这个Handler的sendMessage发送。然后在H中的handleMessage中处理消息，接着又调用ActivityThread.handleBindService()</p><p>接着看看ActivityThread.handleBindService()这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取之前创建的Service</span></span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, <span class="string">"handleBindService s="</span> + s + <span class="string">" rebind="</span> + data.rebind);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    <span class="comment">//绑定</span></span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    <span class="comment">//通知客户端绑定成功</span></span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to bind to service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，Service通过onBind方法，就绑定完成了。然后系统会通知客户端，接着看看如何通知客户端的</p><p>AMS.publishService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，最终还是交到了ActivityServices中处理</p><p>接着看ActivityServices的publishServiceLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"PUBLISHING "</span> + r</span><br><span class="line">                + <span class="string">" "</span> + intent + <span class="string">": "</span> + service);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = <span class="keyword">true</span>;</span><br><span class="line">                b.received = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni=r.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//这里才是重点</span></span><br><span class="line">                            c.conn.connected(r.name, service, <span class="keyword">false</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            Slog.w(TAG, <span class="string">"Failure sending service "</span> + r.name +</span><br><span class="line">                                  <span class="string">" to connection "</span> + c.conn.asBinder() +</span><br><span class="line">                                  <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c.conn是ServiceDispatcher.InnerConnection</p><p>所以接着看看LoadedApk.ServiceDispatcher.InnerConnection的connected方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sd.connected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以看出，先是从mDispatcher中获取了ServiceDispatcher，然后调用了其connected方法。mDispatcher中存储着之前在ContextImpl.bindService()中将ServiceConnection转换为ServiceDispatcher.InnerConnection处创建的ServiceDispatcher</p><p>接着看LoadedApk.ServiceDispatcher的connected方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过mActivityThread post了一个RunConnection对象，mActivityThread就是一个Handler，是ActivityThread中的H（在ContextImpl的bindService中，调用bindServiceCommon时，通过mMainThread.getHandler获取，也就是在这里开始传入的），RunConnection就通过H发送到了主线程</p><p>简单看看RunConnection</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunConnection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    RunConnection(ComponentName name, IBinder service, <span class="keyword">int</span> command, <span class="keyword">boolean</span> dead) &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mService = service;</span><br><span class="line">        mCommand = command;</span><br><span class="line">        mDead = dead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCommand == <span class="number">0</span>) &#123;</span><br><span class="line">            doConnected(mName, mService, mDead);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCommand == <span class="number">1</span>) &#123;</span><br><span class="line">            doDeath(mName, mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ComponentName mName;</span><br><span class="line">    <span class="keyword">final</span> IBinder mService;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mCommand;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mDead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会调用ServiceDispatcher的doConnected方法</p><p>接着看一些LoadedApk.ServiceDispatcher.doConnected</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was an old service, it is now disconnected.</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dead) &#123;</span><br><span class="line">        mConnection.onBindingDied(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is a new service, it is now connected.</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于ServiceDispatcher保存右ServiceConnection，所以可以很方便的调用ServiceConnection的onServiceConnected方法</p><h2 id="Service的取消绑定"><a href="#Service的取消绑定" class="headerlink" title="Service的取消绑定"></a>Service的取消绑定</h2><p>从<code>unbindService(ServiceConnection conn);</code>开始，先是ContextWrapper的unbindService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">(ServiceConnection conn)</span> </span>&#123;</span><br><span class="line">    mBase.unbindService(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后接着还是ContextImpl中的unBindService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">(ServiceConnection conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将ServiceConnection转换回IServiceConnection</span></span><br><span class="line">        IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(</span><br><span class="line">                getOuterContext(), conn);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//AMS中的unbindService</span></span><br><span class="line">            ActivityManager.getService().unbindService(sd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里先是通过LoadedApk.forgetServiceDispatcher方法将ServiceConnection转换回IServiceConnection，并对ServiceDispatcher做一些预处理，如remove掉这个ServiceConnection匹配的ServiceDispatcher，接着还是到了AMS中</p><p>接着看AMS的unbindService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unbindService</span><span class="params">(IServiceConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.unbindServiceLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又交给了ActivityServices</p><p>接着看ActivityServices.unbindServiceLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">unbindServiceLocked</span><span class="params">(IServiceConnection connection)</span> </span>&#123;</span><br><span class="line">    IBinder binder = connection.asBinder();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"unbindService: conn="</span> + binder);</span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (clist.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ConnectionRecord r = clist.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//这么重要的remove</span></span><br><span class="line">            removeConnectionLocked(r, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.binding.service.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.binding.service.app.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.binding.service.app);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// This could have made the service less important.</span></span><br><span class="line">                <span class="keyword">if</span> ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                    r.binding.service.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">                    mAm.updateLruProcessLocked(r.binding.service.app,</span><br><span class="line">                            r.binding.service.app.hasClientActivities</span><br><span class="line">                            || r.binding.service.app.treatLikeActivity, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mAm.updateOomAdjLocked(r.binding.service.app, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看重要的，就知道下面是<code>removeConnectionLocked(r, null, null);</code>这个方法</p><p>接着看ActivityServices的removeConnectionLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeConnectionLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ConnectionRecord c, ProcessRecord skipApp, ActivityRecord skipAct)</span> </span>&#123;</span><br><span class="line">    IBinder binder = c.conn.asBinder();</span><br><span class="line">    AppBindRecord b = c.binding;</span><br><span class="line">    ServiceRecord s = b.service;</span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            s.connections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.connections.remove(c);</span><br><span class="line">    <span class="keyword">if</span> (c.activity != <span class="keyword">null</span> &amp;&amp; c.activity != skipAct) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.activity.connections != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c.activity.connections.remove(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.client != skipApp) &#123;</span><br><span class="line">        b.client.connections.remove(c);</span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            b.client.updateHasAboveClientLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If this connection requested whitelist management, see if we should</span></span><br><span class="line">        <span class="comment">// now clear that state.</span></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.updateWhitelistManager();</span><br><span class="line">            <span class="keyword">if</span> (!s.whitelistManager &amp;&amp; s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateWhitelistManagerLocked(s.app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            mServiceConnections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAm.stopAssociationLocked(b.client.uid, b.client.processName, s.appInfo.uid, s.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b.connections.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        b.intent.apps.remove(b.client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c.serviceDead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Disconnecting binding "</span> + b.intent</span><br><span class="line">                + <span class="string">": shouldUnbind="</span> + b.intent.hasBound);</span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; s.app.thread != <span class="keyword">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">                &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(s, <span class="keyword">false</span>, <span class="string">"unbind"</span>);</span><br><span class="line">                <span class="keyword">if</span> (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span></span><br><span class="line">                        &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">                    <span class="comment">// If this service's process is not already in the cached list,</span></span><br><span class="line">                    <span class="comment">// then update it in the LRU list here because this may be causing</span></span><br><span class="line">                    <span class="comment">// it to go down there and we want it to start out near the top.</span></span><br><span class="line">                    mAm.updateLruProcessLocked(s.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mAm.updateOomAdjLocked(s.app, <span class="keyword">true</span>);</span><br><span class="line">                b.intent.hasBound = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// Assume the client doesn't want to know about a rebind;</span></span><br><span class="line">                <span class="comment">// we will deal with that later if it asks for one.</span></span><br><span class="line">                b.intent.doRebind = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//ApplicationThread，又是这个方式调用</span></span><br><span class="line">                s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when unbinding service "</span> + s.shortName, e);</span><br><span class="line">                serviceProcessGoneLocked(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If unbound while waiting to start, remove the pending service</span></span><br><span class="line">        mPendingServices.remove(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasAutoCreate = s.hasAutoCreateConnections();</span><br><span class="line">            <span class="keyword">if</span> (!hasAutoCreate) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    s.tracker.setBound(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                            SystemClock.uptimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bringDownServiceIfNeededLocked(s, <span class="keyword">true</span>, hasAutoCreate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里面有太多的remove了，感兴趣的可以自己去分析分析。我们看重点<code>s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</code>，这里是多么熟悉，又是到ApplicationThread中</p><p>接着看ApplicationThread的scheduleUnbindService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleUnbindService</span><span class="params">(IBinder token, Intent intent)</span> </span>&#123;</span><br><span class="line">    BindServiceData s = <span class="keyword">new</span> BindServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.intent = intent;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.UNBIND_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的就都是一样的，在ActivityThread中辗转反则，最后通过ActivityThread的H发送，在H中处理消息，然后会调用ActivityThread的handleUnbindServicef方法</p><p>接着看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUnbindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取Service</span></span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="comment">//调用unBind</span></span><br><span class="line">            <span class="keyword">boolean</span> doRebind = s.onUnbind(data.intent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (doRebind) &#123;</span><br><span class="line">                    <span class="comment">//如果需要重新绑定</span></span><br><span class="line">                    ActivityManager.getService().unbindFinished(</span><br><span class="line">                            data.token, data.intent, doRebind);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//已经取消绑定</span></span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to unbind to service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释很清楚了，先获取Service，接着调用Service的onUnbind方法，接着看看AMS的serviceDoneExecuting方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"serviceDoneExecuting: Invalid service token="</span> + token);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//又去了ActivityServices</span></span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看ActivityServices的serviceDoneExecutingLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="comment">//接着调用</span></span><br><span class="line">        serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Done executing unknown service from pid "</span></span><br><span class="line">                + Binder.getCallingPid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看ActivityServices的serviceDoneExecutingLocked重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> inDestroying,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> finishing)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r</span><br><span class="line">            + <span class="string">": nesting="</span> + r.executeNesting</span><br><span class="line">            + <span class="string">", inDestroying="</span> + inDestroying + <span class="string">", app="</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">            <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r.shortName);</span><br><span class="line">    r.executeNesting--;</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line">            r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                        <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line">                <span class="comment">// Need to re-evaluate whether the app still needs to be in the foreground.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=r.app.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                        r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inDestroying) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">"doneExecuting remove destroying "</span> + r);</span><br><span class="line">                mDestroyingServices.remove(r);</span><br><span class="line">                r.bindings.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r.executeFg = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.tracker.setExecuting(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                r.tracker.clearCurrentOwner(r, <span class="keyword">false</span>);</span><br><span class="line">                r.tracker = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; !r.app.persistent) &#123;</span><br><span class="line">                r.app.services.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是各种remove，remove的消息</p><h2 id="Service的停止"><a href="#Service的停止" class="headerlink" title="Service的停止"></a>Service的停止</h2><p>从<code>stopService(Intent name);</code>开始，然后是ContextWrapper中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stopService</span><span class="params">(Intent name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.stopService(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后具体的实现是在ContextImpl中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stopService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> stopServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用了ContextImpl内部的stopServiceCommon方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stopServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这都是一些准备</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//还是AMS</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManager.getService().stopService(</span><br><span class="line">            mMainThread.getApplicationThread(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to stop service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做一些准备后，又到了AMS中的stopService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stopService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"stopService"</span>);</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.stopServiceLocked(caller, service, resolvedType, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，AMS还是交给了ActivityServices<br>接着看看ActivityServices的stopServiceLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stopServiceLocked</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"stopService: "</span> + service</span><br><span class="line">            + <span class="string">" type="</span> + resolvedType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span> &amp;&amp; callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") when stopping service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this service is active, make sure it is stopped.</span></span><br><span class="line">    <span class="comment">//确保这个Service是要停止的检查</span></span><br><span class="line">    ServiceLookupResult r = retrieveServiceLocked(service, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.record != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//内部方法调用</span></span><br><span class="line">                stopServiceLocked(r.record);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着还是调用ActivityServices内部的stopServiceLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopServiceLocked</span><span class="params">(ServiceRecord service)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//继续</span></span><br><span class="line">    bringDownServiceIfNeededLocked(service, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着还是调用ActivityServices的bringDownServiceIfNeededLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceIfNeededLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    bringDownServiceLocked(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着还是调用ActivityServices的bringDownServiceLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the service that it has been unbound.</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=r.bindings.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bringing down binding "</span> + ibr</span><br><span class="line">                    + <span class="string">": hasBound="</span> + ibr.hasBound);</span><br><span class="line">            <span class="keyword">if</span> (ibr.hasBound) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"bring down unbind"</span>);</span><br><span class="line">                    mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">                    ibr.hasBound = <span class="keyword">false</span>;</span><br><span class="line">                    ibr.requested = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//停止之前先取消绑定</span></span><br><span class="line">                    r.app.thread.scheduleUnbindService(r,</span><br><span class="line">                            ibr.intent.getIntent());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Exception when unbinding service "</span></span><br><span class="line">                            + r.shortName, e);</span><br><span class="line">                    serviceProcessGoneLocked(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.stopLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        r.app.services.remove(r);</span><br><span class="line">        <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">            updateWhitelistManagerLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceForegroundLocked(r.app, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"destroy"</span>);</span><br><span class="line">                mDestroyingServices.add(r);</span><br><span class="line">                r.destroying = <span class="keyword">true</span>;</span><br><span class="line">                mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//停止</span></span><br><span class="line">                r.app.thread.scheduleStopService(r);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when destroying service "</span></span><br><span class="line">                        + r.shortName, e);</span><br><span class="line">                serviceProcessGoneLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                TAG_SERVICE, <span class="string">"Removed service that has no process: "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">            TAG_SERVICE, <span class="string">"Removed service that is not running: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中的代码有很多，但是关键还是<code>.app.thread.scheduleStopService(r);</code>这行代码</p><p>接着看ApplicationThread中的scheduleStopService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleStopService</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    sendMessage(H.STOP_SERVICE, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，熟悉的一切，跟前面的启动、绑定、取消绑定一样，最后调用H处理消息，然后调用ActivityThread的handleStopService方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStopService</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从列表中移除Service</span></span><br><span class="line">    Service s = mServices.remove(token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Destroying service "</span> + s);</span><br><span class="line">            <span class="comment">//销毁Service</span></span><br><span class="line">            s.onDestroy();</span><br><span class="line">            s.detachAndCleanUp();</span><br><span class="line">            Context context = s.getBaseContext();</span><br><span class="line">            <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">                <span class="keyword">final</span> String who = s.getClassName();</span><br><span class="line">                ((ContextImpl) context).scheduleFinalCleanup(who, <span class="string">"Service"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通知完成停止操作</span></span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        token, SERVICE_DONE_EXECUTING_STOP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to stop service "</span> + s</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            Slog.i(TAG, <span class="string">"handleStopService: exception for "</span> + token, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"handleStopService: token="</span> + token + <span class="string">" not found."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Slog.i(TAG, "Running services: " + mServices);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是从mServices中移除了要停止的Service，然后调用Service的onDestory销毁，最后通过AMS来发出通知（<code>ActivityManager.getService().serviceDoneExecuting(token, SERVICE_DONE_EXECUTING_STOP, 0, 0);</code>）后面的就跟取消绑定一样了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android ListView源码</title>
      <link href="/2020/02/07/Android%20ListView%E6%BA%90%E7%A0%81/"/>
      <url>/2020/02/07/Android%20ListView%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="ListView源码"><a href="#ListView源码" class="headerlink" title="ListView源码"></a>ListView源码</h1><h2 id="RecycleBin缓存"><a href="#RecycleBin缓存" class="headerlink" title="RecycleBin缓存"></a>RecycleBin缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecycleBin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RecyclerListener mRecyclerListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The position of the first view stored in mActiveViews.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFirstActivePosition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Views that were on screen at the start of layout. This array is populated at the start of</span></span><br><span class="line"><span class="comment">     * layout, and at the end of layout all view in mActiveViews are moved to mScrapViews.</span></span><br><span class="line"><span class="comment">     * Views in mActiveViews represent a contiguous range of Views, with position of the first</span></span><br><span class="line"><span class="comment">     * view store in mFirstActivePosition.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> View[] mActiveViews = <span class="keyword">new</span> View[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unsorted views that can be used by the adapter as a convert view.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;View&gt;[] mScrapViews;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mViewTypeCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;View&gt; mCurrentScrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;View&gt; mSkippedScrap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SparseArray&lt;View&gt; mTransientStateViews;</span><br><span class="line">    <span class="keyword">private</span> LongSparseArray&lt;View&gt; mTransientStateViewsById;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewTypeCount</span><span class="params">(<span class="keyword">int</span> viewTypeCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (viewTypeCount &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can't have a viewTypeCount &lt; 1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        ArrayList&lt;View&gt;[] scrapViews = <span class="keyword">new</span> ArrayList[viewTypeCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; viewTypeCount; i++) &#123;</span><br><span class="line">            scrapViews[i] = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mViewTypeCount = viewTypeCount;</span><br><span class="line">        mCurrentScrap = scrapViews[<span class="number">0</span>];</span><br><span class="line">        mScrapViews = scrapViews;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>setViewtypeCount()<br>  我们都知道Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，而setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。在这个方法中，会根据你设置有多少种类型的数据，建立多少个ArrayList的废弃池；mScrapViews就是一个ArrayList&lt;View&gt;类型的数组，它的大小就是viewTypeCount，根据多少种类型，分别存放View；mCurrentScrap就是默认的第一种数据类型，也就是我们常用的</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Fragment相关总结</title>
      <link href="/2020/02/07/Android%20Fragment%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Android%20Fragment%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Fragment相关总结"><a href="#Fragment相关总结" class="headerlink" title="Fragment相关总结"></a>Fragment相关总结</h1><h2 id="Fragment用法"><a href="#Fragment用法" class="headerlink" title="Fragment用法"></a>Fragment用法</h2><p>Fragment从 Android 3.0后引入，用来替代Activity实现模块化，可以适配不同屏幕大小的手机或者平板或电视。但是Fragment不能独立存在，必须嵌入到Activity，Fragment具有自己的生命周期，接收它自己的事件，可以在Activity运行时被添加或删除。</p><h3 id="静态使用Fragment"><a href="#静态使用Fragment" class="headerlink" title="静态使用Fragment"></a>静态使用Fragment</h3><p>这是最简单的使用方式，将Fragment当成一个控件，直接在Activity的布局文件绑定</p><p>首先需要一个类来继承Fragment，重写onCreateView方法来指定Fragment的布局</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.fragment1, container, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里面可以像Activity处理UI、逻辑一样处理Fragment的UI、逻辑，接下来通过fragment来绑定Activity，在Activity的布局里添加并指定一个Fragment</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/fragment1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.example.a14512.activitydemo.Fragment1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当系统创建此 Activity 布局时，会实例化在布局中指定的每个Fragment，并为每个Fragment调用 onCreateView() 方法，以检索每个Fragment的布局。系统会直接插入Fragment返回的 View 来替代 &lt;fragment&gt; 元素</p><h3 id="动态加载Fragment"><a href="#动态加载Fragment" class="headerlink" title="动态加载Fragment"></a>动态加载Fragment</h3><p>除了可以在Activity的布局指定外，还可以通过代码来实现动态添加、更新、删除等操作</p><p>首先Fragment的创建都不变，只是在Activity的布局有一点点改变</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/frameLayout"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里只是将FrameLayout代替了fragment标签，接着我们在Activity来实例化并动态操作Fragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        LogUtil.d(<span class="string">"onCreate"</span>);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//获取FragmentManager</span></span><br><span class="line">        FragmentManager fragmentManager = getSupportFragmentManager();</span><br><span class="line">        <span class="comment">//获取FragmentTransaction来更改，保证一些列Fragment操作的原子性</span></span><br><span class="line">        FragmentTransaction transaction = fragmentManager.beginTransaction();</span><br><span class="line">        Fragment1 fragment1 = <span class="keyword">new</span> Fragment1();</span><br><span class="line">        <span class="comment">//第一个参数是ViewGroup用来放置Fragment的位置，第二个参数是要放置的fragment</span></span><br><span class="line">        transaction.add(R.id.frameLayout, fragment1);</span><br><span class="line">        <span class="comment">//提交，让更改生效</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是刚开始加载Fragment的动态加载，如果我们需要替换另一个Fragment到这个布局容器中，同样也是获取FragmentManager、FragmentTransaction进行替换、删除等操作，最后通过FragmentTransaction来提交更改使之生效</p><p>FragmentTransaction常用的操作有如下：<br>| 方法名 | 含义 |<br>| :-: | :-: |<br>| add() | 向一个Activity中添加一个Fragment |<br>| remove() | 从Activity中移除一个Fragment |<br>| replace() | 使用另一个Fragment替换当前的Fragment |<br>| hide() | 隐藏当前的Fragment，不会调用生命周期的回调方法 |<br>| show() | 显示之前隐藏的Fragment，不会调用生命周期的回调方法 |<br>| detach() | 会将View从UI中移除，detach之后可以调用attach恢复 |<br>| attach() | 重建view试图，附加到UI上展示 |</p><ul><li>Fragment回退栈<br>  可以利用Fragment的回退栈（类似于Activity栈）来保存Fragment的状态，在back后回到之前的Fragment<br>  <code>transaction.addToBackStack(String name);</code>在commit之前，将这次的transaction添加到回退栈，这样就可以保存这次transaction</li></ul><h2 id="与ViewPager合用"><a href="#与ViewPager合用" class="headerlink" title="与ViewPager合用"></a>与ViewPager合用</h2><p>Fragment的使用就像上面那样简单，但是这并不能满足我们的需求。当我们想让Fragment滑动起来，这就需要和ViewPager一起使用了</p><p>在Activity的布局中添加ViewPager</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/viewPager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就相当于一个View容器，接着在Activity实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Fragment的适配器，注意FragmentPagerAdapter 和 FragmentStatePagerAdapter 的区别</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Fragment&gt; mFragments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FragmentAdapter</span><span class="params">(FragmentManager fm, ArrayList&lt;Fragment&gt; fragments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">        <span class="keyword">this</span>.mFragments = fragments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFragments.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFragments.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        LogUtil.d(<span class="string">"onCreate"</span>);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ViewPager viewPager = findViewById(R.id.viewPager);</span><br><span class="line">        ArrayList&lt;Fragment&gt; fragments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Fragment1 fragment1 = <span class="keyword">new</span> Fragment1();</span><br><span class="line">        Fragment2 fragment2 = <span class="keyword">new</span> Fragment2();</span><br><span class="line">        Fragment3 fragment3 = <span class="keyword">new</span> Fragment3();</span><br><span class="line">        fragments.add(fragment1);</span><br><span class="line">        fragments.add(fragment2);</span><br><span class="line">        fragments.add(fragment3);</span><br><span class="line">        FragmentAdapter adapter = <span class="keyword">new</span> FragmentAdapter(getSupportFragmentManager(), fragments);</span><br><span class="line">        viewPager.setAdapter(adapter);</span><br><span class="line">        viewPager.setCurrentItem(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//预加载</span></span><br><span class="line">        viewPager.setOffscreenPageLimit(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样简单就实现了Fragment和ViewPager的联合使用</p><h2 id="Fragment与其他组件的通信"><a href="#Fragment与其他组件的通信" class="headerlink" title="Fragment与其他组件的通信"></a>Fragment与其他组件的通信</h2><h3 id="Fragment和Fragment"><a href="#Fragment和Fragment" class="headerlink" title="Fragment和Fragment"></a>Fragment和Fragment</h3><ul><li>Fragment是同一层级的，Fragment都处于Activity中，没有嵌套<ol><li>直接在一个Fragment中调用另一个Fragment的方法（这种方法对于Fragment有着一定的要求）<br> 这种就是通过获取到另一个Fragment的实例，就可以直接操作另一个Fragment的方法或属性。一般是通过getActivity().getFragmentManager()来获取FragmentManager，这样就可以通过findFragmentById或者findFragmentByTag方法来获取Fragment的实例，这就跟Activity于Fragment的通信一样，因为在Fragment中可以获取到所依赖的Activity</li><li>接口回调，原理跟Activity和Activity的通信差不多</li><li>广播</li></ol></li><li>Fragment不是同一层级的，Fragment嵌套Fragment<br>  在宿主Fragment中可以通过getChildFragmentManager来获取FragmentManager类管理子Fragment<br>  对于子Fragment来说，可以通过getParentFragment() 来获取宿主的FragmentManager</li></ul><h3 id="Fragment和Activity"><a href="#Fragment和Activity" class="headerlink" title="Fragment和Activity"></a>Fragment和Activity</h3><ul><li>如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法</li><li>如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作。</li><li>在Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作，直接调用Activity中的public方法</li><li>Hanlder</li><li>EventBus</li><li>广播</li><li>getArguments获取Activity传递的参数</li></ul><h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p><a href="http://i.imgur.com/fjGYjRN.png" target="_blank" rel="noopener"><img src="http://i.imgur.com/fjGYjRN.png" alt="经典图"></a>经典图</p><ul><li>onAttach()<br>  关联Activity时调用</li><li>onCreate()<br>  创建Fragment时调用，在这里必须初始化Fragment的基础组件</li><li>onCreateView()<br>  Fragment要绘制自己的界面时调用，这个方法必须返回Fragment的layout，也可以返回null(表示没有界面)</li><li>onActivityCreated()<br>  当Activity对象完成自己的onCreate方法时调用</li><li>onStart()<br>  Fragment的UI可见时调用</li><li>onResume()<br>  Fragment的UI可交互时调用</li><li>onPause()<br>  Fragment 可见但不可交互时调用</li><li>onStop()<br>  Fragment 完全不可见时调用</li><li>onDestroyView()<br>  Fragment 移除视图时调用</li><li>onDestroy()<br>  清理View资源时调用</li><li>onDetach()<br>  失去Activity关联时调用</li></ul><h3 id="Fragment和Activity生命周期关系"><a href="#Fragment和Activity生命周期关系" class="headerlink" title="Fragment和Activity生命周期关系"></a>Fragment和Activity生命周期关系</h3><p><a href="http://i.imgur.com/xglLE0e.png" target="_blank" rel="noopener"><img src="http://i.imgur.com/xglLE0e.png" alt="Fragment和Activity"></a>Fragment和Activity</p><p>首先加载Fragment，看看生命周期<br><a href="https://upload-images.jianshu.io/upload_images/4061843-06ee9f0101301e4a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-06ee9f0101301e4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>Fragment在宿主onCreate后相应的生命周期就开始执行了，跟一个View有点类似，在宿主onResume后才调用onResume</p><p>如果是通过按钮来添加就有所区别，因为这时Activity已经完成了onResume的调用<br><a href="https://upload-images.jianshu.io/upload_images/4061843-3637646cf201c4b3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-3637646cf201c4b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>先是宿主Activity的onCreate、onStart、onResume调用，接着加载Fragment，onAttach、onCreate、onCreateView、onActivityCreated、onStart、onResume依次调用</p><p>跳转到一个新的活动<br><a href="https://upload-images.jianshu.io/upload_images/4061843-9506ff5f453c1de3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-9506ff5f453c1de3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>当在Fragment中启动一个新的活动的时候，先是Fragment的onPause调用，接着是宿主Activity的onPause调用，然后就是新活动的生命周期，当Fragment和宿主Activity完全不可见后，就先调用Fragment的onStop，接着是宿主Activity的onStop</p><p>如果新启动的Activity是透明主题或者是一些其他的view不能遮挡Fragment，那么就不会执行onStop<br><a href="https://upload-images.jianshu.io/upload_images/4061843-caad0df0c1a6ac4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-caad0df0c1a6ac4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>这个跟Activity被遮挡类似，不会有onStop调用</p><p>接着按下back键结束活动<br><a href="https://upload-images.jianshu.io/upload_images/4061843-a570c13e13d1dbbb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-a570c13e13d1dbbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>当结束一个活动后，发现是宿主Activity先onRestart，然后再是Fragment的onStart，接着宿主Activity的onStart、onResume调用，最后才是Fragment的onResume调用（这里就可以看出Fragment是依赖于宿主Activity的，只有当Activity完全可见的时候，Fragment的onResume才会调用）</p><p>再back键结束宿主活动<br><a href="https://upload-images.jianshu.io/upload_images/4061843-a6894843ce0e1288.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-a6894843ce0e1288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>结束宿主活动时，先是Fragment的onPause调用，接着是宿主Activity的onPause，Fragment的onStop，宿主的onStop，然后Fragment的onDestroyView、onDestroy、onDetach，最后是宿主活动的onDestroy</p><p>试试replace后的生命周期<br><a href="https://upload-images.jianshu.io/upload_images/4061843-6f5deb44aab68d49.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-6f5deb44aab68d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>replace对Fragment的生命周期有影响，就是Fragment结束的生命周期</p><p>hide之前<br><a href="https://upload-images.jianshu.io/upload_images/4061843-7a32739f3657bcb3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-7a32739f3657bcb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>hide后的生命周期<br><a href="https://upload-images.jianshu.io/upload_images/4061843-7a32739f3657bcb3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-7a32739f3657bcb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>show后的生命周期<br><a href="https://upload-images.jianshu.io/upload_images/4061843-7a32739f3657bcb3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-7a32739f3657bcb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>发现，不管是hide还是show，都不会影响Fragment的生命周期</p><p>remove后的生命周期<br><a href="https://upload-images.jianshu.io/upload_images/4061843-cd0a8865d10f442e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-cd0a8865d10f442e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>当remove的时候，就相当于将Fragment从宿主Activity移除，所以就会结束Fragment</p><h3 id="异常情况的Fragment生命周期"><a href="#异常情况的Fragment生命周期" class="headerlink" title="异常情况的Fragment生命周期"></a>异常情况的Fragment生命周期</h3><p>例如当横竖屏切换时<br><a href="https://upload-images.jianshu.io/upload_images/4061843-b6709b8d62760553.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-b6709b8d62760553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>Fragment依次调用onPause、onSaveInstanceState、onStop、onDestoryView、onDestroy、onDetach，销毁时候的生命周期调用Fragment总是先于宿主Activity；接着重新构建的时候，却是Fragment先调用onAttach、onCreate，然后才是宿主Activity的onCreate，再然后又是Fragment的onCreateView、onActivityCreated、onViewStateRestored、onStart，接着宿主Activity的onStart、onRestoreInstanceState、onResume，最后时Fragment的onResume。可以看出，销毁时先保存Fragment、先销毁Fragment，重建时，先onCreateFragment，然后在宿主Activity onCreate之后就先恢复Fragment，当宿主resume后，Fragment才resume直接展示了。</p><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li><p>fragment 各种情况下的生命周期<br> 切换到Fragment(第一次)</p><blockquote><p>onAttach<br>onCreate<br>onCreateView<br>onActivityCreated<br>onStart<br>onResume</p></blockquote><p> 屏幕熄灭</p><blockquote><p>onPause<br>onSaveInstanceState<br>onStop</p></blockquote><p> 屏幕解锁</p><blockquote><p>onStart<br>onResume</p></blockquote><p> 切换到其他Fragment</p><blockquote><p>onPause<br>onStop<br>onDestroyView</p></blockquote><p> 切换回本身</p><blockquote><p>onCreateView<br>onActivityCreated<br>onStart<br>onResume</p></blockquote><p> 回到桌面</p><blockquote><p>onPause<br>onSaveInstanceState<br>onStop</p></blockquote><p> 回到应用</p><blockquote><p>onStart<br>onResume</p></blockquote><p> 退出应用</p><blockquote><p>onPause<br>onStop<br>onDestroyView<br>onDestroy<br>onDetach</p></blockquote></li><li><p>遇到过哪些关于Fragment的问题，如何处理的？<br> Fragment嵌套Fragment时通信的问题，还有就是一些控制操作的问题</p><p> 在宿主Fragment中可以通过getChildFragmentManager来获取FragmentManager类管理子Fragment<br> 对于子Fragment来说，可以通过getParentFragment() 来获取宿主的FragmentManager</p></li><li><p>如何实现Fragment的滑动<br> ViewPager的联合使用，通过ViewPager来操作</p></li><li><p>ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化<br> viewPager有一个setOffscreenPageLimit(int);默认值是1，这个就是每次左右Fragment的初始化个数</p></li><li><p>fragment之间传递数据的方式？<br> 重复问题</p></li><li><p>Fragment的生命周期，栈管理，和commit()类似的方法还有哪个<br> <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0214/2481.html" target="_blank" rel="noopener">Fragment笔记整理</a></p></li><li><p>Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用，如果在Adapter中使用应该如何解耦</p></li><li><p>Fragment的懒加载：<br> 在Fragment中有一个setUserVisibleHint这个方法，而且这个方法是优于onCreate()方法的，所以也可以作为Fragment的一个生命周期来看待，它会通过isVisibleToUser告诉我们当前Fragment我们是否可见，getUserVisibleHint()，它就是用来判断当前Fragment是否可见</p></li><li><p>Fragment如何去调用Activity的方法<br> getActivity、getContext</p></li><li><p>如何切换 fragement,不重新实例化<br>适用Fragment适配器，和ViewPager联合适用，基本上都是提前实例化好，切换时使用</p></li><li><p>Fragment与Fragment、Activity通信的方式<br>Fragment与Fragment：<br>（1）在宿主Fragment中可以通过getChildFragmentManager来获取FragmentManager类管理子Fragment<br>（2）对于子Fragment来说，可以通过getParentFragment() 来获取宿主的FragmentManager<br>（3）如果能直接获取对应的实例可以直接通信<br>（4）接口，同样适用和Activity<br>（5）广播，同样适用和Activity<br>（6）EventBus</p><p>Fragment与Activity：<br>和前面Fragment之间有些重复<br>不同的就是在Fragment中可以通过getActivity来获取Activity的实例</p></li><li><p>Activity与Fragment之间生命周期比较<br>如前面的图</p></li></ol><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p><a href="https://blog.csdn.net/handsome_926/article/details/50736024" target="_blank" rel="noopener">Fragment 用法总结（一）</a><br><a href="https://blog.csdn.net/handsome_926/article/details/50771239" target="_blank" rel="noopener">Fragment 用法总结（二）</a><br><a href="https://blog.csdn.net/lmj623565791/article/details/37992017" target="_blank" rel="noopener">Android Fragment 真正的完全解析（下）</a><br><a href="https://www.cnblogs.com/mengdd/p/5552721.html" target="_blank" rel="noopener">Android Fragment使用(二) 嵌套Fragments (Nested Fragments) 的使用及常见错误</a><br><a href="http://seniorzhai.github.io/2015/01/05/Fragment生命周期详解/" target="_blank" rel="noopener">Fragment生命周期详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Broadcast相关总结</title>
      <link href="/2020/02/07/Android%20Broadcast%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Android%20Broadcast%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Broadcast相关总结"><a href="#Broadcast相关总结" class="headerlink" title="Broadcast相关总结"></a>Broadcast相关总结</h1><h2 id="Broadcast用法"><a href="#Broadcast用法" class="headerlink" title="Broadcast用法"></a>Broadcast用法</h2><h2 id="Broadcast其他注意事项"><a href="#Broadcast其他注意事项" class="headerlink" title="Broadcast其他注意事项"></a>Broadcast其他注意事项</h2><h2 id="Broadcast源码分析"><a href="#Broadcast源码分析" class="headerlink" title="Broadcast源码分析"></a>Broadcast源码分析</h2><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li><p>广播传输的数据是否有限制，是多少，为什么要限制？<br> （1）广播是通过Intent携带需要传递的数据的<br> （2）Intent是通过Binder机制实现的<br> （3）Binder对数据大小有限制，不同room不一样，一般为1M</p></li><li><p>广播的分类？<br> 标准广播：通过context. sendBroadcast或者context. sendBroadcastAsUser发送给当前系统中所有注册的接受者，也就是只要注册了就会接收到。应用在需要通知各个广播接收者的情况下使用，如开机启动</p><p> 有序广播：接收者按照优先级处理广播，并且前面处理广播的接受者可以中止广播的传递，一般通过context. sendOrderedBroadcast或者context.sendOrderedBroadcastAsUser，在需要有特定拦截的场景下使用，如黑名单短信、电话拦截</p><p> 粘性广播：可以发送给以后注册的接受者，意思是系统会将前面的粘性广播保存在AMS中，一旦注册了与以保存的粘性广播符合的广播，在注册结束后会立即收到广播，一般通过context. sendStickyBroadcast或context.sendStickyOrderedBroadcast来发送，从字面上看，可以看出来粘性广播也分为普通粘性广播和有序粘性广播</p><p> 本地广播：发出的广播只能在应用程序内部进行传递，广播接收器也只能接受来自本应用程序的广播</p><p> 全局广播：系统和广播，发出的广播可以被其他任何应用程序接收到，并且也可以接受到其他任何应用程序的广播</p></li><li><p>广播的使用场景，使用方式<br> 广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。<br> 在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。</p><p> 使用：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AndroidManifest中静态注册</span></span><br><span class="line">&lt;receiver</span><br><span class="line">    android:name=<span class="string">".MyBroadcastReceiver"</span></span><br><span class="line">    android:enabled=<span class="string">"true"</span></span><br><span class="line">    android:exported=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;intent-filter android:priority=<span class="string">"100"</span>&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"com.example.hp.broadcasttest.MY_BROADCAST"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态注册，在代码中注册</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    mIntentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">//添加广播想要监听的类型，监听网络状态是否发生变化</span></span><br><span class="line">    mIntentFilter.addAction(<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>);</span><br><span class="line">    mNetworkChangeReceiver = <span class="keyword">new</span> NetworkChangeReceiver();</span><br><span class="line">    <span class="comment">//注册广播</span></span><br><span class="line">    registerReceiver(mNetworkChangeReceiver, mIntentFilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    <span class="comment">//取消注册广播接收器</span></span><br><span class="line">    unregisterReceiver(mNetworkChangeReceiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送广播，同样通过Intent</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.hp.broadcasttest.MY_BROADCAST"</span>);</span><br><span class="line"><span class="comment">//发送标准广播</span></span><br><span class="line">sendBroadcast(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收广播</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBroadcastReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This method is called when the BroadcastReceiver is receiving</span></span><br><span class="line">        <span class="comment">// an Intent broadcast.</span></span><br><span class="line">        Toast.makeText(context, <span class="string">"received"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="comment">//将这条广播截断</span></span><br><span class="line"><span class="comment">//        abortBroadcast();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BroadcastReceiver，LocalBroadcastReceiver 区别<br> 广播接收者：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）用于应用间的传递消息</span><br><span class="line">（<span class="number">2</span>）由于跨应用，存在安全问题</span><br></pre></td></tr></table></figure><p> 本地广播接收者：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）广播数据在本应用范围内传播。  </span><br><span class="line">（<span class="number">2</span>）不用担心别的应用伪造广播。  </span><br><span class="line">（<span class="number">3</span>）比发送全局广播更高效、安全。  </span><br><span class="line">（<span class="number">4</span>）无法使用静态注册</span><br></pre></td></tr></table></figure></li><li><p>在manifest和代码中如何注册和使用BroadcastReceiver<br> 在AndroidManifest中静态注册，然后直接使用</p><p> 代码中，通过registerReceiver来注册</p><p> 注册发送后，在BroadcastReceiver（自定义一个接收器继承自BroadcastReceiver）的onReceive中接收广播并处理广播</p></li><li><p>广播引起anr的时间限制<br> 前台广播：BROADCAST_FG_TIMEOUT = 10s<br> 后台广播：BROADCAST_BG_TIMEOUT = 60s</p></li><li><p>广播是否可以请求网络<br> 不建议，网络请求一般都是耗时操作，而广播实在主线程运行的，耗时操作会导致线程阻塞，很容易导致ANR。可以在广播中使用子线程进行网络请求，但不建议，更建议在Service中进行。广播可以用于监听网络变化</p></li><li><p>如何通过广播拦截和abort一条短信<br> 要拦截首先设置权限：android.permission.SEND_SMS，android.permission.RECEIVE_SMS，设置receiver的优先级为最高1000，acticion为android.provider.Telephony.SMS_RECEIVED。</p><p> 在4.4前，短信拦截都是通过动态注册高优先级BroadcastReceiver的方式进行拦截的，主要是用于跟竞品进行短信抢占。而现在ContenetObserver是并行通知的情况下，如果过滤逻辑不够快，依然有可能会被竞品抢先把短信先删除掉，导致拿到的最后一次短信是旧的短信。建议结合BroadcastReceiver和ContenetObserver进行拦截，BroadcastReceiver做内容校正和后备数据，以防拿到的最后一条短信是旧的时候，依然可以进行正常的拦截流程；</p><p> 4.4以上引入了default sms机制，我们可以在不成为default sms的前提下实现短信拦截，利用App Ops权限管理功能，</p><p> 但由于App Ops从4.3出现到4.4一直牌隐藏的状态，猜想google还在不断调整中；</p><p> Write SMS/MMS的权限开关的存在跟default sms本身是一个矛盾，之所以出现Write SMS/MMS的权限开关，完全是因为App Ops出现在前，而defaultsms出现在后所致。</p><p> 6.0以上引入了新的动态权限管理，类似于iOS中的权限。6.0以前是在安装时一次性获取权限，6.0之后是在运行的时候选择。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//onReceive代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当接收到短信时被触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是接收到短信</span></span><br><span class="line">        <span class="keyword">if</span> (intent.getAction().equals(<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 取消广播（这行代码将会让系统收不到短信）</span></span><br><span class="line">            abortBroadcast();</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 接收由SMS传过来的数据</span></span><br><span class="line">            Bundle bundle = intent.getExtras();</span><br><span class="line">            <span class="comment">// 判断是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (bundle != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 通过pdus可以获得接收到的所有短信消息</span></span><br><span class="line">                Object[] pdus = (Object[]) bundle.get(<span class="string">"pdus"</span>);</span><br><span class="line">                <span class="comment">// 构建短信对象array,并依据收到的对象长度来创建array的大小</span></span><br><span class="line">                SmsMessage[] messages = <span class="keyword">new</span> SmsMessage[pdus.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pdus.length; i++) &#123;</span><br><span class="line">                    messages[i] = SmsMessage.createFromPdu((<span class="keyword">byte</span>[]) pdus[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将送来的短信合并自定义信息于StringBuilder当中</span></span><br><span class="line">                <span class="keyword">for</span> (SmsMessage message : messages) &#123;</span><br><span class="line">                    sb.append(<span class="string">"短信来源:"</span>);</span><br><span class="line">                    <span class="comment">// 获得接收短信的电话号码</span></span><br><span class="line">                    sb.append(message.getDisplayOriginatingAddress());</span><br><span class="line">                    sb.append(<span class="string">"\n------短信内容------\n"</span>);</span><br><span class="line">                    <span class="comment">// 获得短信的内容</span></span><br><span class="line">                    sb.append(message.getDisplayMessageBody());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Toast.makeText(context, sb.toString(), <span class="number">5000</span>).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AndroidManifest中</span></span><br><span class="line">&lt;application</span><br><span class="line">    android:icon=<span class="string">"@drawable/icon"</span></span><br><span class="line">    android:label=<span class="string">"@string/app_name"</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt;receiver android:name=<span class="string">".SmsReceiver"</span> &gt;</span><br><span class="line"></span><br><span class="line">        &lt;intent-filter android:priority=<span class="string">"800"</span> &gt;</span><br><span class="line"></span><br><span class="line">            &lt;action android:name=<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span> /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/receiver&gt;</span><br><span class="line">&lt;/application&gt;</span><br><span class="line">&lt;!-- 授予程序接收短信的权限 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.RECEIVE_SMS"</span> /&gt;</span><br></pre></td></tr></table></figure><p> 通过ContentObserver监听短信数据库</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ContentObserver smsContentObserver =  <span class="keyword">new</span> ContentObserver(<span class="keyword">new</span> Handler()) &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.onChange(<span class="keyword">true</span>);  </span><br><span class="line">        <span class="comment">/*Cursor cursor = resolver.query( </span></span><br><span class="line"><span class="comment">                Uri.parse(SMS_INBOX_URI), </span></span><br><span class="line"><span class="comment">                new String[] &#123; "_id", "address", "thread_id", "date", </span></span><br><span class="line"><span class="comment">                        "protocol", "type", "body", "read" &#125;, </span></span><br><span class="line"><span class="comment">                " address=? and read=?", new String[] &#123;SENDER_ADDRESS, "0"&#125;, </span></span><br><span class="line"><span class="comment">                "date desc");*/</span>  </span><br><span class="line">        <span class="comment">//注释掉的是查未读状态的，但如果你的手机安装了第三放的短信软件时，他们有可能把状态改变了，你就查询不到数据</span></span><br><span class="line">        Cursor cursor = resolver.query(  </span><br><span class="line">                Uri.parse(SMS_INBOX_URI),  </span><br><span class="line">                <span class="keyword">new</span> String[] &#123; <span class="string">"_id"</span>, <span class="string">"address"</span>, <span class="string">"thread_id"</span>, <span class="string">"date"</span>,  </span><br><span class="line">                        <span class="string">"protocol"</span>, <span class="string">"type"</span>, <span class="string">"body"</span>, <span class="string">"read"</span> &#125;,  </span><br><span class="line">                <span class="string">" address=?"</span>, <span class="keyword">new</span> String[] &#123;SENDER_ADDRESS&#125;,  </span><br><span class="line">                <span class="string">"date desc"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cursor.moveToNext())&#123;  </span><br><span class="line">            String address = cursor.getString(cursor.getColumnIndex(<span class="string">"address"</span>));  </span><br><span class="line">            String body = cursor.getString(cursor.getColumnIndex(<span class="string">"body"</span>));  </span><br><span class="line">            String id = cursor.getString(cursor.getColumnIndex(<span class="string">"_id"</span>));  </span><br><span class="line">            resolver.delete(Uri.parse(<span class="string">"content://sms/"</span>+id), <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">            Log.d(<span class="string">"短信平台发来的短信---"</span>, address+<span class="string">":::::"</span>+body);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android ContentProvider相关总结</title>
      <link href="/2020/02/07/Android%20ContentProvider%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Android%20ContentProvider%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="ContentProvider相关总结"><a href="#ContentProvider相关总结" class="headerlink" title="ContentProvider相关总结"></a>ContentProvider相关总结</h1><h2 id="ContentProvider用法"><a href="#ContentProvider用法" class="headerlink" title="ContentProvider用法"></a>ContentProvider用法</h2><h2 id="ContentProvider与其他数据库相关"><a href="#ContentProvider与其他数据库相关" class="headerlink" title="ContentProvider与其他数据库相关"></a>ContentProvider与其他数据库相关</h2><h2 id="ContentProvider源码分析"><a href="#ContentProvider源码分析" class="headerlink" title="ContentProvider源码分析"></a>ContentProvider源码分析</h2><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li><p>Android系统为什么会设计ContentProvider，进程共享和线程安全问题<br> （1）封装</p><p> ​        对数据进行封装，提供统一的接口，使用者完全不必关心这些数据是在DB，XML、Preferences或者网络请求来的。当项目需求要改变数据来源时，使用我们的地方完全不需要修改。  </p><p> （2）提供一种跨进程数据共享的方式</p><p> ​        由系统来管理ContentProvider的创建、生命周期及访问的线程分配，简化我们在应用间共享数据（进程间通信）的方式。我们只管通过ContentResolver访问ContentProvider所提示的数据接口，而不需要担心它所在进程是启动还是未启动  </p><p> （3）更好的数据访问权限管理</p><p> ​        ContentProvider可以对开发的数据进行权限设置，不同的URI可以对应不同的权限，只有符合权限要求的组件才能访问到ContentProvider的具体操作。</p></li></ol><pre><code>ContentProvider是一个APP间共享数据的接口。一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，例如在A APP中实现建ContentProvider，并在Manifest中生命它的Uri和权限，在B APP中注册权限，并通过ContentResolver和Uri进行增删改查；ContentProvider也是通过Binder机制实现跨进程的通信，通过匿名共享内存的方式进行数据的传输，一个应用进程有16个Binder线程去和远程线程进行交互，每个线程可占用的缓存空间为128KB，超出会报异常ContentProvider的线程安全是跨进程的，不管Provider使用方是同一个进程的不同线程，还是不同的进程，Provider方实际上是同一个Provider对象实例，并发访问时，Provider方query()方法运行在不同的线程，实际上是运行在Provider方的进程的Binder线程池中。在AMS中，获取Provider相关的方法都有同步锁，所以这个Provider远程对象实际上是同一个</code></pre><ol start="2"><li><p>ContentProvider、ContentResolver与ContentObserver之间的关系是什么？<br> ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider提供了统一的接口，可以用来做进程间数据共享</p><p> ContentResolver：可以不同的URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互，用于获取内容提供器提供的数据</p><p> ContentObserver：监听、观察ContentProvider中的数据变化，并将变化通知给外界</p></li><li><p>批量插入50条联系人，比较高效的方法，ContentProvider是否了解原理<br> SQL语句采用“insert into tb (…) values(…),(…)…;”方式，，也就是不要重复去使用一个SQL语句，重复执行相同的操作，直接一次性添加多条数据进去</p><p> <a href="http://gityuan.com/2016/07/30/content-provider/" target="_blank" rel="noopener">理解ContentProvider原理</a></p></li><li><p>请介绍下ContentProvider 是如何实现数据共享的<br> ContentProvider 是应用程序之间共享数据的接口. 使用的时候首先自定义一个类继承 ContentProvider, 然后覆写 query、insert、update、delete 等方法. 因为其是四大组件之一因此必须在 AndroidManifest 文件中进行注册. 把自己的数据通过 uri 的形式共享出去</p><p> 第三方可以通过 ContentResolver 来访问该 Provider</p></li><li><p>ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)<br> （1）Provider可以提供读权限android:readPermission，写权限android:writePermission，或者权限android:permission（读写都设置）</p><p> 我们可以针对其中某个或某部分URI，单独进行权限设置。除了android:pathPrefix，还可以有android:path和android:pathPatten，例如 android:pathPattern=”/hello/.<em>“（注意，通配符</em>之前有个‘.’）<br> 例如，我们可以只开发 content://com.robert.propermission.PrivProvider/hello路径下权限，不允许 访问其他路径，如下声明：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">".PrivProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"com.robert.propermission.PrivProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:readPermission</span>=<span class="string">"com.robert.READ_CONTENTPROVIDER"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path-permission</span> <span class="attr">android:pathPrefix</span>=<span class="string">"/hello"</span> <span class="attr">android:readPermission</span>=<span class="string">"READ_HELLO_CONTENTPROVIDER"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p> Provider的granting<br> 全局granting<br> ProPermissionClient具有读取 content provider的权限，它去调用另一个应用C的activity，例子中这个另一个应用C为ProPermissionGrant，但是这个例子没有读 取content provider的权限，ProPermissionClient可以将自己的权限通过intent传递给应用C，让其也具有访问content provider的权限。<br> 对于应用A，相关的content provider为：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">".PrivProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"com.robert.propermission.PrivProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:readPermission</span>=<span class="string">"com.robert.READ_CONTENTPROVIDER"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p> 对于应用B，其具有com.robert.permission.READ_CONTENTPROVIDER的权限，而应用C不具备，应用B通过intent调用应用C的代码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,ReadProvider.class);</span><br><span class="line">intent.setClassName(<span class="string">"com.robert.example.propermissiongrant"</span>, <span class="string">"com.robert.example.propermissiongrant.MainActivity"</span>);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"content://com.robert.propermission.PrivProvider/world/1"</span>));</span><br><span class="line">intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);  <span class="comment">//传递权限</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p> 所调用的C的activity具备访问content provider的权限。<br> 如果我们将provider的属性android:grantUriPermissions设置为false，则不允许通过接受传递的权限方式进行访问，即B所调用的C的activity不能读content provider，就会报错<br> 部分URI的granting</p><p> 我们只希望部分的URI允许grant权限访问，而不是开放整个provider，如下：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">".PrivProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"com.robert.propermission.PrivProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:readPermission</span>=<span class="string">"com.robert.permission.READ_CONTENTPROVIDER"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">grant-uri-permission</span> <span class="attr">android:pathPrefix</span>=<span class="string">"/hello"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 我们将之允许前缀为hello的部分URI访问。一旦 我们设置了grant-uri-permission，则全局的android:grantUriPermissions属性将无效，无论设置true还 是flase，也都是只允许grant-uri-permission是声明的部分uri可以被grant权限访问。</p><blockquote><p>android:grantUriPermssions:临时许可标志。<br>android:permission:Provider读写权限。<br>android:readPermission:Provider的读权限。<br>android:writePermission:Provider的写权限。<br>android:enabled:标记允许系统启动Provider。<br>android:exported:标记允许其他应用程序使用这个Provider。<br>android:multiProcess:标记允许系统启动Provider相同的进程中调用客户端。</p><p>&lt;path-permission&gt;：只针对某一个路径开通权限，不允许访问其他路径<br>android:pathPattern：具体的路径<br>android:permission</p></blockquote><p> <a href="https://blog.csdn.net/robertcpp/article/details/51337891" target="_blank" rel="noopener">ContentProvider权限设置</a><br> <a href="https://www.cnblogs.com/622698abc/p/6033080.html" target="_blank" rel="noopener">Content Provider的权限</a></p></li></ol><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Broadcast源码分析</title>
      <link href="/2020/02/07/Android%20Broadcast%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/07/Android%20Broadcast%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Broadcast源码分析"><a href="#Broadcast源码分析" class="headerlink" title="Broadcast源码分析"></a>Broadcast源码分析</h1><p><a href="http://naotu.baidu.com/file/f218c472d4ef7b60b1ad1f5d9dfa5646?token=3e3820b1e30ce0a2" target="_blank" rel="noopener">源码脑图</a></p><h2 id="注册Broadcast"><a href="#注册Broadcast" class="headerlink" title="注册Broadcast"></a>注册Broadcast</h2><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>我们通过<code>registerReceiver(BroadcastReceiver receiver, IntentFilter filter)</code>方法来动态注册一个广播，跟进看源码</p><p>首先跟Activity和Service一样，都是到ContextWrapper中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.registerReceiver(receiver, filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, IntentFilter filter, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.registerReceiver(receiver, filter, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">    String broadcastPermission, Handler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.registerReceiver(receiver, filter, broadcastPermission,</span><br><span class="line">            scheduler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">    String broadcastPermission, Handler scheduler, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.registerReceiver(receiver, filter, broadcastPermission,</span><br><span class="line">            scheduler, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很直观的看见，根据传入的参数不同，registerReceiver有多个重载方法，不过这并没有什么影响，因为在ContextWrapper这个类中并没有具体的操作，所以还是得到ContextImpl中看看</p><p>接着看看ContextImpl中得registerReceiver方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiver(receiver, filter, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiver(receiver, filter, <span class="keyword">null</span>, <span class="keyword">null</span>, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">        String broadcastPermission, Handler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            filter, broadcastPermission, scheduler, getOuterContext(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">        String broadcastPermission, Handler scheduler, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            filter, broadcastPermission, scheduler, getOuterContext(), flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中也是根据参数得不同重载了几个registerReceiver方法，不过这没有什么影响，最后都会调用5个参数的方法，有些则会调用4个参数的方法。但这并没有什么影响，最后的结果都是调用registerReceiverInternal这个方法</p><p>接着看看ContextImpl的registerReceiverInternal方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        IntentFilter filter, String broadcastPermission,</span></span></span><br><span class="line"><span class="function"><span class="params">        Handler scheduler, Context context, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将BroadcastReceiver转换为LoadedApk.ReceiverDispatcher.InnerRecever</span></span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当LoadedApk和Context为空的时候直接创建LoadedApk.ReceiverDispatcher对象</span></span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//最后通过AMS注册</span></span><br><span class="line">        <span class="keyword">final</span> Intent intent = ActivityManager.getService().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName, rd, filter,</span><br><span class="line">                broadcastPermission, userId, flags);</span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intent;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，首先会通过mPackageInfo来将BroadcastReceiver转换为InnerReceiver，mPackageInfo是LoadedApk对象，那我们看看LoadedApk的getReceiverDispatcher方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IIntentReceiver <span class="title">getReceiverDispatcher</span><span class="params">(BroadcastReceiver r,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, Handler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instrumentation, <span class="keyword">boolean</span> registered)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        LoadedApk.ReceiverDispatcher rd = <span class="keyword">null</span>;</span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">            map = mReceivers.get(context);</span><br><span class="line">            <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">                rd = map.get(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//ReceiverDispatcher在这里创建，同时返回一个InnerReceiver对象</span></span><br><span class="line">            rd = <span class="keyword">new</span> ReceiverDispatcher(r, context, handler,</span><br><span class="line">                    instrumentation, registered);</span><br><span class="line">            <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    map = <span class="keyword">new</span> ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                    mReceivers.put(context, map);</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(r, rd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        rd.mForgotten = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> rd.getIIntentReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会创建一个ReceiverDispatcher对象，这个类跟ServiceDispatcher的作用是一样的。接着就通过ReceiverDispatcher将BroadcastReceiver转换为IIntentReceiver。IIntentReceiver是一个Binder，不直接使用BroadcastReceiver是因为可能会跨进程通信，BroadcastReceiver是不能进行跨进程传递，跟SeriviceConnection基本相似.IItentReceiver具体实现是LoadApk.ReceiverDispatcher.InnerReceiver，类似于InnerConnection。最后返回了ReceiverDispatcher持有的InnerReceiver</p><p>那么接着回到之前ContextImpl的registerReceiverInternal方法，接着往下面看。我们可以看到，不管怎样，都会创建一个LoadedApk.ReceiverDispather对象，最后通过ActivityManager.getService().registerReceiver注册，ActivityManager.getService()就是AMS，这个应该很熟悉了吧</p><p>接着看AMS的registerReceiver方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"registerReceiver"</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">        <span class="keyword">if</span> (rl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rl = <span class="keyword">new</span> ReceiverList(<span class="keyword">this</span>, callerApp, callingPid, callingUid,</span><br><span class="line">                    userId, receiver);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//存储</span></span><br><span class="line">            mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.uid != callingUid) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.pid != callingPid) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.userId != userId) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实例化BroadcastFilter，BroadcastFilter继承自IntentFilter</span></span><br><span class="line">        BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                permission, callingUid, userId, instantApp, visibleToInstantApps);</span><br><span class="line">        rl.add(bf);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//将远程的InnerReceiver对象和IntentFilter对象存储起来，这样注册就完了</span></span><br><span class="line">        mReceiverResolver.addFilter(bf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enqueue broadcasts for all existing stickies that match</span></span><br><span class="line">        <span class="comment">// this filter.</span></span><br><span class="line">        <span class="comment">//由于粘性广播注册后就可以接收，所以这里是粘性广播的处理</span></span><br><span class="line">        <span class="keyword">if</span> (allSticky != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的代码还是优点多，在重要的地方写了注释，广播就这样注册完了（刚开始看的时候也懵逼，就这样完了？），确实是这样就完了</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册是在AndroidManifest中注册的，通过PMS进行解析，具体的请看PMS的源码分析</p><h2 id="发送和接收Broadcast"><a href="#发送和接收Broadcast" class="headerlink" title="发送和接收Broadcast"></a>发送和接收Broadcast</h2><p>我们通过<code>sendBroadcast(Intent intent)</code>方法来发送一个广播，在onReceive方法中接收广播，那么来看看具体怎么实现的</p><p>首先还是ContextWrapper的sendBroadcast()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    mBase.sendBroadcast(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来，还是到ContextImpl中看看sendBroadcast()方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        ActivityManager.getService().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">                Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简短，ContextImpl马上就把工作交给了AMS去了</p><p>那么接着看AMS的broadcastIntent方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"broadcastIntent"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="comment">//交给了内部方法</span></span><br><span class="line">        <span class="keyword">int</span> res = broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != <span class="keyword">null</span> ? callerApp.info.packageName : <span class="keyword">null</span>,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中也没有做太多的事，就是获取了一些需要的信息，接着就调用了内部的broadcastIntentLocked方法</p><p>接着看AMS的broadcastIntentLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callerPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle resultExtras, String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    intent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// By default broadcasts do not go to stopped apps.</span></span><br><span class="line">    <span class="comment">//默认情况下，广播不会发给已经停止的应用</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have not finished booting, don't allow this to launch new processes.</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who is receiving this broadcast is running.</span></span><br><span class="line">    <span class="comment">// If not, we will just skip it. Make an exception for shutdown broadcasts</span></span><br><span class="line">    <span class="comment">// and upgrade steps.</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that protected broadcasts are only being sent by system code,</span></span><br><span class="line">    <span class="comment">// and that system code is only sending protected broadcasts.</span></span><br><span class="line">    <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">    <span class="comment">//确保收保护的广播是由系统发出的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isProtectedBroadcast;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Remote exception"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCallerSystem;</span><br><span class="line">    <span class="keyword">switch</span> (UserHandle.getAppId(callingUid)) &#123;</span><br><span class="line">        <span class="keyword">case</span> ROOT_UID:</span><br><span class="line">        <span class="keyword">case</span> SYSTEM_UID:</span><br><span class="line">        <span class="keyword">case</span> PHONE_UID:</span><br><span class="line">        <span class="keyword">case</span> BLUETOOTH_UID:</span><br><span class="line">        <span class="keyword">case</span> NFC_UID:</span><br><span class="line">            isCallerSystem = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            isCallerSystem = (callerApp != <span class="keyword">null</span>) &amp;&amp; callerApp.persistent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First line security check before anything else: stop non-system apps from</span></span><br><span class="line">    <span class="comment">// sending protected broadcasts.</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add to the sticky list if requested.</span></span><br><span class="line">    <span class="comment">//粘性广播的处理</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line">    <span class="comment">//查找出匹配的广播接收者并经过过滤</span></span><br><span class="line">    List receivers = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">             == <span class="number">0</span>) &#123;</span><br><span class="line">        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == SHELL_UID) &#123;</span><br><span class="line">            <span class="comment">// Query one target user at a time, excluding shell-restricted users</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mUserController.hasUserRestriction(</span><br><span class="line">                        UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                        mReceiverResolver.queryIntent(intent,</span><br><span class="line">                                resolvedType, <span class="keyword">false</span> <span class="comment">/*defaultOnly*/</span>, users[i]);</span><br><span class="line">                <span class="keyword">if</span> (registeredReceivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registeredReceivers = registeredReceiversForUser;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registeredReceiversForUser != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                    resolvedType, <span class="keyword">false</span> <span class="comment">/*defaultOnly*/</span>, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge into one list.</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (ir &lt; NR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            receivers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        receivers.add(registeredReceivers.get(ir));</span><br><span class="line">        ir++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将筛选出来的广播接收者添加到BroadcastQueue中，BroadcastQueue会将广播发送给相应的广播接收者</span></span><br><span class="line">    <span class="keyword">if</span> ((receivers != <span class="keyword">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">            || resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取创建好的BroadcastQueue，在AMS中的全局变量，有前台和后台</span></span><br><span class="line">        BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing ordered broadcast "</span> + r</span><br><span class="line">                + <span class="string">": prev had "</span> + queue.mOrderedBroadcasts.size());</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Enqueueing broadcast "</span> + r.intent.getAction());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BroadcastRecord oldRecord =</span><br><span class="line">                replacePending ? queue.replaceOrderedBroadcastLocked(r) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Replaced, fire the result-to receiver.</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//添加到BroadcastQueue中</span></span><br><span class="line">            queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">            <span class="comment">//通过BroadcastQueue进行发送</span></span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中的代码有几百行，说明这个方法的重要性。在这个方法中，先会根据intent-filter查找出匹配的广播接收者并经过一系列的条件过滤，最终添加到BroadcastQueue中，通过BroadcastQueue来发送。这就说明了在这个方法中仅仅是将符合条件的广播接收者筛选出来，放到BroadcastQueue中，最终的发送还是通过BroadcastQueue来实现的</p><p>接着看BroadcastQueue.scheduleBroadcastsLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Schedule broadcasts ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: current="</span></span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过Handler来发送</span></span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</span><br><span class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mHanlder是根据创建BroadcastQueue时传入的AMS的MainHandler来创建的BroadcastHandler，持有的是AMS的MainHandler的looper。BroadcastHandler就在BroadcastQueue中</p><p>接着看看BroadcastQueue.BroadcastHanlder的handleMessage方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BroadcastHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</span><br><span class="line">                <span class="comment">//接着调用</span></span><br><span class="line">                processNextBroadcast(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中处理了两种消息，其中一种是超时的，另外一种就是我们要发送的广播消息了，然后接着又调用了BroadcastQueue的processNextBroadcast方法</p><p>接着看BroadcastQueue的processNextBroadcast方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processNextBroadcast</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"processNextBroadcast ["</span></span><br><span class="line">                + mQueueName + <span class="string">"]: "</span></span><br><span class="line">                + mParallelBroadcasts.size() + <span class="string">" parallel broadcasts, "</span></span><br><span class="line">                + mOrderedBroadcasts.size() + <span class="string">" ordered broadcasts"</span>);</span><br><span class="line"></span><br><span class="line">        mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">            mBroadcastsScheduled = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First, deliver any non-serialized broadcasts right away.</span></span><br><span class="line">        <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r = mParallelBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">            r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = r.receivers.size();</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                Object target = r.receivers.get(i);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Delivering non-ordered on ["</span> + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                        + target + <span class="string">": "</span> + r);</span><br><span class="line">                <span class="comment">//无序广播存储在mParallelBroadcasts中，系统会遍历并将其中的广播发送给它们所有的接收者</span></span><br><span class="line">                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            addBroadcastToHistoryLocked(r);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Done with parallel broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now take care of the next serialized one...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we are waiting for a process to come up to handle the next</span></span><br><span class="line">        <span class="comment">// broadcast, then do nothing at this point.  Just in case, we</span></span><br><span class="line">        <span class="comment">// check that the process we're waiting for still exists.</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Get the next receiver...</span></span><br><span class="line">        <span class="keyword">int</span> recIdx = r.nextReceiver++;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BroadcastOptions brOptions = r.options;</span><br><span class="line">        <span class="keyword">final</span> Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">            <span class="comment">// Simple case: this is a registered receiver who gets</span></span><br><span class="line">            <span class="comment">// a direct call.</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (r.receiver == <span class="keyword">null</span> || !r.ordered) &#123;</span><br><span class="line">                <span class="comment">// The receiver has already finished, so schedule to</span></span><br><span class="line">                <span class="comment">// process the next one.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Quick finishing ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"]: ordered="</span></span><br><span class="line">                        + r.ordered + <span class="string">" receiver="</span> + r.receiver);</span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                <span class="comment">//下一个接收者接着调用该方法</span></span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hard case: need to instantiate the receiver, possibly</span></span><br><span class="line">        <span class="comment">// starting its application process to host it.</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中的代码也有很多，但是我们发送标准的广播就在方法开始的前面几行，所以后面的代码都是对其他情况的处理，以及下一个接收者的方法调用。好了，我们重点关注前面的循环，无序广播存储在mParallelBroadcasts中，系统会遍历并将其中的广播通过deliverToRegisteredReceiverLocked方法发送给它们所有的接收者</p><p>接着看BroadcastQueue的deliverToRegisteredReceiverLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverToRegisteredReceiverLocked</span><span class="params">(BroadcastRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        BroadcastFilter filter, <span class="keyword">boolean</span> ordered, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.i(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Delivering to "</span> + filter + <span class="string">" : "</span> + r);</span><br><span class="line">        <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span> &amp;&amp; filter.receiverList.app.inFullBackup) &#123;</span><br><span class="line">            <span class="comment">// Skip delivery if full backup in progress</span></span><br><span class="line">            <span class="comment">// If it's an ordered broadcast, we need to continue to the next receiver.</span></span><br><span class="line">            <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">                skipReceiverLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//就是这里了</span></span><br><span class="line">            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                    <span class="keyword">new</span> Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                    r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            r.state = BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failure sending broadcast "</span> + r.intent, e);</span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            r.receiver = <span class="keyword">null</span>;</span><br><span class="line">            r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">            filter.receiverList.curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                filter.receiverList.app.curReceivers.remove(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，这个方法的代码也不少，不过前面大多数都是if，说明是一些情况的处理，那么直接看到这个方法的最后，try里面有<code>performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.initialSticky, r.userId);</code>注意方法名，Receive，不是Receiver了，所以从这里开始，我们就要开始准备<strong>接收</strong>了哦</p><hr><p>小分割线，开始准备接收广播…..</p><hr><p>接着看BroadcastQueue的performReceiveLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performReceiveLocked</span><span class="params">(ProcessRecord app, IIntentReceiver receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">// Send the intent to the receiver asynchronously using one-way binder calls.</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we have an app thread, do the call through that so it is</span></span><br><span class="line">            <span class="comment">// correctly ordered with other one-way calls.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//终于看到了熟悉的ApplicationThread了</span></span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">            ...</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于接收广播会调起应用程序，所以app.thread不为null，所以就会执行到ApplicationThread中了</p><p>接着看ApplicationThread的scheduleRegisteredReceiver方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码就比较少了，通过IIntentReceiver调用其performReceive方法，我们知道这个receiver实际上是InnerReceiver，那么接下来就是通过InnerReceiver来实现接收了</p><p>接着看LoadedApk.ReceiverDiaptcher.InnerReceiver的performReceive方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"Null intent received"</span>);</span><br><span class="line">        rd = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//拿到ReceiverDispatcher</span></span><br><span class="line">        rd = mDispatcher.get();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//接着调用ReceiverDispatcher的performReceive方法</span></span><br><span class="line">        rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                ordered, sticky, sendingUser);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在InnerReceiver中会先拿到ReceiverDispatcher，接着调用其performReceive方法</p><p>接着看ReceiverDispatcher的performReceive方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Args实例，内部实现了Runnable</span></span><br><span class="line">    <span class="keyword">final</span> Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"Null intent received"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">            <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">            Slog.i(ActivityThread.TAG, <span class="string">"Enqueueing broadcast "</span> + intent.getAction()</span><br><span class="line">                    + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + mReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mActivityThread就是ActivityThread中的H这个Handler，然后通过post方法来执行这个Args对象的run方法中的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span> || !mActivityThread.post(args.getRunnable())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing sync broadcast to "</span> + mReceiver);</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会先创建一个Args实例，这个类实现了Runnable，然后通过mActivityThread的post方法执Args的run方法，mActivityThread就是ActivityThread的H</p><p>接着就看看Args中Runnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Runnable <span class="title">getRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> ordered = mOrdered;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        <span class="keyword">final</span> Intent intent = mCurIntent;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mCurIntent = <span class="keyword">null</span>;</span><br><span class="line">        mDispatched = <span class="keyword">true</span>;</span><br><span class="line">        mPreviousRunStacktrace = <span class="keyword">new</span> Throwable(<span class="string">"Previous stacktrace"</span>);</span><br><span class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || intent == <span class="keyword">null</span> || mForgotten) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                        <span class="string">"Finishing null broadcast to "</span> + mReceiver);</span><br><span class="line">                sendFinished(mgr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveReg"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader cl = mReceiver.getClass().getClassLoader();</span><br><span class="line">            intent.setExtrasClassLoader(cl);</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">            setExtrasClassLoader(cl);</span><br><span class="line">            <span class="comment">//在这里就调用onReceive方法</span></span><br><span class="line">            receiver.setPendingResult(<span class="keyword">this</span>);</span><br><span class="line">            receiver.onReceive(mContext, intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            finish();</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中我们见到了熟悉的onReceive方法，最终就会回调到我们写onReceive方法那里。所以发送广播后，系统经过一定条件的筛选，最后回调到我们自己写的onReceive方法</p><h2 id="感谢任玉刚大神的Android开发艺术探索"><a href="#感谢任玉刚大神的Android开发艺术探索" class="headerlink" title="感谢任玉刚大神的Android开发艺术探索"></a>感谢任玉刚大神的<strong>Android开发艺术探索</strong></h2>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Activity相关知识总结</title>
      <link href="/2020/02/07/Android%20Activity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/07/Android%20Activity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Activity相关知识总结"><a href="#Activity相关知识总结" class="headerlink" title="Activity相关知识总结"></a>Activity相关知识总结</h1><h2 id="Activity的用法"><a href="#Activity的用法" class="headerlink" title="Activity的用法"></a>Activity的用法</h2><p>Activity主要用于和用户进行交互，负责UI的加载与页面之间的跳转</p><p>应用启动的时候都会加载一个默认的Activity，这就是我们通常的主活动，在AndroidManifest里面设置intent-filter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过给Activity添加如此拦截器，设置为APP的主活动，也就是整个APP的入口（表面上的入口），同时在AndroidManifest里面，标签&lt;activity&gt;就标明了这是一个活动</p><p>直接新建一个应用，默认的Activity会是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中可以看出，Activity就是一个继承AppCompatActivity的类，继承这个类后，就成了一个活动，当然也可以继承Activity这个类，两者的区别在于AppCompatActivity是v7的，也就是兼容性更好，Activity兼容性相比之下比较差一点，当然，现在都一般用AppCompatActivity。</p><p>由此可见，创建一个活动很简单，继承了AppCompatActivity就行了，然后你就可以去操作你的UI加载和布局了</p><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><p>每一个程序都有一个或很多个Activity组成，因此Android内部使用通过回退栈开管理Activity实例，这就是hiActivity栈。对于Android来说，处于栈顶的Activity就是当前显示的页面，通过返回键来销毁这个栈顶的Activity回到上一个Activity<br><a href="http://upload-images.jianshu.io/upload_images/3985563-83df2c2b5d3afafd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3985563-83df2c2b5d3afafd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网上找的图"></a>网上找的图</p><p>通过AndroidManifest的&lt;activity&gt;标签来指定<code>android:launchMode</code>来选择启动模式（或者通过Intent设置标志位来指定启动模式<code>intent.addFlags(Intent,FLAG_ACTIVITY_NEW_TASK);</code>），进而控制Activity栈的出栈规则。Intent则是Android程序中各组件之间进行交互的一种重要方式，不仅可以指明当前组件要执行的动作，还可以在不同组件中传递数据。因此，Activity的启动一般是通过它来实现的。</p><table><thead><tr><th align="center">标志位</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">FLAG_ACTIVITY_NEW_TASK</td><td align="center">新活动放置在新建的一个栈，对应singleTask</td></tr><tr><td align="center">FLAG_ACTIVITY_SINGLE_TOP</td><td align="center">singleTop，处于栈顶不会新建实例</td></tr><tr><td align="center">FLAG_ACTIVITY_CLEAR_TOP</td><td align="center">如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中</td></tr><tr><td align="center">FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</td><td align="center">如果设置，新活动不保存在最近启动的活动列表中，等同于指定<code>android:excludeFromRecents=&quot;true&quot;</code></td></tr><tr><td align="center">FLAG_ACTIVITY_NO_HISTORY</td><td align="center">如果新活动不是在历史栈中，当用户离开这个活动（不管是新启动一个活动还是结束这个活动）就直接结束，设置此标志activity将不添加到回退栈（backStack）</td></tr><tr><td align="center">FLAG_ACTIVITY_MULTIPLE_TASK</td><td align="center">新建一个任务栈，用于放置这个活动，这个标志总是和FLAG_ACTIVITY_NEW_DOCUMENT或者FLAG_ACTIVITY_NEW_TASK联合使用</td></tr><tr><td align="center">FLAG_ACTIVITY_BROUGHT_TO_FRONT</td><td align="center">这个flag不能正常地被应用程序代码设置，而是系统为你设置由于在 launchMode 设置为singleTask模式</td></tr><tr><td align="center">FLAG_ACTIVITY_CLEAR_TASK</td><td align="center">如果通过 Context.startactivity()去设置/启动一个Intent，这个flag将导致任何存在的task，将与活动开始前清除的活动相关</td></tr><tr><td align="center">FLAG_ACTIVITY_FORWARD_RESULT</td><td align="center">如果设置这个intent是被用来从一个现有的acitivity启动到新的acitivity，现有activity的回复目标将被转移到新的activity</td></tr><tr><td align="center">FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</td><td align="center">这个flag不能正常地被应用程序代码设置，而是系统为你设置，如果这个活动正在展开的历史堆栈（长按 Home键）</td></tr><tr><td align="center">FLAG_ACTIVITY_NEW_DOCUMENT</td><td align="center">此标志用于将文档打开到一个新的任务中，该任务源于intent启动的活动</td></tr><tr><td align="center">FLAG_ACTIVITY_NO_ANIMATION</td><td align="center">如果通过 Context.startactivity()去设置/启动一个Intent，这个标志将阻止系统执行一个活动去下一个活动的过渡动画</td></tr><tr><td align="center">FLAG_ACTIVITY_NO_USER_ACTION</td><td align="center">设置此标志，将阻止onuserleavehint()正常回调发生在当前最前的活动，在它被停下来作为新启动活动被带到前面</td></tr><tr><td align="center">FLAG_ACTIVITY_PREVIOUS_IS_TOP</td><td align="center">如果设置并使用此意图从现有的一个activity a启动到新activity b，新avitivity b将不会被视为栈顶而是activity a，而是决定是否新意图传递到顶部而不是启动新的活动</td></tr><tr><td align="center">FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</td><td align="center">设置此标志使这个活动要么开始在一个新的任务或带到现有的任务的顶部，那么它将被启动作为任务的前门</td></tr><tr><td align="center">FLAG_ACTIVITY_REORDER_TO_FRONT</td><td align="center">如果在通过 Context.startactivity()去设置/启动一个Intent，如果需要启动的activity已经运行，此标志使被启动的活动被带到任务的历史堆栈的前面</td></tr><tr><td align="center">FLAG_ACTIVITY_TASK_ON_HOME</td><td align="center">如果在通过 Context.startactivity()去设置/启动一个Intent，此flag将使新启动任务置于当前活动任务的顶部（如果只有一个task时）</td></tr><tr><td align="center">FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</td><td align="center">这个常数是在API级别21废弃掉。在API 21执用 flag_activity_new_document 替代</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, TargetActivity.class);</span><br><span class="line">intent.addFlags(Intent,FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>这就是简单活动的启动</p><p>Activity可以通过Intent来实现启动各组件之间的通信。首先我们先见识了显示启动Activity的用法，现在看看隐式使用Intent。</p><p>首先在AndroidManifest中，通过&lt;activtiy&gt;标签被指&lt;intent-filter&gt;来指定活动响应的action和category</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"com.example.a14512.activitydemo.ACTION_START"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"com.example.a14512.activitydemo.MY_CATEGORY"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动活动，传入action</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.a14512.activitydemo.ACTION_START"</span>);</span><br><span class="line"><span class="comment">//添加category</span></span><br><span class="line">intent.addCategory(<span class="string">"com.example.a14512.activitydemo.MY_CATEGORY"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>每个Intent只能指定一个action，但是可以指定多个category，通过addCategory来添加（启动活动时一定要注意action和category要与AndroidManifest中的匹配对应，否则出现找不到Activity的崩溃）；除了action和category外，还有一个data，一旦在&lt;intent-filter&gt;设置了这三个过滤类别，当启动activity的时候，Intent必须完全匹配这些才能成功启动Activity。另外，一个intent-filter可以有有多个action、category、data，而一个Activity可以有多个intent-filter，一个Intent只要能匹配其中一个组就可以启动Activity</p><ul><li><p>Intent-filter匹配规则</p><ol><li><p>action<br> 是一个字符串，系统预定义了一些action，同时我们也可以定义自己的action。Intent中的action必须和intent-filter中的action匹配（字符串值完全一样）。 action字符串区分大小写</p></li><li><p>category<br> 是一个字符串，系统预定义了一些category，也可以自定义。Intent中可以不用设置category（系统会默认添加默认的default，intent-filter必须添加一个default的category），但一旦设置了，就必须和intent-filter中的category中的一个匹配</p></li><li><p>data<br> 和action类似，如果intent-filter中定义了data，Intent必须也要定义可匹配的data<br> data语法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;data android:scheme=<span class="string">"string"</span></span><br><span class="line">            android:host=<span class="string">"string"</span></span><br><span class="line">            android:port=<span class="string">"string"</span></span><br><span class="line">            android:path=<span class="string">"string"</span></span><br><span class="line">            android:pathPattern=<span class="string">"string"</span></span><br><span class="line">            android:pathPrefix=<span class="string">"string"</span></span><br><span class="line">            android:mimeType=<span class="string">"string"</span> /&gt;</span><br></pre></td></tr></table></figure><p> data由mimeType和URI两部分组成，mimeType指媒体类型，比如image/jpeg、video/*等，可以表示图片、文本、视频等不同的媒体格式。</p><p> URI的结构：<br> <code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code></p><blockquote><p>scheme：URI的模式，比如http、file、content；如果没有指定scheme，则整个URI无效<br>host：URI的主机名<br>port：URI中的端口号<br>path、pathPattern、pathPrefix：表述路径信息，path表示完整路径，pathPattern也表示完整路径，但是可以包含*统配符，pathPrefix表示路径的前缀信息</p></blockquote><p> 一个小例子：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;data android:scheme=<span class="string">"image/*"</span>/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//intent使用，如果传入的uri参数与intent-filter中不匹配就会报错</span></span><br><span class="line"><span class="comment">//不能先调用setData，再调用setType</span></span><br><span class="line">intent.setDataAndType(Uri.parse(<span class="string">"file://abc"</span>), <span class="string">"image/png"</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>在每次使用隐式启动Activity时，可以通过PackageManager的resolveActivity或Intent的resolveActivity方法先检测是否有Activity匹配，放止找不到Activity。</p><ul><li><p>隐式Intent的其他用法</p><ol><li><p>打开网页</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Android内置的动作</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line"><span class="comment">//setData接受一个Uri对象，主要用于指定正在操作的数据</span></span><br><span class="line">intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li><li><p>调用拨号</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内置的动作</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL);</span><br><span class="line"><span class="comment">//同样一个Uri对象</span></span><br><span class="line">intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>下面介绍四种启动模式</p><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a><strong>standard</strong></h3><p>Activity的标准启动模式，当你没有通过<code>android:launchMode</code>来指定启动模式的时候，Activity的启动模式就是这个了。</p><p>在这种情况下，Activity的实例可以有多个，Activity可以被多次实例化。每启动一个Activity，Activity栈中就会有这么一个实例，Activity栈不会管之前创建没有，会重复实例化。<br><a href="https://upload-images.jianshu.io/upload_images/4061843-8ce1962079fe22e0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-8ce1962079fe22e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="借用郭神的示例图"></a>借用郭神的示例图</p><p>在MainActivity的布局添加一个Button，用来启动Activity，打印日志<br><a href="https://upload-images.jianshu.io/upload_images/4061843-909953040b9cc7ad.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-909953040b9cc7ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="standard"></a>standard由此可见，每启动一个Activity，就会新建一个Activity的实例，依次放入栈中</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a><strong>singleTop</strong></h3><p>栈顶复用模式，在这中模式下，如果Activity已经处于栈顶，重复启动这个Activity的话，不会新建这个Activity的实例，会重用这个已经在栈顶的Activity，并会调用该实例的onNewIntent函数将Intent对象传递到这个实例中；但是如果不在栈顶的话，启动一个Activity就会新建一个Activity的实例，即使以前创建了一次，这也就意味着，不是栈顶的Activity仍然可以重复实例化<br><a href="https://upload-images.jianshu.io/upload_images/4061843-0718c07f0a8a513a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-0718c07f0a8a513a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="处于栈顶"></a>处于栈顶<br><a href="https://upload-images.jianshu.io/upload_images/4061843-674b6ab8f33a39c2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-674b6ab8f33a39c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="没有处于栈顶"></a>没有处于栈顶</p><p>新建一个SecondActivity，将SecondActivity和MainActivity的启动模式设为singleTop，先启动SecondActivity，再启动一次SecondActivity，打印日志<br><a href="https://upload-images.jianshu.io/upload_images/4061843-1721e603d9e0de8c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-1721e603d9e0de8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png由此可见，不管你在SecondActivity启动几次SecondActivity，它总是不会新建实例，只会重新调用onNewIntent这个方法来接受传递过来的Intent</p><p>然后再试一下，启动MainActivity，再启动SecondActivity，最后再启动MainActivity<br><a href="https://upload-images.jianshu.io/upload_images/4061843-08e44548d89d4933.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-08e44548d89d4933.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png可以看见，当MainActivity和SecondActivity不是处于栈顶的时候，就可以再次创建自己的实例</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a><strong>singleTask</strong></h3><p>栈内复用模式，是一种单实例模式，在一个Activity栈中只能存在一个实例，当启动一个Activity后，系统会首先查找是由存在A想要的任务栈，如果不存在，就要重新创建一个，然后在把这个Activity的实例放到任务栈中；如果已经存在这个Activity要的任务栈，就查看栈中是否有这个Activity的实例，如果已存在这个Activity的实例，当再一次启动的时候，如果上面有其他的Activity，就会销毁该Activity上的所有Activity，最终让这个Activity处于栈顶，然后调用onNewIntent函数</p><ul><li><p>如果要启动的Activity需要的栈就是跟MainActivity一个栈<br>  <a href="https://upload-images.jianshu.io/upload_images/4061843-f537a3dae37e9fd8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-f537a3dae37e9fd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同一个栈"></a>同一个栈</p></li><li><p>要启动的Activity跟MainActivity不是同一个栈（开发艺术探索）<br>  <a href="https://upload-images.jianshu.io/upload_images/4061843-2deca2228ccf3d3a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-2deca2228ccf3d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同栈，且处于栈顶"></a>不同栈，且处于栈顶</p><p>  <a href="https://upload-images.jianshu.io/upload_images/4061843-048db956f587adc5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-048db956f587adc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同栈，但不是栈顶"></a>不同栈，但不是栈顶</p></li></ul><p>创建ThirdActivity，启动模式设为singlTask。其余默认<br><a href="https://upload-images.jianshu.io/upload_images/4061843-b3a68a0130c09228.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-b3a68a0130c09228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png可以看到，先启动了ThirdActivity，接着启动了SecondActivity，然后又启动ThirdActivity，ThirdActivity并没有重新实例化，而是restart了之前的，并销毁了SecondActivity。</p><p>将ThirdActivity单独指定一个栈，启动模式为singleTask，其余为默认，然后一次启动MainActivity、SecondActivity、ThirdActivity，再次启动ThirdActivity<br><a href="https://upload-images.jianshu.io/upload_images/4061843-c2ef318fad9ba1f1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-c2ef318fad9ba1f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同栈，且处于栈顶"></a>不同栈，且处于栈顶可以看出，单独一个栈的ThirdActivity已经处于栈顶，不管你重复启动多少次，都不会变</p><p>将FourthActivity和ThirdActivity单独指定一个栈，利用<code>android:taskAffinity</code>指定，ThirdActivity设置启动模式为singleTask，其他默认，然后先启动SecondActivity，接着启动ThirdActivity，再启动FourthActivity，再启动ThirdActivity，打印日志<br><a href="https://upload-images.jianshu.io/upload_images/4061843-3d43ba6987c31fe2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-3d43ba6987c31fe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同栈，不是栈顶"></a>不同栈，不是栈顶可以看出，当单独一个栈的ThirdActivity和FourthActivity，重新启动ThirdActivity，会销毁FourthActivity，但不会影响MainActivity这个栈的活动</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a><strong>singleInstance</strong></h3><p>这是一种加强的单实例模式，在一个Activity栈中只能存在一个实例，且这个栈是独立的一个栈，保证整<br>个系统中只有一个singleInstance的栈和一个Activity实例<br><a href="https://upload-images.jianshu.io/upload_images/4061843-efb2d9b75211992e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-efb2d9b75211992e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png</p><p>将SecondActivity的启动模式改为singleInstance，其余默认，然后依次启动MainActivity、SecondActivity、FourthActivity<br><a href="https://upload-images.jianshu.io/upload_images/4061843-c29d1feeb1430261.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-c29d1feeb1430261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png可以看出，SecondActivity和MainActivity的TaskId并不一致，说明它们不处于同一个栈</p><h2 id="Activity和其他组件的通信"><a href="#Activity和其他组件的通信" class="headerlink" title="Activity和其他组件的通信"></a>Activity和其他组件的通信</h2><h3 id="Activity和Activity"><a href="#Activity和Activity" class="headerlink" title="Activity和Activity"></a>Activity和Activity</h3><p>首先，我们可以通过Intent来显示启动活动，那么与此同时，我们可以通过Intent来向启动的活动传递数据，进而进行通信</p><h4 id="使用Intent"><a href="#使用Intent" class="headerlink" title="使用Intent"></a>使用Intent</h4><ul><li><p>intent向下一个活动传递数据：<br>  先来个简单的例子</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line"><span class="comment">//传递一个String数据</span></span><br><span class="line">intent.putExtra(<span class="string">"data_key"</span>, <span class="string">"MainActivity"</span>);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line">Intent intent = getIntent();</span><br><span class="line"><span class="comment">//根据key值接收String数据</span></span><br><span class="line">String data = intent.getStringExtra(<span class="string">"data_key"</span>);</span><br></pre></td></tr></table></figure><p>  这就是一个简单的数据传递</p><p>  Intent传递的数据也是有限的，只能传递基本类型、String、Parcelable、Serializable以及它们相关的数组类型，这是Intent可以直接传递的类型，当然，还可以将数据装在Bundle里面，通过Intent来传递，同样在传递时，都需要指定一个String的name值，方便在接收的时候准确获取对应的数据。</p></li><li><p>intent返回数据给上一个活动<br>  一个例子</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动活动</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line"><span class="comment">//requestCode设置为1</span></span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写方法，requestCode一般使用系统内置的，也可以自己自定义，resultCode时我们前面设置的</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">            <span class="comment">//判断数据来源</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">//获取数据</span></span><br><span class="line">                String resultData = data.getStringExtra(<span class="string">"data_key"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在结束活动的时候</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"data_key"</span>, <span class="string">"result"</span>);</span><br><span class="line"><span class="comment">//第一个参数用于向上一个活动返回处理结果，一般为RESULT_OK或RESULT_CANCELED，第二个参数用于返回带有数据的Intent</span></span><br><span class="line">setResult(RESULT_OK, intent);</span><br></pre></td></tr></table></figure></li></ul><h4 id="借助类的静态变量"><a href="#借助类的静态变量" class="headerlink" title="借助类的静态变量"></a>借助类的静态变量</h4><p>由于类的静态成员可以通过“className.fileName”进行访问，所以可以在Activity中生命一个静态变量从而实现Activity之间的数据通信</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity中</span></span><br><span class="line"><span class="comment">//先查看值</span></span><br><span class="line">LogUtil.d(SecondActivity.name);</span><br><span class="line">SecondActivity.name = <span class="string">"MainActivity change"</span>;</span><br><span class="line"><span class="comment">//查看修改后的值</span></span><br><span class="line">LogUtil.d(SecondActivity.name);</span><br><span class="line">Button button = findViewById(R.id.btnStartActivity);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SecondActivity中，声明一个静态变量并赋予初值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"SecondActivity"</span>;</span><br><span class="line"><span class="comment">//启动SecondActivity后查看值是否变更</span></span><br><span class="line">LogUtil.d(name);</span><br></pre></td></tr></table></figure><p>结果：<br><a href="https://upload-images.jianshu.io/upload_images/4061843-daa46052a40b37e3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-daa46052a40b37e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>可以看出，我们可以访问SecondActivity的静态变量，通过这个例子，我们也可以实现两个Activity之间的通信</p><h4 id="通过全局变量-Application"><a href="#通过全局变量-Application" class="headerlink" title="通过全局变量/Application"></a>通过全局变量/Application</h4><p>跟在Activity中生命一个静态变量类似，只不过单独一个类生命的静态变量就是全局访问的，这就跟我们平时会写一个Config类来管理全局静态常量类似。就是访问同一块内存区（内存共享）</p><p>小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三方类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"Config"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MainActivity中</span></span><br><span class="line">LogUtil.d(Config.name);</span><br><span class="line">Config.name = <span class="string">"MainActivity change"</span>;</span><br><span class="line">LogUtil.d(Config.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SecondActivity中</span></span><br><span class="line">LogUtil.d(Config.name);</span><br></pre></td></tr></table></figure><p>结果：<br><a href="https://upload-images.jianshu.io/upload_images/4061843-fce165e51ca8bef8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-fce165e51ca8bef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>从结果中就可以看出，效果跟前面一个是一样的，原理其实也差不多</p><h4 id="Broadcast或者LocalBroadcast"><a href="#Broadcast或者LocalBroadcast" class="headerlink" title="Broadcast或者LocalBroadcast"></a>Broadcast或者LocalBroadcast</h4><p>在一个Activity发送广播，在另一个接受并解析数据</p><h4 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h4><p>外部存储就是通过访问第三方，来实现数据通信（这个需要注意同步并发的问题），一下几个基本上都是数据的持久化</p><ul><li>SharedPreference</li><li>SQLite</li><li>File</li><li>Service<br>  后台服务，数据存取，直连的Activity就可以使用这些数据</li></ul><h4 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h4><p>适用于页面之间的信息传递和同步，EventBus是一个第三方库，不仅可以用于Activity和Activity，其余的组件间都可以，这个开源库就是用来进行组件间的通信的</p><h4 id="RxBus"><a href="#RxBus" class="headerlink" title="RxBus"></a>RxBus</h4><p>类似于EventBus，就是EventBus的一种替代</p><h4 id="otto"><a href="#otto" class="headerlink" title="otto"></a>otto</h4><p>OTTO是Square推出的库，原理与EventBus相同，实现方式也非常类似。不同的是接收方的回调方法不是固定的那四个，而是通过@Subscribe注解标志来识别接收方的回调方法的。</p><h3 id="Activity和Fragment"><a href="#Activity和Fragment" class="headerlink" title="Activity和Fragment"></a>Activity和Fragment</h3><ol><li><p>如果Activity中有Fragment实例，可以通过直接调用Fragment中的public方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fragment"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity中使用</span></span><br><span class="line">Fragment1 fragment1 = <span class="keyword">new</span> Fragment1();</span><br><span class="line">fragment1.getFun();</span><br></pre></td></tr></table></figure></li><li><p>如果Activity中没有Fragment实例，每个Fragment都有唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行1中的操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过findFragmentById方法获取Fragment</span></span><br><span class="line">Fragment1 fragment1 = (Fragment1) getSupportFragmentManager().findFragmentById(R.id.fragment1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过findFragmentByTag</span></span><br><span class="line">Fragment1 fragment1 = (Fragment1) getSupportFragmentManager().findFragmentByTag(<span class="string">"Fragment1"</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果Activity向Fragment传递参数，在Activity通过setArguments传递，在Fragment通过getArguments获取<br> 官方文档推荐，在每个Frament里必须有一个空的构造函数，以便其可以实例化，但是不推荐含有带参的构造方法，用来传递参数，因为这些构造函数，并不能在调用Fragment时，将Fragment重新实例化，如果需要传递参数，可以通过setArguments传递，在Fragment通过getArguments。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fragment1 fragment1 = <span class="keyword">new</span> Fragment1();</span><br><span class="line"><span class="comment">//通过setArguments和Bundle传递数据</span></span><br><span class="line">fragment1.setArguments(<span class="keyword">new</span> Bundle());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Activity传递过来的数据</span></span><br><span class="line">Bundle bundle = getArguments();</span><br></pre></td></tr></table></figure></li><li><p>通过回调<br> （1）在Activity中写接口，Fragment实现接口，在Activity回调</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getFun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MainListener mMainListener;</span><br><span class="line">Fragment1 fragment1 = <span class="keyword">new</span> Fragment1();</span><br><span class="line">mMainListener = fragment1;</span><br><span class="line"><span class="comment">//回调</span></span><br><span class="line">mMainListener.getFun1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fragment中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">MainActivity</span>.<span class="title">MainListener</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtil.d(<span class="string">"main interface"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> （2）在Fragment中写接口，Activity实现接口，在Fragment中回调</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Fragment中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FragmentListener mListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mListener = (FragmentListener) getActivity();</span><br><span class="line">        <span class="comment">//回调</span></span><br><span class="line">        mListener.getFun2();</span><br><span class="line">        View view = inflater.inflate(R.layout.fragment1, container, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FragmentListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getFun2</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity中实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">Fragment1</span>.<span class="title">FragmentListener</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtil.d(<span class="string">"fragment interface"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 由此看来，回调的方法是可以行的，不管你在Activity中回调还是在Fragment中回调都是可以的</p></li><li><p>Handler<br> 也可以使用Handler实现组件通信</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity</span></span><br><span class="line"><span class="meta">@SuppressLint</span>(<span class="string">"HandlerLeak"</span>)</span><br><span class="line"><span class="keyword">public</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fragment</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttach(activity);</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> MainActivity) &#123;</span><br><span class="line">        Handler handler = ((MainActivity) activity).mHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>广播</p></li><li><p>EventBus</p></li><li><p>RxBus</p></li></ol><h3 id="Activity和Service"><a href="#Activity和Service" class="headerlink" title="Activity和Service"></a>Activity和Service</h3><ul><li><p>Activity启动Service的两种方式:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CustomService 是自定义Service，完成一些后台操作</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>，CustomService.class)；</span><br><span class="line"><span class="comment">//start和stop Service的时候都可以进行数据传递</span></span><br><span class="line">startService(intent);</span><br><span class="line">stopService(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过绑定服务启动，来进行一些操作</span></span><br><span class="line">bindService(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>，CustomService.class)), <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当前启动的service 一些数据就会回调回这里，我们在Activity中操作这些数据即可</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, flags);</span><br></pre></td></tr></table></figure><p>  从启动方式就可以看出，通过Bundle对象的形式存储，通过Intent传输，来完成Activity向Service传递数据的操作</p></li><li><p>接口回调<br>  Service设置接口实例，Activity实现</p></li></ul><h3 id="Activity和Broadcast"><a href="#Activity和Broadcast" class="headerlink" title="Activity和Broadcast"></a>Activity和Broadcast</h3><p>通过发送广播，利用Intent传递数据，实现Activity和Broadcast的通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><p>Activity与BroadcastReceiver通信时，用的也是Intent传递，Bundle存储</p><h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><p><a href="http://upload-images.jianshu.io/upload_images/3985563-a2caa08d3cbca003.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3985563-a2caa08d3cbca003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="经典周期图"></a>经典周期图</p><h3 id="典型情况下的生命周期"><a href="#典型情况下的生命周期" class="headerlink" title="典型情况下的生命周期"></a>典型情况下的生命周期</h3><ol><li>onCreat<br> 表示Activity正在被创建，生命周期的第一个方法。一般做一些初始化的工作</li><li>onStart<br> 表示Activity正在启动，即将开始，Activity已经可见，但是没有出现在前台（在后台），还无法和用户交互（我们无法看到，但是Activity已经显示出来）</li><li>onResume<br> 表示Activity已经可见了，并且出现在前台并开始活动。</li><li>onPause<br> 表示Activity正在停止，正常情况onStop会接着调用。特殊情况下，如果快速地返回当前Activity，会调用onResume</li><li>onStop<br> 表示Activity即将停止，可以做一些稍微重量级的回收工作，不能耗时操作</li><li>onDestroy<br> 表示Activity即将被销毁，做一些回收工作和最终的资源释放</li><li>onRestart<br> 表示Activity正在重新启动。一般情况下，Activity由不可见重新变为可见状态时调用</li></ol><p>除了onRestart方法，其余的都是两两相对的，从而可以分为3中生存期</p><ul><li>完整生存期<br>  在onCreat和onDestroy方法之间所经历的就是一个正常的完整的周期</li><li>可见生存周期<br>  在onStart和onStop方法之间所经历的就是可见生存期，在这个周期内，活动对于用户总是可见的，即使可能无法交互。</li><li>前台生存期<br>  在onResume和onPause方法之间所经历的就是前台生存期，在这个期间，活动总是处于运行状态的，可以和用户交互</li></ul><p>小例子：<br>当启动一个正常的活动时，观察MainActivity的生命周期，当启动MainActivity时，onCreat、onStart、onResume先后调用<br><a href="https://upload-images.jianshu.io/upload_images/4061843-a75c83eefd1005a0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-a75c83eefd1005a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png</p><p>接着启动SecondActivity，观察MainActivity的周期，发现，onPause、onStop被调用了，此时MainActivity被SecondActivity遮挡了。从结果中同样可以观察到，先是MainActivity的onPause调用，然后是SecondActivity的onCreate、onStart、onResume被调用（此时，MainActivity变为完全不可见了），然后MainActivity的onSavaInstanceState、onStop被调用<br><a href="https://upload-images.jianshu.io/upload_images/4061843-8d2799aab84769f6.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-8d2799aab84769f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png</p><p>接着按下back键，返回MainActivity，此时onRestart、onStart、onResume调用（此前MainActivity是停止状态，所以不会重建调用onCreate）。从结果中还以知道，先是SecondActivity的onPause被调用，接着MainActivity的onRestart、onStart、onResume被调用，然后SecondActivity的onStop、onDestroy被调用。说明SecondActivity的回收需要时间，会先onPause，然后展示MainActivity让它置于前台，最后才慢慢收回SecondActivity<br><a href="https://upload-images.jianshu.io/upload_images/4061843-f5931b493ab0279b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-f5931b493ab0279b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png</p><p>当点击按钮，启动DialogActivity（主题设置为Dialog，对话框式的活动），发现MainActivity只有onPause调用了，onStop并没有调用（因为Dialog并没有完全遮挡MainActivity），按下back键，MainActivity的onResume调用。<br><a href="https://upload-images.jianshu.io/upload_images/4061843-ddde0b9f57d12d84.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-ddde0b9f57d12d84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br><a href="https://upload-images.jianshu.io/upload_images/4061843-1be8fe28f84d8dbd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-1be8fe28f84d8dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png</p><p>同理，如果启动一个Activity采用了透明主题，那么也会只调用onPause而不会调用onStop<br><a href="https://upload-images.jianshu.io/upload_images/4061843-3e81ecf46caf577f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-3e81ecf46caf577f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>按下back键后，MainActivity不会调用onRestart、onStart方法，直接调用onResume<br><a href="https://upload-images.jianshu.io/upload_images/4061843-4e875ba6e5047470.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-4e875ba6e5047470.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png</p><p>最后back键退出MainActivity，onPause、onStop、onDestroy依次调用<br><a href="https://upload-images.jianshu.io/upload_images/4061843-903fe3056dc8a5fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-903fe3056dc8a5fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png</p><p>onSaveInstanceState方法用于数据临时保存，在活动被系统回收之前一定会被调用，主动销毁活动不会调用这个方法。</p><p>当targetSdkVersion小于等于11（也就是2.3及其之前）时onSaveInstanceState是在onPause方法中调用的，而大于11（3.0开始）时是在onStop方法中调用的。<br>而onRestoreInstanceState是在onStart之后、onResume之前调用的</p><h3 id="异常情况下的生命周期"><a href="#异常情况下的生命周期" class="headerlink" title="异常情况下的生命周期"></a>异常情况下的生命周期</h3><ul><li><p>资源相关的系统配置发生改变导致Activity被杀死并重新创建<br>  例如横竖屏切换：targetSdkVersion小于等于10时<a href="https://upload-images.jianshu.io/upload_images/4061843-c63dfd46457150c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-c63dfd46457150c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>  targetSdkVersion大于10时<br>  <a href="https://upload-images.jianshu.io/upload_images/4061843-1b761d4a24ebdf42.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4061843-1b761d4a24ebdf42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a>image.png<br>  这两者的区别就是onSaveInstanceState和onPause调用的先后顺序不同，&lt;=10的时候式onSaveInstanceState先于onPause被调用，&gt;10的的时候式onPause先于onSaveInstanceState被调用</p></li><li><p>资源内存不足导致低优先级的Activity被杀死<br>  优先级：</p><blockquote><p>(1) 前台Activity——正在和用户交互的Activity，优先级最高<br>(2) 可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户交互<br>(3) 后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低</p></blockquote><p>  当系统内存不足时，会按照上述优先级从低到高去杀死目标Activity所在的进程。我们在平常使用手机时，能经常感受到这一现象。这种情况下数组存储和恢复过程和上述情况一致，生命周期情况也一样</p><p>  对应的三种运行状态：</p><blockquote><p>(1)Resumed（活动状态） 又叫Running状态，这个Activity正在屏幕上显示，并且有用户焦点。这个很好理解，就是用户正在操作的那个界面</p><p>②Paused（暂停状态） 这是一个比较不常见的状态。这个Activity在屏幕上是可见的，但是并不是在屏幕最前端的那个Activity。比如有另一个非全屏或者透明的Activity是Resumed状态，没有完全遮盖这个Activity</p><p>③Stopped（停止状态） 当Activity完全不可见时，此时Activity还在后台运行，仍然在内存中保留Activity的状态，并不是完全销毁。这个也很好理解，当跳转的另外一个界面，之前的界面还在后台，按回退按钮还会恢复原来的状态，大部分软件在打开的时候，直接按Home键，并不会关闭它，此时的Activity就是Stopped状态</p></blockquote></li></ul><p>可以通过在AndroidManifest文件的Activity中指定如下属性：<code>android:configChanges = &quot;orientation| screenSize&quot;</code>来避免横竖屏切换时，Activity的销毁和重建，而是回调了下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">configChanges的项目</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">locale</td><td align="center">设备的本地位置发生了改变，一般指切换了语言</td></tr><tr><td align="center">orientation</td><td align="center">屏幕方向发生了改变，比如旋转屏幕</td></tr><tr><td align="center">keyboardHidden</td><td align="center">键盘的访问性发生了改变，比如调出键盘</td></tr><tr><td align="center">mcc</td><td align="center">SIM卡唯一标识的国家代码，标识mcc代码发生了改变</td></tr><tr><td align="center">mnc</td><td align="center">SIM的运营商代码。标识mnc发生改变</td></tr><tr><td align="center">touchscreen</td><td align="center">触摸屏发生了改变，正常情况不会发生</td></tr><tr><td align="center">keyboard</td><td align="center">键盘类型发生了改变，比如使用了外接键盘</td></tr><tr><td align="center">navigation</td><td align="center">系统导航方式发生了改变，比如是否开启了夜间模式</td></tr><tr><td align="center">screenLayout</td><td align="center">屏幕布局发生了改变，很可能是用户激活了另外一个显示设备</td></tr><tr><td align="center">fontScale</td><td align="center">系统字体缩放比例发生了改变，比如选择一个新字号</td></tr><tr><td align="center">uiMode</td><td align="center">用户界面模式发生了改变，比如开启夜间模式</td></tr><tr><td align="center">screenSize</td><td align="center">屏幕的尺寸信息发生了改变，当旋转屏幕时，屏幕尺寸会发生变化</td></tr><tr><td align="center">smallestScreenSize</td><td align="center">设备的物理屏幕尺寸发生改变</td></tr><tr><td align="center">layoutDirection</td><td align="center">布局方向发生改变</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><p>只有前三个经常用到，其他很少使用</p><h2 id="Activity的启动过程（源码分析）"><a href="#Activity的启动过程（源码分析）" class="headerlink" title="Activity的启动过程（源码分析）"></a>Activity的启动过程（源码分析）</h2><h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><ol><li><p>Activity与Service通信的方式<br> 启动服务的时候可以通信<br> bindService的时候，进行通信<br> 回调接口，在Service中实例回调，Activity中实现</p></li><li><p>前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。<br> 先是onPasuse，然后新活动的onCreate、onStart、onResume，再是旧的onSaveInstanceState用于保存数据，接着是onStop</p><p> 弹出Dialog，activity的生命周期不变，Dialog和Toast时通过Window添加的View，不会对Activity的生命周期有影响</p></li><li><p>Activity 上有 Dialog 的时候按 home 键时的生命周期<br> onPause、onSaveInstanceState、onStop</p></li><li><p>横竖屏切换的时候，Activity 各种情况下的生命周期<br> 当targetSdkVersion大于等于10时：<br> onPase、onSavInstanceState、onStop、onDestroy、onCreate、onStart、onRestoreInstanceState、onResume</p><p> 当targetSdkVersion小于10时：<br> onSavInstanceState、onPase、onStop、onDestroy、onCreate、onStart、onRestoreInstanceState、onResume</p></li><li><p>四大组件<br> Activity：一个界面、活动<br> Service：服务<br> Broadcast：你的应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应<br> ContentProvider：使一个应用程序的指定数据集提供给其他应用程序</p></li><li><p>四大组件是在主线程运行的吗<br> 都是的</p></li><li><p>怎么启动activity<br> Intent隐式启动或显示启动<br> 隐式启动：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"com.example.a14512.activitydemo.ACTION_START"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"com.example.a14512.activitydemo.MY_CATEGORY"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动活动，传入action</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.a14512.activitydemo.ACTION_START"</span>);</span><br><span class="line"><span class="comment">//添加category</span></span><br><span class="line">intent.addCategory(<span class="string">"com.example.a14512.activitydemo.MY_CATEGORY"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p> 显示启动：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, TargetActivity.class);</span><br><span class="line">intent.addFlags(Intent,FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li><li><p>描述一下Activity栈<br> Activity的管理是采用任务栈的形式，任务栈采用“后进先出”的栈结构</p></li><li><p>保存Activity状态<br> onSaveInstanceState、onRestoreInstanceState</p></li><li><p>下拉状态栏是不是影响activity的生命周期，如果在onStop的时候做了网络请求，onResume的时候怎么恢复<br>下拉状态栏不影响生命周期</p></li><li><p>两个Activity 之间跳转时必然会执行的是哪几个方法？<br>旧Activity的onPause，新Activity的onCreate、onStart、onResume，旧Activity的onStop、onSaveInstanceState</p></li><li><p>Activity之间的通信方式<br>Intent、广播、EventBus、RxBus、otto、静态变量、全局变量、外部存储</p></li><li><p>Activity的启动模式，每种启动模式的使用场景，singletop中回调onNewIntent和finish掉之后onCreate()有什么不同？<br>singleTop的模式下，如果Activity已经处于栈顶，那么接着再次启动这个Activity，就会调用onNewIntent来接受Intent实例，因为这个Activity没有发生改变，而不是重新新建一个Activity的实例放于任务栈中。如果不是栈顶，那么还是会新建要给实例，会调用onCreate</p><p>而finish掉后的onCreate就是新建了一个Activity的实例，然后放于任务栈中</p></li><li><p>singleTask启动模式、Activity的启动模式以及使用场景<br>栈内复用模式，是一种单实例模式，在一个Activity栈中只能存在一个实例，当启动一个Activity后，系统会首先查找是由存在A想要的任务栈，如果不存在，就要重新创建一个，然后在把这个Activity的实例放到任务栈中；如果已经存在这个Activity要的任务栈，就查看栈中是否有这个Activity的实例，如果已存在这个Activity的实例，当再一次启动的时候，如果上面有其他的Activity，就会销毁该Activity上的所有Activity，最终让这个Activity处于栈顶，然后调用onNewIntent函数</p></li><li><p>Activity的生命周期和缓存<br>正常的生命周期：onCreate、onStart、onResume、onPause、onStop、onDestroy（可能会出现的onRestart）</p><p>缓存：Activity 由于异常终止时，系统会调用 onSaveInstanceState()来保存 Activity 状态(onStop()之前和onPause()没有既定的时序关系)。当重建时，会调用 onRestoreInstanceState()，并且把 Activity 销毁时 onSaveInstanceState()方法所保存的 Bundle 对象参数同时传递给 onSaveInstanceState()和onCreate()方法。因此，可通过 onRestoreInstanceState()方法来恢复 Activity 的状态，该方法的调用时机是在 onStart()之后。onCreate()和 onRestoreInstanceState()的区别：onRestoreInstanceState()回调则表明其中Bundle对象非空，不用加非空判断。onCreate()需要非空判断。建议使用onRestoreInstanceState().</p></li><li><p>切换activity执行顺序<br>旧Activity的onPause，新Activity的onCreate、onStart、onResume，旧Activity的onStop、onSaveInstanceState</p></li><li><p>如何安全的退出一个已经开启多个activity的APP<br>使用广播关闭所有的Activity或者通过Activity栈来管理所有的活动，在退出时安全结束所有的活动</p></li><li><p>Activity启动模式，intent匹配规则<br>standard、singleTop、singleTask、singleInstance<br>匹配规则：Intent指定的唯一action、多个category、多个data都要在intent-filter中匹配（找到字符串值相同的）才算匹配成功，如果匹配一个没有在intent-filter中声明的活动会直接报错</p></li><li><p>如何判断一个activity（启动方式是singtonTop）是正常启动还是复用启动<br>生命周期可以监测到，正常启动的Activity会经历onCreate、onStart、onResume方法，而复用启动的Activity不会onCreate、onStart</p><p>还可以查看onNewIntent方法是否被调用，只有复用启动的情况下，onNewIntent方法会调用</p></li><li><p>Android里的Intent传递的数据有大小限制吗，如何解决？<br>不仅有大小限制（1MB左右，不同机型不一样），而且还有类型限制，最好的方式就是通过Bundle这个容器来装数据（也不建议传递大量数据），然后进行数据传递</p><p>数据持久化、ContentProvider、EventBus</p></li><li><p>Intent的使用方法，可以传递哪些数据类型<br>显示或隐式启动一个活动，传递数据<br>可以传递基本类型、String、Parcelable、Serializable及其数组类型，还有就是Bundle容器</p></li><li><p>四种LaunchMode及其使用场景<br>standard：绝大多数Activity。如果以这种方式启动的Activity被跨进程调用，在5.0之前新启动的Activity实例会放入发送Intent的Task的栈的顶部，尽管它们属于不同的程序，这似乎有点费解看起来也不是那么合理，所以在5.0之后，上述情景会创建一个新的Task，新启动的Activity就会放入刚创建的Task中，这样就合理的多了</p><p>singleTop：在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。当然实际的开发过程中，测试妹纸没准给你提过这样的bug：某个场景下连续快速点击，启动了两个Activity。如果这个时候待启动的Activity使用 singleTop模式也是可以避免这个Bug的。同standard模式，如果是外部程序启动singleTop的Activity，在Android 5.0之前新创建的Activity会位于调用者的Task中，5.0及以后会放入新的Task中</p><p>singleTask：大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，都应该使用将主界面Activity上所有的Activity移除的方式来让主界面Activity处于栈顶，而不是往栈顶新加一个主界面Activity的实例，通过这种方式能够保证退出应用时所有的Activity都能报销毁。在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么将创建一个新的Task，然后创建SingleTask Activity的实例，将其放入新的Task中</p><p>singleInstance： 呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。建议谨慎使用</p></li><li><p>Android中main方法入口在哪里<br>ActivityThread里面，有一个main函数</p></li><li><p>activity的startActivity和context的startActivity区别<br>最终调用的都是 Activity 类实现的 startActivity 方法<br>activity的startActivity是直接调用的Activity的startActivity<br>context的startActivity是Context的抽象方法，而Context的一个子类ContextWrapper简单实现了这个方法，但是需要实例化，接着是ContextWrapper的一个子类ContextThemeWrapper并没有实现这个方法，而Activity是继承ContextThemeWrapper的，所以自然而然startActivity方法最终回到了Activity中</p></li></ol><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Activity的启动过程（API27 源码分析）</title>
      <link href="/2020/02/07/Android%20Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88API27%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%89/"/>
      <url>/2020/02/07/Android%20Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88API27%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Activity的启动过程（API27-源码分析）"><a href="#Activity的启动过程（API27-源码分析）" class="headerlink" title="Activity的启动过程（API27 源码分析）"></a>Activity的启动过程（API27 源码分析）</h1><h2 id="正常启动"><a href="#正常启动" class="headerlink" title="正常启动"></a>正常启动</h2><p><a href="http://naotu.baidu.com/file/a824b4941efefafb032f507b78b9feaf?token=0b7f9970bfba3410" target="_blank" rel="noopener">Activity启动过程源码分析思维导图</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Instrumentation：每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。 Instrumentation这个类里面的方法大多数和Application和Activity有关，<strong>这个类就是完成对Application和Activity初始化和生命周期的工具类。</strong>可以说它就是Activity生命周期的一个大管家</li><li>ActivityManagerService：简称AMS，不仅负责系统中所有Activity的生命周期，还负责其他几个组件的管理，可以说这个服务贯穿了四大组件</li><li>ActivityStarter：Activity启动的intent和flag等的控制和解释</li><li>ActivityStarterSupervisor：ActivityStackSupervisor是ActivityStack的总管。4.4中默认引入了两个ActivityStack，一个叫Home stack，放Launcher和systemui，id为0；另一个是Applicationstack，放App的Activity，id可能是任意值</li><li>ActivityStack：Activity堆栈，其中的ActivityRecord是通过TaskRecord这一层间接地被管理着</li><li>ActivityThread：依赖于UI线程，这个app启动的最开始的地方，在这里你可以找到熟悉的<strong>main()</strong>方法，Application也是在这里创建和初始化的，并且主活动的启动也是在这里的，包括主线程Handler</li><li>ApplicationThread：ActivityThread的一个内部类，你可以在这里找到四大组件的创建和初始化，它是和ActivityManagerService沟通的桥梁</li><li>Instrumentation：用来监控应用程序和系统的交互</li></ul><h3 id="startActivity正常启动分析"><a href="#startActivity正常启动分析" class="headerlink" title="startActivity正常启动分析"></a>startActivity正常启动分析</h3><p>通过startActivity(intent)来启动活动，跟进源码看一下</p><p>首先Activity类里面重载了多个startActivity()方法，参数不同而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//options是启动活动需要添加的附加条件，一般为null</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管options是不是null，判断过后都会调用到Activity类中的<code>startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mParent是ActivityGroup，用来嵌套多个子Activity，现已弃用，所以一般为null</span></span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断、转移启动活动的选项</span></span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        <span class="comment">//调用了Instrumentation中的execStartActivity</span></span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当ActivityResult不为null的时候，通过mMainThread发送</span></span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//有ActivityGroup的情况，暂不分析</span></span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取Instrumentation.ActivityResult的实例时，调用了Instrumentation中的execStartActivity，先看传入的参数有this（上下文），mMainThread.getApplicationThread()（mMainThread是一个ActivityThread，调用此方法获取了ApplicationThread，ApplicationThread是ActivityThread的一个内部类），mToken（IBinder，用于跨进程通信），this（目标活动），intent，requestCode（前面传入的，没有传入的时候是-1），options（前面传入的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当活动监视器不为null的一些配置</span></span><br><span class="line">    <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">//获取启动Activity的结果</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        <span class="comment">//检查启动Activity的结果</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，通过ActivityManager.getService().startActivity来获取启动Activity的结果。那么Activity启动的真正实现就在这里了。先是通过ActivityManager这个管理类来获取Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单例模式获取IActivityManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取IBinder型service</span></span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                <span class="comment">//通过IActivityManager.Stub绑定service</span></span><br><span class="line">                <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                <span class="keyword">return</span> am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>可以看到，ActivityManager中的getService通过单例模式来获取了IActivityManager的实例am，这个am拥有着从ServiceManager那里获取的Service。这个am其实就是ActivityManagerService（简称AMS），因为AMS继承了IActivityManager.Stub这个内部类，所以最后Activity的启动过程实际到了AMS中了，所以startActivity是AMS中的方法了</p><p>在看AMS之前先简单看一下checkStartActivityResult方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkStartActivityResult</span><span class="params">(<span class="keyword">int</span> res, Object intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ActivityManager.isStartResultFatalError(res)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_INTENT_NOT_RESOLVED:</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">            <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//这个就是当待启动的Activity没有在AndroidManifest中注册就会抛出的异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                        <span class="string">"Unable to find explicit activity class "</span></span><br><span class="line">                        + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                        + <span class="string">"; have you declared this activity in your AndroidManifest.xml?"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                    <span class="string">"No Activity found to handle "</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_PERMISSION_DENIED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Not allowed to start activity "</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                    <span class="string">"FORWARD_RESULT_FLAG used while also requesting a result"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_ACTIVITY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"PendingIntent is not an activity"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_VOICE_COMPATIBLE:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Starting under voice control not allowed for: "</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Session calling startVoiceActivity does not match active session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_HIDDEN_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot start voice activity on a hidden session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Session calling startAssistantActivity does not match active session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_ASSISTANT_HIDDEN_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot start assistant activity on a hidden session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CANCELED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Activity could not be started for "</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Unknown error code "</span></span><br><span class="line">                    + res + <span class="string">" when starting "</span> + intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到确实是对于启动Activity结果的检查，抛出了这么多异常<br>还是回到我们之前的AMS的startActivity方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mActivityStarter是一个控制Activity怎样启动的管理类，此处调用ActivityStarter的startActivityMayWait</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">            resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="string">"startActivityAsUser"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用AMS类里面的startActivityAsUser，接着mActivityStarter.startActivityMayWait，而mActivityStarter是一个ActivityStarter的实例，所以又进入到ActivityStarter中的startActivityMayWait</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, WaitResult outResult,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration globalConfig, Bundle bOptions, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        TaskRecord inTask, String reason)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一些配置信息和检查</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//获取res值</span></span><br><span class="line">        <span class="keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">                resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                options, ignoreTargetSecurity, componentSpecified, outRecord, inTask,</span><br><span class="line">                reason);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回的是res，而res是调用ActivityStarter本类中的startActivityLocked方法得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity, TaskRecord inTask, String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用startActivity获取ActivityResult</span></span><br><span class="line">    mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">            aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">            callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">            options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">            inTask);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> mLastStartActivityResult != START_ABORTED ? mLastStartActivityResult : START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据mLastStartActivityResult进行返回，而mLastStartActivityResult是通过startActivity得到，所以接着看ActivityStarter本类中的startActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//返回的是startActivity的返回值</span></span><br><span class="line">    <span class="keyword">return</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, <span class="keyword">true</span>,</span><br><span class="line">            options, inTask, outActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着又调用ActivityStarter本类中的startActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">        <span class="comment">//要返回的result，通过startActivityUnchecked</span></span><br><span class="line">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId,  mSourceRecord,</span><br><span class="line">            mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用的是ActivityStarter本类中的startActivityUnchecked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化ActivityStarter的成员变量，包括了四种启动模式和启动flags</span></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor);</span><br><span class="line">    <span class="comment">//计算启动的flags，包括启动模式</span></span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line">    <span class="comment">//计算原栈</span></span><br><span class="line">    computeSourceStack();</span><br><span class="line">    <span class="comment">//设置flag</span></span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> preferredLaunchStackId =</span><br><span class="line">            (mOptions != <span class="keyword">null</span>) ? mOptions.getLaunchStackId() : INVALID_STACK_ID;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> preferredLaunchDisplayId =</span><br><span class="line">            (mOptions != <span class="keyword">null</span>) ? mOptions.getLaunchDisplayId() : DEFAULT_DISPLAY;</span><br><span class="line">    <span class="comment">//此处就开始判断启动的模式了</span></span><br><span class="line">    <span class="keyword">if</span> (reusedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused but</span></span><br><span class="line">        <span class="comment">// still needs to be a lock task mode violation since the task gets cleared out and</span></span><br><span class="line">        <span class="comment">// the device would otherwise leave the locked task.</span></span><br><span class="line">        <span class="keyword">if</span> (mSupervisor.isLockTaskModeViolation(reusedActivity.getTask(),</span><br><span class="line">                (mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">                        == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123;</span><br><span class="line">            mSupervisor.showLockTaskToast();</span><br><span class="line">            Slog.e(TAG, <span class="string">"startActivityUnchecked: Attempt to violate Lock Task Mode"</span>);</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mStartActivity.getTask() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mStartActivity.setTask(reusedActivity.getTask());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (reusedActivity.getTask().intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This task was started because of movement of the activity based on affinity...</span></span><br><span class="line">            <span class="comment">// Now that we are actually launching it, we can assign the base intent.</span></span><br><span class="line">            reusedActivity.getTask().setIntent(mStartActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This code path leads to delivering a new intent, we want to make sure we schedule it</span></span><br><span class="line">        <span class="comment">// as the first operation, in case the activity will be resumed as a result of later</span></span><br><span class="line">        <span class="comment">// operations.</span></span><br><span class="line">        <span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span></span><br><span class="line">                || isDocumentLaunchesIntoExisting(mLaunchFlags)</span><br><span class="line">                || mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskRecord task = reusedActivity.getTask();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In this situation we want to remove all activities from the task up to the one</span></span><br><span class="line">            <span class="comment">// being started. In most cases this means we are resetting the task to its initial</span></span><br><span class="line">            <span class="comment">// state.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity,</span><br><span class="line">                    mLaunchFlags);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The above code can remove &#123;@code reusedActivity&#125; from the task, leading to the</span></span><br><span class="line">            <span class="comment">// the &#123;@code ActivityRecord&#125; removing its reference to the &#123;@code TaskRecord&#125;. The</span></span><br><span class="line">            <span class="comment">// task reference is needed in the call below to</span></span><br><span class="line">            <span class="comment">// &#123;@link setTargetStackAndMoveToFrontIfNeeded&#125;.</span></span><br><span class="line">            <span class="keyword">if</span> (reusedActivity.getTask() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                reusedActivity.setTask(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (top.frontOfTask) &#123;</span><br><span class="line">                    <span class="comment">// Activity aliases may mean we use different intents for the top activity,</span></span><br><span class="line">                    <span class="comment">// so make sure the task now has the identity of the new intent.</span></span><br><span class="line">                    top.getTask().setIntent(mStartActivity);</span><br><span class="line">                &#125;</span><br><span class="line">                deliverNewIntent(top);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendPowerHintForLaunchStartIfNeeded(<span class="keyword">false</span> <span class="comment">/* forceSend */</span>, reusedActivity);</span><br><span class="line"></span><br><span class="line">        reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord outResult =</span><br><span class="line">                outActivity != <span class="keyword">null</span> &amp;&amp; outActivity.length &gt; <span class="number">0</span> ? outActivity[<span class="number">0</span>] : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When there is a reused activity and the current result is a trampoline activity,</span></span><br><span class="line">        <span class="comment">// set the reused activity as the result.</span></span><br><span class="line">        <span class="keyword">if</span> (outResult != <span class="keyword">null</span> &amp;&amp; (outResult.finishing || outResult.noDisplay)) &#123;</span><br><span class="line">            outActivity[<span class="number">0</span>] = reusedActivity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We don't need to start a new activity, and the client said not to do anything</span></span><br><span class="line">            <span class="comment">// if that is the case, so this is it!  And for paranoia, make sure we have</span></span><br><span class="line">            <span class="comment">// correctly resumed the top activity.</span></span><br><span class="line">            resumeTargetStackIfNeeded();</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">        &#125;</span><br><span class="line">        setTaskFromIntentActivity(reusedActivity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mAddingToTask &amp;&amp; mReuseTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We didn't do anything...  but it was needed (a.k.a., client don't use that</span></span><br><span class="line">            <span class="comment">// intent!)  And for paranoia, make sure we have correctly resumed the top activity.</span></span><br><span class="line">            resumeTargetStackIfNeeded();</span><br><span class="line">            <span class="keyword">if</span> (outActivity != <span class="keyword">null</span> &amp;&amp; outActivity.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                outActivity[<span class="number">0</span>] = reusedActivity;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> START_TASK_TO_FRONT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//判断栈顶的同一个活动，检查是否需要只启动一次</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack topStack = mSupervisor.mFocusedStack;</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord topFocused = topStack.topActivity();</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dontStart = top != <span class="keyword">null</span> &amp;&amp; mStartActivity.resultTo == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class="line">            &amp;&amp; top.userId == mStartActivity.userId</span><br><span class="line">            &amp;&amp; top.app != <span class="keyword">null</span> &amp;&amp; top.app.thread != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">            || mLaunchSingleTop || mLaunchSingleTask);</span><br><span class="line">    <span class="keyword">if</span> (dontStart) &#123;</span><br><span class="line">        <span class="comment">//resume栈顶的活动</span></span><br><span class="line">        <span class="comment">// For paranoia, make sure we have correctly resumed the top activity.</span></span><br><span class="line">        topStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            <span class="comment">//做resume的事情，而不是新建一个活动</span></span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(mOptions);</span><br><span class="line">        <span class="keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We don't need to start a new activity, and the client said not to do</span></span><br><span class="line">            <span class="comment">// anything if that is the case, so this is it!</span></span><br><span class="line">            <span class="keyword">return</span> START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deliverNewIntent(top);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't use mStartActivity.task to show the toast. We're not starting a new activity</span></span><br><span class="line">        <span class="comment">// but reusing 'top'. Fields in mStartActivity may not be fully initialized.</span></span><br><span class="line">        mSupervisor.handleNonResizableTaskIfNeeded(top.getTask(), preferredLaunchStackId,</span><br><span class="line">                preferredLaunchDisplayId, topStack.mStackId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> START_DELIVERED_TO_TOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="keyword">null</span>)</span><br><span class="line">            ? mSourceRecord.getTask() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否新建一个任务栈</span></span><br><span class="line">    <span class="keyword">int</span> result = START_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.resultTo == <span class="keyword">null</span> &amp;&amp; mInTask == <span class="keyword">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        newTask = <span class="keyword">true</span>;</span><br><span class="line">        result = setTaskFromReuseOrCreateNewTask(</span><br><span class="line">                taskToAffiliate, preferredLaunchStackId, topStack);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = setTaskFromSourceRecord();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = setTaskFromInTask();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This not being started from an existing activity, and not part of a new task...</span></span><br><span class="line">        <span class="comment">// just put it in the top task, though these days this case should never happen.</span></span><br><span class="line">        setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//mDoResume是在方法开始时初始化，doResume的值又是在第一次startActivity中传递的true</span></span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            <span class="comment">//检查不能Resume时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//mSupervisor时ActivityStarterSupervisor的实例</span></span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有异常情况的话，这个方法的正确返回值会是START_SUCCESS，在此之前，mDoResume为true，mSupervisor.resumeFocusedStackTopActivityLocked执行，所以启动活动的任务又到了ActivityStarterSupervisor中，接着看ActivityStarterSupervisor的resumeFocusedStackTopActivityLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//重点在这里</span></span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resumeFocusedStackTopActivityLocked中经过判断后，又调用了ActivityStack中的resumeTopActivityUncheckedLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Protect against recursion.</span></span><br><span class="line">            mStackSupervisor.inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//这里是重点</span></span><br><span class="line">            result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接着又调用了ActivityStack本类中的resumeTopActivityInnerLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">        <span class="comment">//如果活动没有被启动过</span></span><br><span class="line">        <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">            next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Restarting: "</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Restarting "</span> + next);</span><br><span class="line">        <span class="comment">//这是重点</span></span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用了ActivityStarterSupervisor的startSpecificActivityLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    r.getStack().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//这是重点</span></span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当启动活动的Application不为null，接着调用了ActivityStarterSupervisors本类的realStartActivityLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//此处重点</span></span><br><span class="line">            app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">                    <span class="comment">// and override configs.</span></span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                    r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                    mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.launchFailed) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            r.launchFailed = <span class="keyword">true</span>;</span><br><span class="line">            app.activities.remove(r);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        endDeferResume();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，重点是app.thread.scheduleLaunchActivity，安排启动活动。而app.thread是IApplicationThread，而IApplicationThread的实现类其实就是ActivityThread的内部类ApplicationThread，接着看ApplicationThread的scheduleLaunchActivity方法</p><h3 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h3><p>ApplicationThread的scheduleLaunchActivity方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">    <span class="comment">//中间是一些设置</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//好吧，这里是重点</span></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过sendMessage来发送消息，连续两次的方法重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">        TAG, <span class="string">"SCHEDULE "</span> + what + <span class="string">" "</span> + mH.codeToString(what)</span><br><span class="line">        + <span class="string">": "</span> + arg1 + <span class="string">" / "</span> + obj);</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是重点，mH是H的实例，H就是一个Hanlder的子类</span></span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mH是H的实例，而H是继承于Hanlder的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后调用了mH的sendMessage方法将一个Message对象添加到消息队列。由于是Handler，那么最终也应该mH的handleMessage方法处理消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="comment">//第一个就是启动Activity</span></span><br><span class="line">        <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">            <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> PAUSE_ACTIVITY: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> STOP_ACTIVITY_SHOW: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> RESUME_ACTIVITY:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> DESTROY_ACTIVITY:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    Object obj = msg.obj;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> SomeArgs) &#123;</span><br><span class="line">        ((SomeArgs) obj).recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&lt;&lt;&lt; done: "</span> + codeToString(msg.what));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用ApplicationThread的handleLaunchActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">            ...</span><br><span class="line">            performPauseActivityIfNeeded(r, reason);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">                r.state = oldState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过performLaunchActivity来获取Activity对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");</span></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取一个Context</span></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取类加载器</span></span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        <span class="comment">//通过mInstrumentation，Instrumentation中的newActivity方法是通过反射来获取一个实例的</span></span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取Application</span></span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取标题</span></span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Launching activity "</span></span><br><span class="line">                    + r.activityInfo.name + <span class="string">" with config "</span> + config);</span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                <span class="comment">//获取window</span></span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            <span class="comment">//配置信息</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//获取theme</span></span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                <span class="comment">//开始调用onCreate方法，最后回调成重写的onCreate方法</span></span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//开始调用onCreate方法</span></span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                <span class="comment">//最终回调到Activity中的onStart</span></span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//最后会回调成onRestoreInstanceState方法，对你没猜错</span></span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//最后会回调成onRestoreInstanceState方法，对你没猜错</span></span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    <span class="comment">//最后会回调成onPostCreate方法</span></span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                        <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                        <span class="string">" did not call through to super.onPostCreate()"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行了一些Activity必须的一些配置，然后都会调用mInstrumentation.callActivityOnCreate方法，即Instrumentation中的callActivityOnCreate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle,</span></span></span><br><span class="line"><span class="function"><span class="params">        PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    <span class="comment">//这是重点</span></span><br><span class="line">    activity.performCreate(icicle, persistentState);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着又调用了Activity的performCreate方法，这时就开始回到最初的Activity中了，在Activity中，不管performCreate重载了几种，最后都会调用performCreate有两个参数的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    mCanEnterPictureInPicture = <span class="keyword">true</span>;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这是重点，onCreate出现了</span></span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这是重点，onCreate出现了</span></span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, <span class="keyword">false</span>);</span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="keyword">this</span>, getActivityOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，源码中都会调用Activity中的onCreate方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="string">"onCreate "</span> + <span class="keyword">this</span> + <span class="string">": "</span> + savedInstanceState);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，这就是你在Activity中重写的方法onCreate</p><hr><h2 id="APP启动过程（从点击桌面开始）"><a href="#APP启动过程（从点击桌面开始）" class="headerlink" title="APP启动过程（从点击桌面开始）"></a>APP启动过程（从点击桌面开始）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>我们知道从桌面上点击一个应用图标时，就会启动到对应的应用中，并且启动的应用首先展示的Activity就是我们每个apk里面在AndroidManifest中注册的主活动。</p><p>在我们分析从桌面点击启动APP之前先了解一些概念：</p><ul><li>Launcher：其实我们常说的桌面本身就是一个APP，一般手机上默认的桌面就是一个系统级的APP；这个桌面就是我们需要了解的Lancher应用程序，它会展示所有的当前系统安装了的应用程序和其相关的信息（具体了解Launcher请移步[Android 系统启动流程](<a href="http://blog.penghesheng.cn/2019/04/25/Android" target="_blank" rel="noopener">http://blog.penghesheng.cn/2019/04/25/Android</a> Activity启动过程/)）</li><li>Launcher进程：Launcher所在的进程</li><li>APP进程：启动的APP所在的进程，我们知道每一个APP都是独立运行在一个Android虚拟机中的，也是在一个独立的进程中</li><li>zygote：这也是一个进程，译为<em>受精卵</em>，Android是基于Linux系统的，而在Linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote进程也不例外。在Android系统里，开启新进程的方式都是通过fork第一个Zygote进程来实现的。所以Dalvik虚拟机、应用程序进程以及SystemServer都是Zygote的子进程</li><li>SystemServer：运行系统的关键服务的一个进程，它和Zygote是Android系统FragmeWork两个非常重要的进程；SystemServer中开启了很多重要的服务，如ActivityManagerService、PackageManagerService、WindowManagerService等</li><li>ActivityManagerService：简称AMS，不仅负责系统中所有Activity的生命周期，还负责其他几个组件的管理，可以说这个服务贯穿了四大组件</li><li>APP进程：待启动应用程序所在的进程</li></ul><p>整个启动过程呢，大致就是下面的图咯（是后面的博文中的图呢）</p><p><a href="https://upload-images.jianshu.io/upload_images/3985563-b7edc7b70c9c332f.png?imageMogr2/auto-orient/strip|imageView2/2/w/960/format/webp" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/3985563-b7edc7b70c9c332f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" alt="app启动图"></a>app启动图</p><h3 id="桌面点击过程"><a href="#桌面点击过程" class="headerlink" title="桌面点击过程"></a>桌面点击过程</h3><p>从前面我们了解到了，从桌面点击一个应用图标，其实就是去启动一个Activity，又由于Launcher本身就是一个应用程序，我们启动的又是一个应用程序，所以这将是一个跨进程的启动Activity，同时这将是一个普通的APP进程从无到有的过程；那么接下来我们就分析这个过程</p><h3 id="Launcher启动Activity"><a href="#Launcher启动Activity" class="headerlink" title="Launcher启动Activity"></a>Launcher启动Activity</h3><p>Launcher的源码在系统源码的packages/apps/Launcher3下（PS：虽然现在有Launcher、Launcher2、Launcher3三个Launcher，但是都不影响代码分析，这里主要以Launcher3来看源码）</p><p>首先看看Launcher的定义吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default launcher application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> <span class="keyword">extends</span> <span class="title">BaseDraggingActivity</span> <span class="keyword">implements</span> <span class="title">LauncherExterns</span>,</span></span><br><span class="line"><span class="class">        <span class="title">LauncherModel</span>.<span class="title">Callbacks</span>, <span class="title">LauncherProviderChangeListener</span>, <span class="title">UserEventDelegate</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Launcher是通过继承这个BaseDraggingActivity的，通过名字就知道这是个能够拖放的BaseActivity。通过查看它的源码，也的确是这样，BaseDraggingActivity是继承自BaseActivity的，然后在BaseActivity的基础上扩展了一些功能，最主要的就是拖放了。好了，这些都不是我们的重点了，我们着重关注Launcher的点击事件。在Launcher中无法找到点击应用图标响应点击事件的处理，在<code>createShortcut()</code>方法中我们能知道，在Launcher添加这些应用图标的时候都设置了ClickListener，而这个Listener是<code>ItemClickHandler.INSTANCE</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> <span class="keyword">extends</span> <span class="title">BaseDraggingActivity</span> <span class="keyword">implements</span> <span class="title">LauncherExterns</span>,</span></span><br><span class="line"><span class="class">        <span class="title">LauncherModel</span>.<span class="title">Callbacks</span>, <span class="title">LauncherProviderChangeListener</span>, <span class="title">UserEventDelegate</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//这里就是创建桌面上显示的View</span></span><br><span class="line"><span class="function">View <span class="title">createShortcut</span><span class="params">(ShortcutInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createShortcut((ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">createShortcut</span><span class="params">(ViewGroup parent, ShortcutInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加载对应的app icon，设置响应的参数 如监听事件</span></span><br><span class="line">        BubbleTextView favorite = (BubbleTextView) LayoutInflater.from(parent.getContext())</span><br><span class="line">                .inflate(R.layout.app_icon, parent, <span class="keyword">false</span>);</span><br><span class="line">        favorite.applyFromShortcutInfo(info);</span><br><span class="line">        favorite.setOnClickListener(ItemClickHandler.INSTANCE);</span><br><span class="line">        favorite.setOnFocusChangeListener(mFocusHandler);</span><br><span class="line">        <span class="keyword">return</span> favorite;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们直接看整个<code>ItemClickHandler.INSTANCE</code>是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemClickHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instance used for click handling on items</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OnClickListener INSTANCE = ItemClickHandler::onClick;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure that rogue clicks don't get through while allapps is launching, or after the</span></span><br><span class="line">        <span class="comment">// view has detached (it's possible for this to happen if the view is removed mid touch).</span></span><br><span class="line">        <span class="keyword">if</span> (v.getWindowToken() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//获取Launcher 这个方法是Launcher中的静态方法</span></span><br><span class="line">        Launcher launcher = Launcher.getLauncher(v.getContext());</span><br><span class="line">        <span class="keyword">if</span> (!launcher.getWorkspace().isFinishedSwitchingState()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object tag = v.getTag();</span><br><span class="line">        <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> ShortcutInfo) &#123;</span><br><span class="line">            onClickAppShortcut(v, (ShortcutInfo) tag, launcher);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> FolderInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v <span class="keyword">instanceof</span> FolderIcon) &#123;</span><br><span class="line">                onClickFolderIcon(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> AppInfo) &#123;</span><br><span class="line">            startAppShortcutOrInfoActivity(v, (AppInfo) tag, launcher);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> LauncherAppWidgetInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v <span class="keyword">instanceof</span> PendingAppWidgetHostView) &#123;</span><br><span class="line">                onClickPendingWidget((PendingAppWidgetHostView) v, launcher);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ItemClickHandler.INSTANCE</code>其实就是ItemClickHandler中的onClick方法，在Launcher中用了一个单例来获取，在onClick方法中会先做一个检查，确保当某个app正在卸载但是图标还没有移除的情况下，这时候的点击事件不能当作一个正常的点击事件。</p><p>接着会拿到Launcher的实例，通过点击的的View的tag来判定是ShortcutInfo、FolderInfo、AppInfo、LauncherAppWidgetInfo其中的某一个。</p><blockquote><p>ShortcutInfo代表的是一个可快捷式点击的图标，这也是Launcher在添加app图标的时候创建的时候设置的参数;</p><p>FolderInfo代表的是文件形式的图标，我们都知道在桌面上是可以将多个图标放在一个文件夹中的，这就是描述的这种情况；</p><p>AppInfo代表的是应用图标，表示app（没懂和ShortcutInfo的区别）</p><p>LauncherAppWidgetInfo代表的是桌面上的一些小控件</p></blockquote><p>不管是ShortcutInfo还是AppInfo，最后都会调用<code>startAppShortcutOrInfoActivity(View v, ItemInfo item, Launcher launcher)</code>方法，<code>onClickAppShortcut()</code>方法最终也会调用上面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemClickHandler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onClickAppShortcut</span><span class="params">(View v, ShortcutInfo shortcut, Launcher launcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shortcut.isDisabled()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for abandoned promise</span></span><br><span class="line">        <span class="keyword">if</span> ((v <span class="keyword">instanceof</span> BubbleTextView) &amp;&amp; shortcut.hasPromiseIconUi()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Start activities</span></span><br><span class="line">        startAppShortcutOrInfoActivity(v, shortcut, launcher);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看一下<code>startAppShortcutOrInfoActivity(View v, ItemInfo item, Launcher launcher)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemClickHandler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startAppShortcutOrInfoActivity</span><span class="params">(View v, ItemInfo item, Launcher launcher)</span> </span>&#123;</span><br><span class="line">        Intent intent;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> PromiseAppInfo) &#123;</span><br><span class="line">            PromiseAppInfo promiseAppInfo = (PromiseAppInfo) item;</span><br><span class="line">            intent = promiseAppInfo.getMarketIntent(launcher);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intent = item.getIntent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Input must have a valid intent"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> ShortcutInfo) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        launcher.startActivitySafely(v, intent, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看一下方法传进的参数，View就是点击事件产生的View，ItemInfo是Launcher中的所有Item，ShortcutInfo、AppInfo等都是继承自它的</p><p>方法中先检查是不是PromiseAppInfo类型，PromiseAppInfo是继承自AppInfo的，然后通过PromiseAppInfo的getMarketIntent方法来获取Intent，<code>getMarketIntent()</code>返回的是<code>new PackageManagerHelper(context).getMarketIntent(componentName.getPackageName())</code></p><p>如果是其他类型，比如ShortcutInfo，则直接获取intent</p><p>接着如果是ShortcutInfo还需要检查一下</p><p>最后通过<code>launcher.startActivitySafely(v, intent, item);</code>来启动Activity，launcher就是我们前面获取的Launcher实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v, Intent intent, ItemInfo item)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> success = <span class="keyword">super</span>.startActivitySafely(v, intent, item);</span><br><span class="line">       <span class="keyword">if</span> (success &amp;&amp; v <span class="keyword">instanceof</span> BubbleTextView) &#123;</span><br><span class="line">           BubbleTextView btv = (BubbleTextView) v;</span><br><span class="line">           btv.setStayPressed(<span class="keyword">true</span>);</span><br><span class="line">           setOnResumeCallback(btv);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Launcher中直接调用的是父类BaseDraggingActivity的startActivitySafely方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v, Intent intent, ItemInfo item)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       UserHandle user = item == <span class="keyword">null</span> ? <span class="keyword">null</span> : item.user;</span><br><span class="line">       <span class="comment">// Prepare intent</span></span><br><span class="line">       intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">       <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">           intent.setSourceBounds(getViewBounds(v));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> isShortcut = Utilities.ATLEAST_MARSHMALLOW</span><br><span class="line">                   &amp;&amp; (item <span class="keyword">instanceof</span> ShortcutInfo)</span><br><span class="line">                   &amp;&amp; (item.itemType == Favorites.ITEM_TYPE_SHORTCUT</span><br><span class="line">                   || item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT)</span><br><span class="line">                   &amp;&amp; !((ShortcutInfo) item).isPromise();</span><br><span class="line">           <span class="keyword">if</span> (isShortcut) &#123;</span><br><span class="line">               <span class="comment">// Shortcuts need some special checks due to legacy reasons.</span></span><br><span class="line">               startShortcutIntentSafely(intent, optsBundle, item);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.equals(Process.myUserHandle())) &#123;</span><br><span class="line">               <span class="comment">// Could be launching some bookkeeping activity</span></span><br><span class="line">               startActivity(intent, optsBundle);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               LauncherAppsCompat.getInstance(<span class="keyword">this</span>).startActivityForProfile(</span><br><span class="line">                       intent.getComponent(), user, intent.getSourceBounds(), optsBundle);</span><br><span class="line">           &#125;</span><br><span class="line">           getUserEventDispatcher().logAppLaunch(v, intent);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ActivityNotFoundException|SecurityException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先是一些检查，我们就不贴出来了。然后通过<code>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</code>来给intent设置FLAG，意味着我们要在一个新的活动栈里启动一个Activity</p><p>接着对是不是ShortcutInfo进行了一个判断，因为ShortcutInfo需要一些特殊的检查</p><p>接着是当item.user为null的时候，直接进行Activity的启动<code>startActivity(intent, optsBundle);</code></p><p>由于我们在Launcher中的是ShortcutInfo类型的，所以这里肯定执行的是内部的<code>startShortcutIntentSafely(intent, optsBundle, item);</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startShortcutIntentSafely</span><span class="params">(Intent intent, Bundle optsBundle, ItemInfo info)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">// Could be launching some bookkeeping activity</span></span><br><span class="line">       startActivity(intent, optsBundle);</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>重点就是留下来的这一行代码<code>startActivity(intent, optsBundle);</code>，这个方法是Activity类中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">           startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">           <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">           startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>根据有没有options来调用startActivityForResult方法，-1表示不需要Activity结束后的结果</p><p>到了这里，后面很多逻辑都和前面启动Activity一样了，所以后面就着重讲不一样的地方</p><p>从这里开始，一直到ActivityStarterSupervisor的startSpecificActivityLocked方法，我们从这里接着看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">       ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">               r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">       r.getStack().setLaunchTime(r);</span><br><span class="line">       <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ...</span><br><span class="line">               realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125; </span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">               <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>前面我们知道，正常启动Activity时，在这里判断application的时候是不为null的，所以正常启动Activity的时候后面会调用<code>realStartActivityLocked(r, app, andResume, checkConfig);</code>方法，并return</p><p>但是现在通过Launcher来启动一个应用，没有运行的application，所以<code>app == null</code>，所以这里就会执行到<code>mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true);</code>方法，mService就是AMS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">           ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">           String hostingType, ComponentName hostingName, <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">               hostingName, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>, keepIfLarge,</span><br><span class="line">               <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>,</span><br><span class="line">               <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在AMS中startProcessLocked方法调用了重载的startProcessLocked方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid, <span class="keyword">boolean</span> keepIfLarge,</span></span></span><br><span class="line"><span class="function"><span class="params">          String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">      ProcessRecord app;</span><br><span class="line">      <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">          app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">          ...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// If this is an isolated process, it can't re-use an existing process.</span></span><br><span class="line">          app = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">          checkTime(startTime, <span class="string">"startProcess: creating new process record"</span>);</span><br><span class="line">          app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">          ...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If the system is not ready yet, then hold off on starting this</span></span><br><span class="line">      <span class="comment">// process until it is.</span></span><br><span class="line">      ...</span><br><span class="line">      checkTime(startTime, <span class="string">"startProcess: stepping in to startProcess"</span>);</span><br><span class="line">      startProcessLocked(</span><br><span class="line">              app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">      checkTime(startTime, <span class="string">"startProcess: done starting proc!"</span>);</span><br><span class="line">      <span class="keyword">return</span> (app.pid != <span class="number">0</span>) ? app : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先根据前面传进来的isolated参数为false，所以必然执行的是<code>app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</code>，这行代码是根据processName去获取已经存在的进程；在Activity应用程序中的AndroidManifest.xml配置文件中，我们没有指定Application标签的process属性，系统就会默认使用package的名称（我们可以配置两个应用程序具有相同的uid和package，或者在AndroidManifest.xml配置文件的application标签或者activity标签中显式指定相同的process属性值，这样，不同的应用程序也可以在同一个进程中启动）；由于我们是Launcher启动的，所有会返回null</p><p>当<code>app == null</code>的时候，会调用<code>newProcessRecordLocked()</code>去创建一个进程</p><p>接着先看AMS中<code>newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">newProcessRecordLocked</span><span class="params">(ApplicationInfo info, String customProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid)</span> </span>&#123;</span><br><span class="line">       String proc = customProcess != <span class="keyword">null</span> ? customProcess : info.processName;</span><br><span class="line">       BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(info.uid);</span><br><span class="line">       <span class="keyword">int</span> uid = info.uid;</span><br><span class="line">       <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> ProcessRecord r = <span class="keyword">new</span> ProcessRecord(stats, info, proc, uid);</span><br><span class="line">       <span class="keyword">if</span> (!mBooted &amp;&amp; !mBooting</span><br><span class="line">               &amp;&amp; userId == UserHandle.USER_SYSTEM</span><br><span class="line">               &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">           r.persistent = <span class="keyword">true</span>;</span><br><span class="line">           r.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">       &#125;</span><br><span class="line">       addProcessNameLocked(r);</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由于isolated为false，所以不会执行if中的语句，接着就<code>new ProcessRecord(stats, info, proc, uid)</code>来创建新的应用程序的进程，然后返回</p><p>接着回到上一个方法AMS中的startProcessLocked，接着看到最后<code>startProcessLocked( app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs)</code>，这AMS中重载的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">           String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">       <span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line"> checkTime(startTime, <span class="string">"startProcess: starting to update cpu stats"</span>);</span><br><span class="line">       <span class="comment">//更新cpu</span></span><br><span class="line">       updateCpuStats();</span><br><span class="line">       checkTime(startTime, <span class="string">"startProcess: done updating cpu stats"</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(app.uid);</span><br><span class="line">               ...</span><br><span class="line">           &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> uid = app.uid;</span><br><span class="line">           <span class="keyword">int</span>[] gids = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">int</span> mountExternal = Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">           <span class="keyword">if</span> (!app.isolated) &#123;</span><br><span class="line">               <span class="keyword">int</span>[] permGids = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   checkTime(startTime, <span class="string">"startProcess: getting gids from package manager"</span>);</span><br><span class="line">                   ....</span><br><span class="line">               &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">               &#125;</span><br><span class="line">...</span><br><span class="line">           &#125;</span><br><span class="line">           checkTime(startTime, <span class="string">"startProcess: building args"</span>);</span><br><span class="line">...</span><br><span class="line">           <span class="comment">//这个标志在启动进程的时候很重要，这里暂就不分析了</span></span><br><span class="line">           <span class="keyword">int</span> debugFlags = <span class="number">0</span>;</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">boolean</span> isActivityProcess = (entryPoint == <span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//注意这里</span></span><br><span class="line">           <span class="keyword">if</span> (entryPoint == <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line">           Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Start proc: "</span> +</span><br><span class="line">                   app.processName);</span><br><span class="line">           checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line">           ProcessStartResult startResult;</span><br><span class="line">           <span class="keyword">if</span> (hostingType.equals(<span class="string">"webview_service"</span>)) &#123;</span><br><span class="line">               ...</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//启动进程</span></span><br><span class="line">               startResult = Process.start(entryPoint,</span><br><span class="line">                       app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                       app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                       app.info.dataDir, invokeWith, entryPointArgs);</span><br><span class="line">           &#125;</span><br><span class="line">           checkTime(startTime, <span class="string">"startProcess: returned from zygote!"</span>);</span><br><span class="line">           Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">           mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);</span><br><span class="line">           checkTime(startTime, <span class="string">"startProcess: done updating battery stats"</span>);</span><br><span class="line">...</span><br><span class="line">           checkTime(startTime, <span class="string">"startProcess: building log message"</span>);</span><br><span class="line">           ...</span><br><span class="line">           checkTime(startTime, <span class="string">"startProcess: starting to update pids map"</span>);</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">               <span class="comment">//存入mPidsSelfLocked这个进程集合里</span></span><br><span class="line">               <span class="keyword">this</span>.mPidsSelfLocked.put(startResult.pid, app);</span><br><span class="line">               <span class="keyword">if</span> (isActivityProcess) &#123;</span><br><span class="line">                   Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);</span><br><span class="line">                   msg.obj = app;</span><br><span class="line">                   mHandler.sendMessageDelayed(msg, startResult.usingWrapper</span><br><span class="line">                           ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           checkTime(startTime, <span class="string">"startProcess: done updating pids map"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法就很重要了，前面我们只是看到了进程的创建，启动进程就是在这个方法中了。这个方法比较长，我们一点一点看</p><p>会获取到userId，然后他通过PackageManager去获取gids，如果没有就会创建，然后配置相应的一些参数，最后保存到我们的app里面</p><p>重点看一下42行，<code>startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs);</code>，这里会通过Zogyte来启动我们的进程，那么entryPoint又是什么呢？看到33行，<code>if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</code>，从这里我们就知道，通过Zogyte启动的进程是什么了——启动了ActivityThread，因为我们所通过桌面点击启动的，所以会跨进程启动，然后到这里来启动对应的应用的进程</p><p>具体是怎样的，我们看一下Process的start方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start a new process.</span></span><br><span class="line"><span class="comment">    * ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                   debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                   abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过注释，我们就知道这个方法是用来启动新的进程</p><p>然后接着调用了zygoteProcess的start方法，zygoteProcess就是ZygoteProcess，名如其义</p><p>接着看看ZygoteProcess</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                   debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                   abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">       &#125; ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接着调用了<code>startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Starts a new process via the zygote mechanism.</span></span><br><span class="line"><span class="comment">    * ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                     <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line">       <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">           <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一系列的配置参数后，调用了<code>zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sends an argument list to the zygote process, which starts a new child</span></span><br><span class="line"><span class="comment">    * and returns the child's pid. Please note: the present implementation</span></span><br><span class="line"><span class="comment">    * replaces newlines in the argument list with spaces.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ZygoteStartFailedEx if process start failed for any reason</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">           <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line">           writer.write(Integer.toString(args.size()));</span><br><span class="line">           writer.newLine();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">               String arg = args.get(i);</span><br><span class="line">               writer.write(arg);</span><br><span class="line">               writer.newLine();</span><br><span class="line">           &#125;</span><br><span class="line">           writer.flush();</span><br><span class="line">           <span class="comment">// Should there be a timeout on this?</span></span><br><span class="line">           Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line">           <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">           <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">           <span class="comment">// upon.</span></span><br><span class="line">           result.pid = inputStream.readInt();</span><br><span class="line">           result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125; ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>到这里就是真正的孵化了一个Zygote进程了，并且启动了进程</p><p>好了，Zygote启动后，ActivityThread自然也就运行了，接着往后面看</p><h3 id="ActivityThread过程"><a href="#ActivityThread过程" class="headerlink" title="ActivityThread过程"></a>ActivityThread过程</h3><p>在java中main方法就是程序的入口了，同样，ActivityThread的main方法就是我们APP的入口了，也就是主活动启动之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line">    <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    <span class="comment">//这里会通知Zogyte进程告知ActivityThread现在已经启动了</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityThread是final的，也就是说一个APP对应一个ActivityThread，同时了创建了ActivityThread的实例。在main方法中，做了一些准备，如Looper和消息队列。实例化后，调用ActivityThread的attach方法将其实例对象绑定到AMS中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//看这里</span></span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用AMS的attachApplication将ActivityThread绑定到AMS中，接着看AMS中的attachApplication方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS的attachApplication接着调用了本类中的attachApplicationLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">//现在，可以根据pid在AMS中拿取到app了</span></span><br><span class="line">    <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            app = mPidsSelfLocked.get(pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (app.instr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                    app.instr.mClass,</span><br><span class="line">                    profilerInfo, app.instr.mArguments,</span><br><span class="line">                    app.instr.mWatcher,</span><br><span class="line">                    app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    <span class="keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                    getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将ApplicationThread绑定到AMS</span></span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, <span class="keyword">null</span>, profilerInfo,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    <span class="keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                    getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里是重点</span></span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread.bindApplication将ApplicationThread对象绑定到AMs，然后ApplicationThread里面会接着调用ActivityThread的sendMessage，最后通过ActivityThread类的H.sendMessage送到消息队列，然后通过H的handleMessage处理消息，最后就调用到ActivityThread的handleBindApplication完成整个ApplicationThread的绑定。</p><p>接着看AMS的attachApplicationLocked的后面，发现还通过mStackSupervisor调用了attachApplicationLocked，又到StackSupervisor中看看attachApplicationLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String processName = app.processName;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityRecord activity = mTmpActivityList.get(i);</span><br><span class="line">                <span class="keyword">if</span> (activity.app == <span class="keyword">null</span> &amp;&amp; app.uid == activity.info.applicationInfo.uid</span><br><span class="line">                        &amp;&amp; processName.equals(activity.processName)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//看这里咯</span></span><br><span class="line">                        <span class="keyword">if</span> (realStartActivityLocked(activity, app,</span><br><span class="line">                                top == activity <span class="comment">/* andResume */</span>, <span class="keyword">true</span> <span class="comment">/* checkConfig */</span>)) &#123;</span><br><span class="line">                            didSomething = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StackSupervisor中attachApplicationLocked方法的代码不是很多，仔细看看，看到了realStartActivityLocked，咦，这不是前面一个Activity正常启动时会调用的方法吗。没错，这里就开始进入到主活动的启动了，跟着进去看看本类的realStartActivityLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//通过各种检测，收集参数信息，最后在这里就开始准备启动Activity了</span></span><br><span class="line">            app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">                    <span class="comment">// and override configs.</span></span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                    r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                    mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        endDeferResume();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，这就是前面分析Activity启动时的部分源码，最后都是调用ApplicationThread来准备启动Activity，后面的调用就跟Activity的启动过程一样了，最后回调到Activity的onCreate，这样，主活动就启动成功了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="正常Activity的启动"><a href="#正常Activity的启动" class="headerlink" title="正常Activity的启动"></a>正常Activity的启动</h3><ol><li>Activity中重载的startActivity启动方法，最终调用到startActivityForResult方法</li><li>调用到Instrumentation中，会检查是否在AndroidManifest中注册，在Instrumentation中会通过单例获取AMS，调用到AMS中</li><li>在AMS中又会调用到ActivityStarter，经过一些列调用后，会计算Activity的启动模式，FLAG等信息以及是否在栈顶等，然后保存这些信息</li><li>然后又到ActivityStarterSupervisor中，通过ActivityStack判断Activity是否启动过，然后检查Application是否为null，不为null就会进行一个正常后面的启动；但是如果启动的Activity是跨进程的，会先去进行进程的一些孵化操作和启动进程的操作，而不会直接去启动活动</li><li>正常的流程接着会通过ApplicationThread来launch一个Activity</li><li>在ApplicationThread（ActivityThread的一个内部类）中会通过Handler的方式，发送启动Activity的消息；Handler是ActivityThread维持的主线程Handler，在接收到启动消息后，接着通过ApplicationThread进行后面的操作</li><li>在ApplicationThread中，通过获取类加载器，然后通过反射来获取了一个Activity实例；接着给这个Activity绑定Application、创建Window、添加DecorView等，接着会回调onCreate方法（先是调用Instrumentation中，最后回调到了Activity中）</li></ol><h3 id="桌面点击应用启动"><a href="#桌面点击应用启动" class="headerlink" title="桌面点击应用启动"></a>桌面点击应用启动</h3><ol><li>从桌面点击应用图标，从Launcher从开始处理这个点击事件，先是会判断当前点击的是一个可启动的应用还是一个文件夹或者是一个小部件，然后相应对应时间，启动应用按照正常的流程启动一个Activity（当然，首先是Launcher这个活动会进入onPause）</li><li>到了ActivityStarterSupervisor中，检查当前要启动的Activity是否跟当前的Activity是一个进程，不是然后就进行进程的孵化</li><li>在AMS中，进行一些列的检查，根据包名是否能够查到相应的进程、获取到相关的信息，最终判定需要新孵化一个进程，就会创建一个ProcessRecord来保存相关的信息</li><li>在AMS中startProcessLocked方法，进行新进程的一个启动，会通过Zygote来孵化一个新的Zygote自进程，然后启动新的ActivityThread主线程</li><li>接着就是要启动APP的ActivityThread在运行中了，在ActivityThread中有一个main方法，在这里会创建ActivityThread的实例，然后绑定Application到AMS中，，准备Handler和Looper等，也会通知之前的进程——当前进程启动了并且ActivityThread启动了</li><li>在将ActivityThread绑定到AMS中的同时，会去启动我们要启动APP的主活动，最后也是通过StackSupervisor中的realStartActivityLocked方法来启动这个MainActivity的，然后再后面的就和正常的启动一样了</li></ol><h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p>[Android开发艺术探索](<a href="http://blog.penghesheng.cn/2019/04/25/Android" target="_blank" rel="noopener">http://blog.penghesheng.cn/2019/04/25/Android</a> Activity启动过程/)</p><p><a href="https://www.jianshu.com/p/a72c5ccbd150" target="_blank" rel="noopener">一个APP从启动到主页面显示经历了哪些过程？</a></p><p><a href="https://juejin.im/entry/586105ff61ff4b006308096a" target="_blank" rel="noopener">Android 进程启动流程（App 启动）</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="noopener">Android应用程序启动过程源代码分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android WiFi Display</title>
      <link href="/2019/12/01/Android%20WiFi%20Display/"/>
      <url>/2019/12/01/Android%20WiFi%20Display/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Android-WiFi-Display-Miracast"><a href="#Android-WiFi-Display-Miracast" class="headerlink" title="Android WiFi Display (Miracast)"></a>Android WiFi Display (Miracast)</h1><p><strong>投屏技术协议</strong>：</p><blockquote><p>DLNA：Digital Living Network Alliance，PC、移动设备、消费电器之间互联互通的协议</p><p>AirPlay：苹果开发的无线技术，通过WiFi传输，支持DLNA没有的镜像（设备显示什么，显示屏幕也显示什么）</p><p>Miracast：以WiFi Direct为基础的无线显示标准</p></blockquote><p>DLNA</p><p>蓝牙：蓝牙发现</p><p>WiFi Direct：WiFi直连</p><p>Nsd：网络服务发现</p><h2 id="技术体系："><a href="#技术体系：" class="headerlink" title="技术体系："></a>技术体系：</h2><p><img src="../images/wifi_miracast_model.png" alt="image-20191108164621905"></p><ol><li>WiFi Direct：WiFi P2P，支持在没有AP（Access Point）下，WiFi设备直连并通信</li><li>WiFi Protected Setup：用于用户自动配置WiFi网络、添加WiFi设备</li><li>11n/WMM/WPA2：11n是802.11n协议（56M提升至600M）；WMM是WiFi Multimedia，针对实时视音频数据的QoS服务；WPA2是WiFi Protected Acess2，传输加密保护</li></ol><ul><li>WiFi Display相关Service：</li></ul><blockquote><p>MediaPlayerService及相关模块：RTP/RTSP及相应的编解码技术</p><p>SurfaceFlinger及相关模块：SurfaceFlinger是将各层UI数据混屏并投递到显示设备中去显示</p><p>WindowManagerService及相关模块：用于管理系统中各个UI层的位置和属性</p><p>DisplayManagerService：用于管理系统显示设备的生命周期，包括物理屏幕、虚拟屏幕、WiFi Display</p><p>WifiService及相关模块：WifiDisplay建立在P2P基础上</p><p>MediaRouterService：管理各个应用程序的多媒体播放的行为</p><p>MediaRouter：用于和MediaRouterService交互一起管理多媒体的播放行为，并维护当前已经配对上的remote display设备，包括WiFi Display、蓝牙A2DP、chromecast设备</p><p>WifiDisplayAdapter：用于DisplayManagerService管理WiFi Display显示的Adapter</p><p>WifiDisplayController：用于控制扫描wifi display设备、连接、断开等操作</p></blockquote><p>Android中关注：WiFi Direct（WifiP2pService管理和控制），WiFi Multimedia</p><p>Miracast工作流程：</p><p><img src="../images/wifi_display_process.png" alt="image-20191108165421163"></p><p><img src="../images/wifi_miracast_specification.png" alt="image-20191112110229164"></p><p><img src="https://img-my.csdn.net/us/201301/06/1357478758_9825.png" alt="img"></p><p><img src="../images/wifi_p2p_num.png" alt="image-20191112101244978"></p><p>SurfaceFlinger对Miracast的支持</p><p>Wifi P2P：<a href="https://blog.csdn.net/u011913612/article/details/52795464" target="_blank" rel="noopener">Android wifi探究三：Wifi P2P 连接附近设备</a></p><h2 id="流媒体协议"><a href="#流媒体协议" class="headerlink" title="流媒体协议"></a>流媒体协议</h2><ol><li><p>RTP：Real-time Transport Protocol，传送具有实时属性的数据，建立在UDP上，不保证传送或防止无序传送，允许接收方重组发送方的包序列（例子：视频解码，就不需要顺序解码）</p></li><li><p>RTCP：Real-time Transport Control Protocol，RTP的控制协议，监控服务质量并传送正在进行的会话参与者的相关信息；为RTP媒体流提供信道外控制</p></li><li><p>SRTCP：Secure Real-time Transport Protocol，在RTP基础上定义的一个协议，用于为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保护和重放保护</p></li><li><p>RTSP：Real-time Streaming Protocol，控制声音或影像的多媒体串流协议，并允许同时多个串流需求控制； 该协议目的在于控制多个数据发送连接，为选择发送通道，如UDP、多播UDP与TCP提供途径，并为选择基于RTP上发送机制提供方法 ；RTSP是双向实时数据传输协议，允许客户端向服务端发送请求（如回放、快进、倒退等）；（<strong>算是在应用层协议？？？？</strong>）</p></li><li><p>SDP：会话描述协议</p><p><strong>RTSP发起/终结流媒体、RTP传输流媒体数据 、RTCP对RTP进行控制，同步</strong> </p></li></ol><p><a href="https://www.zhihu.com/question/20278635" target="_blank" rel="noopener">RTP/RTSP/RTCP</a></p><h2 id="P2P使用demo"><a href="#P2P使用demo" class="headerlink" title="P2P使用demo"></a>P2P使用demo</h2><p><img src="../images/wifi_p2p_process_img.png" alt="image-20191115102040874"></p><h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><ul><li><p>权限申请和检查：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Wifi P2P 权限一定要有，不然获取不到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CHANGE_WIFI_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CHANGE_NETWORK_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.wifi.direct"</span> <span class="attr">android:required</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>  部分权限根据API需要动态申请，如WiFi的状态和打开、位置信息的获取</p></li><li><p>初始化P2P设备，注册广播监听器：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intentFilter = IntentFilter().apply &#123;</span><br><span class="line">    addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)</span><br><span class="line">        addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)</span><br><span class="line">        addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)</span><br><span class="line">        addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)</span><br><span class="line">&#125;</span><br><span class="line">registerReceiver(mReceiver, intentFilter)</span><br><span class="line">mWifiP2pManager = getSystemService(Context.WIFI_P2P_SERVICE) <span class="keyword">as</span> WifiP2pManager</span><br><span class="line"><span class="comment">// 用这个通道来查找和连接P2P设备 在 WLAN P2P 框架中注册您的应用</span></span><br><span class="line">mChannel = mWifiP2pManager?.initialize(<span class="keyword">this</span>, mainLooper) &#123; Log.d(localClassName, <span class="string">"channel disconnected"</span>) &#125;</span><br><span class="line"><span class="comment">// 查找附近P2P设备</span></span><br><span class="line">mWifiP2pManager?.discoverPeers(mChannel, <span class="keyword">object</span> : WifiP2pManager.ActionListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(localClassName, <span class="string">"discoverPeers onSuccess"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(reason: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.w(localClassName, <span class="string">"discoverPeers onFailure:<span class="variable">$reason</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>广播接收：</p><ul><li><p>保证P2P打开：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -&gt; &#123;</span><br><span class="line">    <span class="keyword">when</span> (intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -<span class="number">1</span>)) &#123;</span><br><span class="line">        WifiP2pManager.WIFI_P2P_STATE_ENABLED -&gt; &#123;</span><br><span class="line">            <span class="comment">// Wifi P2P is enabled</span></span><br><span class="line">            Log.d(localClassName, <span class="string">"P2P is enabled"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// Wi-Fi P2P is not enabled</span></span><br><span class="line">            Log.d(localClassName, <span class="string">"P2P is not enabled"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 得到附近所有的支持P2P的设备peers：    <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -&gt; &#123;</span><br><span class="line">    Log.d(localClassName, <span class="string">"可用的peer list发生改变"</span>)</span><br><span class="line">    mWifiP2pManager?.requestPeers(mChannel) &#123; peers -&gt; availablePeers(peers) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">availablePeers</span><span class="params">(peers: <span class="type">WifiP2pDeviceList</span>?)</span></span> &#123;</span><br><span class="line">    Log.d(localClassName, <span class="string">"size:<span class="subst">$&#123;peers?.deviceList?.size&#125;</span>"</span>)</span><br><span class="line">    mAdapter.clear()</span><br><span class="line">    peers?.deviceList?.forEach &#123; wifiP2pDevice -&gt;</span><br><span class="line"><span class="keyword">val</span> name = wifiP2pDevice.deviceName</span><br><span class="line"><span class="keyword">val</span> address = wifiP2pDevice.deviceAddress</span><br><span class="line"><span class="keyword">val</span> status = <span class="keyword">when</span>(wifiP2pDevice.status) &#123;</span><br><span class="line">WifiP2pDevice.CONNECTED -&gt; <span class="string">"connected"</span></span><br><span class="line">WifiP2pDevice.INVITED -&gt; <span class="string">"invited"</span></span><br><span class="line">WifiP2pDevice.FAILED -&gt; <span class="string">"failed"</span></span><br><span class="line">WifiP2pDevice.AVAILABLE -&gt; <span class="string">"available"</span></span><br><span class="line">WifiP2pDevice.UNAVAILABLE -&gt; <span class="string">"unavailable"</span></span><br><span class="line"><span class="keyword">else</span> -&gt; <span class="string">"unknown"</span></span><br><span class="line">&#125;</span><br><span class="line">mAdapter.add(<span class="string">"<span class="variable">$name</span> : <span class="variable">$status</span>\n<span class="variable">$address</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">    mAdapter.notifyDataSetChanged()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 选择连接：    <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = mAdapter.getItem(position)</span><br><span class="line"><span class="keyword">val</span> strs = str?.split(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">val</span> address = strs?.<span class="keyword">get</span>(<span class="number">1</span>)</span><br><span class="line">Log.d(localClassName, <span class="string">"item click: <span class="variable">$str</span> address: <span class="variable">$address</span>"</span>)</span><br><span class="line"><span class="comment">// val wifiP2pDevice = mPeers?.get(address)</span></span><br><span class="line"><span class="keyword">val</span> config = WifiP2pConfig()</span><br><span class="line">config.deviceAddress = address</span><br><span class="line">config.wps.setup = WpsInfo.PBC</span><br><span class="line">mWifiP2pManager?.connect(mChannel, config, <span class="keyword">object</span> : WifiP2pManager.ActionListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(localClassName, <span class="string">"connect onSuccess"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(reason: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.w(localClassName, <span class="string">"connect onFailure:<span class="variable">$reason</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>- 连接成功后，获取连接的WifiP2pInfo：    <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -&gt; &#123;</span><br><span class="line">    Log.d(localClassName, <span class="string">"P2P连接状态发生改变"</span>)</span><br><span class="line">    <span class="comment">// 可以直接通过intent拿到WifiP2pGroup WifiP2pInfo</span></span><br><span class="line">    <span class="comment">// val group = intent.getParcelableExtra&lt;WifiP2pGroup&gt;(WifiP2pManager.EXTRA_WIFI_P2P_GROUP)</span></span><br><span class="line">    <span class="comment">// 也可以通过request去获取</span></span><br><span class="line">    <span class="comment">// mWifiP2pManager.requestNetworkInfo(mChannel) &#123; networkInfo -&gt;</span></span><br><span class="line">    <span class="comment">//     Log.d(localClassName, "networkInfo:$networkInfo")</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">val</span> networkInfo = intent.getParcelableExtra&lt;NetworkInfo&gt;(WifiP2pManager.EXTRA_NETWORK_INFO)</span><br><span class="line">    networkInfo?.takeIf &#123; it.isConnected &#125;?.let &#123;</span><br><span class="line">        mWifiP2pManager?.requestGroupInfo(mChannel) &#123; wifiP2pGroup -&gt;</span><br><span class="line"><span class="keyword">val</span> wifiP2pDevices = wifiP2pGroup.clientList</span><br><span class="line">            <span class="keyword">val</span> wifiP2p2DeviceOwner = wifiP2pGroup.owner</span><br><span class="line">            Log.d(localClassName, <span class="string">"group p2pInfo:<span class="variable">$wifiP2pGroup</span>"</span>)</span><br><span class="line">            tv_client_connected.post &#123; tv_client_connected.text = wifiP2pGroup.networkName &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mWifiP2pManager?.requestConnectionInfo(mChannel) &#123; wifiP2pInfo: WifiP2pInfo? -&gt;</span><br><span class="line">            mWifiP2pInfo = wifiP2pInfo</span><br><span class="line">            Log.d(localClassName, <span class="string">"wifi p2pInfo <span class="variable">$mWifiP2pInfo</span>"</span>)</span><br><span class="line">            mWifiP2pInfo?.let &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.groupFormed &amp;&amp; it.isGroupOwner) &#123;</span><br><span class="line">                   Toast.makeText(<span class="keyword">this</span><span class="symbol">@WifiP2PClientActivity</span>, <span class="string">"can be connected"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it.groupFormed) &#123;</span><br><span class="line">                   Log.d(localClassName, <span class="string">"The other device acts as the client. In this case, we enable the get file button"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 获取IP，创建Socket进行连接Server端：    <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fileUri = extras?.getString(EXTRAS_FILE_PATH)</span><br><span class="line"><span class="keyword">val</span> host = extras?.getString(EXTRAS_GROUP_OWNER_ADDRESS)</span><br><span class="line"><span class="keyword">val</span> port = extras?.getInt(EXTRAS_GROUP_OWNER_PORT)</span><br><span class="line"><span class="keyword">if</span> (fileUri == <span class="literal">null</span> || host == <span class="literal">null</span> || port == <span class="literal">null</span>) &#123;</span><br><span class="line">    Log.e(javaClass.name, <span class="string">"fileUri: <span class="variable">$fileUri</span>, host: <span class="variable">$host</span>, port: <span class="variable">$port</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> socket = Socket()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Log.d(javaClass.name, <span class="string">"opening client socket"</span>)</span><br><span class="line">    socket.bind(<span class="literal">null</span>)</span><br><span class="line">    socket.connect(InetSocketAddress(host, port), SOCKET_TIME_OUT)</span><br><span class="line">    Log.d(javaClass.name, <span class="string">"client socket:<span class="subst">$&#123;socket.isConnected&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span> outputStream = socket.getOutputStream()</span><br><span class="line">    <span class="keyword">val</span> contentResolver = applicationContext.contentResolver</span><br><span class="line">    <span class="keyword">var</span> inputStream: InputStream? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = contentResolver.openInputStream(Uri.parse(fileUri))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: FileNotFoundException) &#123;</span><br><span class="line">        Log.e(javaClass.name, <span class="string">"file not found exception"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">    inputStream?.let &#123;</span><br><span class="line">        StreamUtil.copyFile(it,outputStream)</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(javaClass.name, <span class="string">"Client data written"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    Log.e(javaClass.name, <span class="string">"client socket error"</span>, e)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    socket.takeIf &#123; it.isConnected &#125;?.apply &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            close()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            Log.e(javaClass.name, <span class="string">"client socket close error"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 断开连接：    <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mWifiP2pManager?.removeGroup(mChannel, <span class="keyword">object</span> : WifiP2pManager.ActionListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(localClassName, <span class="string">"disconnect success"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(reason: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.w(localClassName, <span class="string">"disconnect failed:<span class="variable">$reason</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><ul><li><p>权限申请：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Wifi P2P 权限一定要有，不然获取不到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CHANGE_WIFI_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CHANGE_NETWORK_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.wifi.direct"</span> <span class="attr">android:required</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>  同样部分权限需要主动申请</p></li><li><p>初始化P2P：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intentFilter = IntentFilter().apply &#123;</span><br><span class="line">    addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)</span><br><span class="line">    addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)</span><br><span class="line">    addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)</span><br><span class="line">    addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)</span><br><span class="line">&#125;</span><br><span class="line">registerReceiver(mReceiver, intentFilter)</span><br><span class="line">mWifiP2pManager = getSystemService(Context.WIFI_P2P_SERVICE) <span class="keyword">as</span> WifiP2pManager</span><br><span class="line"><span class="comment">// 用这个通道来查找和连接P2P设备 在 WLAN P2P 框架中注册您的应用</span></span><br><span class="line">mChannel = mWifiP2pManager?.initialize(<span class="keyword">this</span>, mainLooper) &#123; Log.d(localClassName, <span class="string">"channel disconnected"</span>) &#125;</span><br><span class="line">mWifiP2pManager?.discoverPeers(mChannel, <span class="keyword">object</span> : WifiP2pManager.ActionListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(localClassName, <span class="string">"discover success"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(reason: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.w(localClassName, <span class="string">"discover failed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 用于创建GroupOwner，决定谁是Group的主导者</span></span><br><span class="line">mWifiP2pManager?.createGroup(mChannel, <span class="keyword">object</span> : WifiP2pManager.ActionListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(localClassName, <span class="string">"createGroup success"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(reason: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.w(localClassName, <span class="string">"create group failed: <span class="variable">$reason</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  Server可以不用去扫描设备，只需要在P2P中注册就可以了，等待被发现</p></li><li><p>创建ServerSocket，监听：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenThread</span> : <span class="type">Thread</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mServerSocket: ServerSocket = ServerSocket(WIFI_P2P_PORT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Log.d(javaClass.name, <span class="string">"server socket bg"</span>)</span><br><span class="line">            <span class="keyword">val</span> client = mServerSocket.accept()</span><br><span class="line">            mHandler?.takeIf &#123; mFilePath != <span class="literal">null</span> &#125;?.apply &#123;</span><br><span class="line">                ServerAsyncTask(<span class="keyword">this</span>, mFilePath!!).execute(client)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在子线程不断监听某个端口，等待连接就可以了</p></li><li><p>accept成功，通信：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = params[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> client?.use &#123; socket -&gt;</span><br><span class="line"><span class="keyword">val</span> f = File(mFilePath, <span class="string">"wifip2pshared-<span class="subst">$&#123;System.currentTimeMillis()&#125;</span>.jpg"</span>)</span><br><span class="line"><span class="keyword">val</span> dirs = File(f.parent?:mFilePath)</span><br><span class="line">dirs.takeIf &#123; !it.exists() &#125;?.apply &#123; mkdirs() &#125;</span><br><span class="line">f.createNewFile()</span><br><span class="line"><span class="keyword">val</span> inputStream = socket.getInputStream()</span><br><span class="line">StreamUtil.copyFile(inputStream, FileOutputStream(f))</span><br><span class="line">socket.close()</span><br><span class="line">f.absolutePath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.android.com/guide/topics/connectivity/wifip2p?hl=zh-cn" target="_blank" rel="noopener">WLAN 直连（对等连接或 P2P）概览</a></p><p><a href="https://www.jianshu.com/p/e9a23dfda330" target="_blank" rel="noopener">Android WiFi P2P开发实践笔记</a></p><p><a href="https://blog.csdn.net/Innost/article/details/8474683" target="_blank" rel="noopener">Android Wi-Fi Display（Miracast）介绍</a></p><p><a href="https://blog.csdn.net/u011897062/article/details/79445560" target="_blank" rel="noopener">多屏互动技术研究（二）之WifiDisplay(Miracast)技术原理及实现</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ol><li><p>socket连接失败：</p><p> 原因：由于server端对客户端的监听只是用了一个AyncTask，所以导致一次socket通信完成后，后续的再无法进行通信</p></li><li><p>设备一会查找得到，一会查找不到：</p><p> 原因：server端没有去初始化P2P，也就没有在WiFi P2P框架中去注册，导致无法client端就无法发现设备，同时server端也要启动discoverPeers，这样才能确保能够被发现，并且GroupOwner也是Server端所持有（并不绝对，可以通过createGroup来决定，最好是在Server端）</p></li><li><p>在UI线程更新UI导致的NetworkOnMainThreadException：</p><p> 原因：<code>mWifiP2pInfo?.groupOwnerAddress?.hostAddress</code>，直接通过WiFiP2PInfo去获取了GroupOwnerAddress，然后去获取HostAddress，这个调用过程产生了网络请求？？</p></li></ol><hr><h2 id="SDK包装SaaS"><a href="#SDK包装SaaS" class="headerlink" title="SDK包装SaaS"></a>SDK包装SaaS</h2><p>如何使用到云服务？？？</p><p>安装（可以考虑云）</p><p>投射播放的信息？？</p><p>语音？？（增加流量）</p><p>遥控（局域网内，或者走云进行下发（延迟太高））</p><p>投射本地/在线，本地走局域网，没有云</p><p>腾讯云短视频SDK（类比？？？）</p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li>Projection：</li><li>remote_help：</li></ul><h3 id="TV："><a href="#TV：" class="headerlink" title="TV："></a>TV：</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Bluetooth</title>
      <link href="/2019/11/20/Android%20Bluetooth/"/>
      <url>/2019/11/20/Android%20Bluetooth/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h1><p>传统蓝牙：比较耗电</p><p>低功耗蓝牙：</p><blockquote><p>从蓝牙4.0开始包含两个蓝牙芯片模块：传统/经典蓝牙模块(Classic Bluetooth,简称BT)和低功耗蓝牙(Bluetooth Low Energy,简称BLE) </p><p>经典蓝牙是在之前的蓝牙1.0,1.2,2.0+EDR,2.1+EDR,3.0+EDR等基础上发展和完善起来的, 而低功耗蓝牙是Nokia的Wibree标准上发展起来的，是完全不同两个标准。</p><ol><li>经典蓝牙模块(BT)</li></ol><p>泛指蓝牙4.0以下的模块，一般用于数据量比较大的传输，如：语音、音乐、较高数据量传输等。</p><p>经典蓝牙模块可再细分为：传统蓝牙模块和高速蓝牙模块。</p><ul><li>传统蓝牙模块在2004年推出，主要代表是支持蓝牙2.1协议的模块，在智能手机爆发的时期得到广泛支持。</li><li>高速蓝牙模块在2009年推出，速率提高到约24Mbps，是传统蓝牙模块的八倍。 </li></ul><p>传统蓝牙有3个功率级别，Class1,Class2,Class3,分别支持100m,10m,1m的传输距离</p><ol start="2"><li><p>低功耗蓝牙模块(BLE)</p><p>泛指蓝牙4.0或更高的模块，蓝牙低功耗技术是低成本、短距离、可互操作的鲁棒性无线技术，工作在免许可的2.4GHz ISM射频频段。旨在提供显著降低的功耗 ； 可与功率要求更严格的 BLE 设备（例如近程传感器、心率监测仪和健身设备）通信 </p><p>因为BLE技术采用非常快速的连接方式，因此平时可以处于“非连接”状态（节省能源），此时链路两端相互间只是知晓对方，只有在必要时才开启链路，然后在尽可能短的时间内关闭链路(每次最多传输20字节)。</p><p>低功耗蓝牙无功率级别，一般发送功率在7dBm，一般在空旷距离，达到20m应该是没有问题</p><p><font color="red"><strong>注意：</strong>当用户使用 BLE 将其设备与其他设备配对时，用户设备上的<strong>所有</strong>应用都可以访问在这两个设备间传输的数据。因此，如果您的应用捕获敏感数据，您应实现应用层安全以保护此类数据的私密性</font></p></li></ol></blockquote><p>Android手机蓝牙4.x都是双模蓝牙(既有经典蓝牙也有低功耗蓝牙)，而某些蓝牙设备为了省电是单模(只支持低功耗蓝牙) </p><ul><li><p>经典蓝牙：  </p><ol><li><p>传声音</p><p> 如蓝牙耳机、蓝牙音箱。蓝牙设计的时候就是为了传声音的，所以是近距离的音频传输的不二选择。</p><p> 现在也有基于WIFI的音频传输方案，例如Airplay等，但是WIFI功耗比蓝牙大很多，设备无法做到便携。</p><p> 因此固定的音响有WIFI的，移动的如耳机、便携音箱清一色都是基于经典蓝牙协议的。</p></li></ol></li></ul><pre><code>2. 传大量数据    例如某些工控场景，使用Android或Linux主控，外挂蓝牙遥控设备的，    可以使用经典蓝牙里的SPP协议，当作一个无线串口使用。速度比BLE传输快多了。    这里要注意的是，iPhone没有开放</code></pre><ul><li><p>BLE蓝牙:</p><p>  耗电低，数据量小，如遥控类(鼠标、键盘)，传感设备(心跳带、血压计、温度传感器、共享单车锁、智能锁、防丢器、室内定位)</p><p>  是目前手机和智能硬件通信的性价比最高的手段，直线距离约50米，一节5号电池能用一年，传输模组成本10块钱，远比WIFI、4G等大数据量的通信协议更实用。</p><p>  虽然蓝牙距离近了点，但胜在直连手机，价格超便宜。以室内定位为例，商场每家门店挂个蓝牙beacon，就可以对手机做到精度10米级的室内定位，一个beacon的价格也就几十块钱而已</p></li></ul><ul><li><p>双模蓝牙:</p><p>  如智能电视遥控器、降噪耳机等。很多智能电视配的遥控器带有语音识别，需要用经典蓝牙才能传输声音。</p><p>  而如果做复杂的按键，例如原本键盘表上没有的功能，经典蓝牙的HID按键协议就不行了，得用BLE做私有协议。</p><p>  包括很多降噪耳机上通过APP来调节降噪效果，也是通过BLE来实现的私有通信协议</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><ul><li><p>权限申请</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH_ADMIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- If your app targets Android 9 or lower, you can declare</span></span><br><span class="line"><span class="comment">       ACCESS_COARSE_LOCATION instead. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>初始化，打开蓝牙，扫描</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intentFilter = IntentFilter().apply &#123;</span><br><span class="line">addAction(BluetoothDevice.ACTION_FOUND)       </span><br><span class="line">    addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)</span><br><span class="line">    &#125;</span><br><span class="line">registerReceiver(mReceiver, intentFilter)</span><br><span class="line"></span><br><span class="line">mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter()</span><br><span class="line">mBluetoothAdapter?.let &#123; bluetoothAdapter -&gt;</span><br><span class="line"><span class="keyword">if</span> (!bluetoothAdapter.isEnabled) &#123;</span><br><span class="line">            <span class="comment">// enable bluetooth</span></span><br><span class="line">            <span class="keyword">val</span> enableBtIntent = Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE                 startActivityForResult(enableBtIntent, REQUEST_CODE_ENABLE_BT)            &#125;</span><br><span class="line">       <span class="keyword">if</span> (bluetoothAdapter.isDiscovering) &#123;</span><br><span class="line">            bluetoothAdapter.cancelDiscovery()</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">val</span> success = bluetoothAdapter.startDiscovery()</span><br><span class="line">       Log.d(localClassName, <span class="string">"connectionStart discovery:<span class="variable">$success</span>"</span>)</span><br><span class="line">       <span class="comment">// 已经配对的</span></span><br><span class="line">       <span class="keyword">val</span> pairedDevices: Set&lt;BluetoothDevice&gt;? = bluetoothAdapter.bondedDevices</span><br><span class="line">       <span class="keyword">if</span> (pairedDevices.isNullOrEmpty()) &#123;</span><br><span class="line">            mPairedDevicesArrayAdapter?.add(<span class="string">"no devices"</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pairedDevices.forEach &#123; device -&gt;</span><br><span class="line">                tv_title_paired.visibility = View.VISIBLE</span><br><span class="line">                <span class="keyword">val</span> deviceName = device.name</span><br><span class="line">                <span class="keyword">val</span> deviceHardwareAddress = device.address</span><br><span class="line">                mPairedDevicesArrayAdapter?.add(<span class="string">"<span class="variable">$deviceName</span>\n<span class="variable">$deviceHardwareAddress</span>"</span>)</span><br><span class="line">                Log.d(localClassName, <span class="string">"for name:<span class="variable">$deviceName</span>. address:<span class="variable">$deviceHardwareAddress</span>"</span>)</span><br><span class="line">                <span class="keyword">if</span> (deviceHardwareAddress == MAC_ADDRESS) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mClientThread == <span class="literal">null</span>) &#123;</span><br><span class="line">                        mClientThread = BluetoothClientThread(<span class="keyword">this</span>, device)</span><br><span class="line">                        mClientThread?.start()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        mPairedDevicesArrayAdapter?.notifyDataSetChanged()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 设置可检测</span></span><br><span class="line"><span class="comment">// val discoverableIntent: Intent = Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE).apply &#123;</span></span><br><span class="line">    <span class="comment">//     putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// startActivity(discoverableIntent)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>扫描结果</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mReceiver = <span class="keyword">object</span> : BroadcastReceiver() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        intent?.action?.let &#123; action -&gt;</span><br><span class="line"><span class="comment">//attention the location permission to bluetooth</span></span><br><span class="line"><span class="keyword">when</span>(action) &#123;</span><br><span class="line">                BluetoothDevice.ACTION_FOUND -&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> device: BluetoothDevice? = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)</span><br><span class="line">                    device?.apply &#123;</span><br><span class="line">                        <span class="keyword">val</span> deviceName = name</span><br><span class="line">                        <span class="keyword">val</span> deviceAddress = address</span><br><span class="line">                        Log.d(localClassName, <span class="string">"onReceive name: <span class="variable">$deviceName</span> address: <span class="variable">$deviceAddress</span>"</span>)</span><br><span class="line">                        <span class="keyword">if</span> (bondState != BluetoothDevice.BOND_BONDED) &#123;</span><br><span class="line">                             <span class="keyword">if</span> (address == MAC_ADDRESS) &#123;</span><br><span class="line">                            mNewDevicesArrayAdapter?.insert(<span class="string">"<span class="variable">$deviceName</span>\n<span class="variable">$deviceAddress</span>"</span>, <span class="number">0</span>)                                             </span><br><span class="line">                             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                 mNewDevicesArrayAdapter?.add(<span class="string">"<span class="variable">$deviceName</span>\n<span class="variable">$deviceAddress</span>"</span>)                                             </span><br><span class="line">                             &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mNewDevicesArrayAdapter?.notifyDataSetChanged()</span><br><span class="line">                &#125;</span><br><span class="line">                BluetoothAdapter.ACTION_DISCOVERY_FINISHED -&gt; &#123;</span><br><span class="line">                    title = <span class="string">"select to connect"</span></span><br><span class="line">                    mNewDevicesArrayAdapter?.let &#123;</span><br><span class="line">                        <span class="keyword">if</span> (it.count == <span class="number">0</span>) &#123;</span><br><span class="line">                            it.add(<span class="string">"no devices"</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>连接线程</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> mSocket: BluetoothSocket? = device.createRfcommSocketToServiceRecord(UUID.fromString(BLUETOOTH_UUID))</span><br><span class="line">   </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mSocket?.connect()</span><br><span class="line">        mConnectedThread = mSocket?.let &#123; ConnectedThread(it) &#125;</span><br><span class="line">        mConnectedThread?.start()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        Log.e(javaClass.name, <span class="string">"connect error"</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>读写线程</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectedThread</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> socket: BluetoothSocket) : Thread() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBuffer = ByteArray(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mDataOS = DataOutputStream(socket.outputStream)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mDataIS = DataInputStream(socket.inputStream)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        Log.d(javaClass.name, <span class="string">"connected thread init <span class="variable">$socket</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> num = mDataIS.read(mBuffer)</span><br><span class="line">                Log.d(javaClass.name, <span class="string">"read: <span class="subst">$&#123;String(mBuffer)&#125;</span>"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                Log.d(javaClass.name, <span class="string">"read error"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">writeFile</span><span class="params">(context: <span class="type">Context</span>, fileUri: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> len: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">var</span> fileIS: FileInputStream? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">val</span> inputStream: InputStream?</span><br><span class="line">        Log.d(javaClass.name, <span class="string">"client socket: <span class="subst">$&#123;socket.isConnected&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = context.contentResolver.openInputStream(Uri.parse(fileUri))</span><br><span class="line">            mDataOS.writeInt(FILE_SEND)</span><br><span class="line">            inputStream?.let &#123;</span><br><span class="line">                mDataOS.writeInt(it.available())</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    len = it.read(mBuffer)</span><br><span class="line">                    <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                Log.d(javaClass.name, <span class="string">"write <span class="subst">$&#123;mBuffer.size&#125;</span> <span class="subst">$&#123;mBuffer.count()&#125;</span> <span class="subst">$&#123;mBuffer.lastIndex&#125;</span> <span class="variable">$len</span>"</span>)</span><br><span class="line">                    mDataOS.write(mBuffer, <span class="number">0</span>, len)</span><br><span class="line">                &#125;</span><br><span class="line">                it.close()</span><br><span class="line">                Log.d(javaClass.name, <span class="string">"Client data written "</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            Log.e(javaClass.name, <span class="string">"client socket error"</span>, e)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fileIS?.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><ul><li><p>权限申请</p></li><li><p>打开蓝牙，保证可检测</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter()</span><br><span class="line"><span class="keyword">if</span> (mBluetoothAdapter == <span class="literal">null</span>) &#123;</span><br><span class="line">    Log.e(localClassName, <span class="string">"can't apply bluetooth"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">mBluetoothAdapter?.enable()</span><br><span class="line"><span class="comment">// 设置可检测</span></span><br><span class="line"><span class="comment">// val discoverableIntent: Intent = Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE).apply &#123;</span></span><br><span class="line"><span class="comment">//     putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 0)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// startActivity(discoverableIntent)</span></span><br><span class="line">mBluetoothAdapter?.name = <span class="string">"极光249"</span></span><br><span class="line">Log.d(localClassName, <span class="string">"enable: <span class="subst">$&#123;mBluetoothAdapter?.isEnabled&#125;</span> name: <span class="subst">$&#123;mBluetoothAdapter?.name&#125;</span> mac: <span class="subst">$&#123;mBluetoothAdapter?.address&#125;</span>"</span>)</span><br><span class="line">bindService(Intent(<span class="keyword">this</span>, BluetoothServerService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>), <span class="type">mConnection</span>, <span class="type">Context.BIND_AUTO_CREATE)</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>启动服务线程</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptThread</span> : <span class="type">Thread</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mServerSocket: BluetoothServerSocket? <span class="keyword">by</span> lazy(LazyThreadSafetyMode.NONE) &#123;</span><br><span class="line">        mBluetoothAdapter?.listenUsingInsecureRfcommWithServiceRecord(NAME, UUID.fromString(BLUETOOTH_UUID))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(javaClass.name, <span class="string">"AcceptThread begin"</span>)</span><br><span class="line">        name = <span class="string">"AcceptThread"</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> clientSocket: BluetoothSocket? = mServerSocket?.accept()</span><br><span class="line">            mHandler?.takeIf &#123; mFilePath != <span class="literal">null</span> &#125;?.apply &#123;</span><br><span class="line">                <span class="keyword">if</span> (mServerThread == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mServerThread = clientSocket?.let &#123; ServerThread(mHandler!!, mFilePath!!, it) &#125;</span><br><span class="line">                    mServerThread?.start()</span><br><span class="line">                &#125;</span><br><span class="line">                cancel()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            Log.e(javaClass.name, <span class="string">"error"</span>, e)</span><br><span class="line">            cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mServerSocket?.close()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            Log.e(javaClass.name, <span class="string">"Could not close the server mSocket"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>读写线程</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> : <span class="type">Thread &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mHandler: Handler</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mFilePath: String</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mSocket: BluetoothSocket</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mDataIS: DataInputStream</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mDataOS: DataOutputStream</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBuffer = ByteArray(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(handler: Handler, filePath: String, socket: BluetoothSocket): <span class="keyword">this</span>(<span class="string">"ServerThread"</span>, handler, filePath, socket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, handler: Handler, filePath: String, socket: BluetoothSocket) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.mHandler = handler</span><br><span class="line">        <span class="keyword">this</span>.mFilePath = filePath</span><br><span class="line">        <span class="keyword">this</span>.mSocket = socket</span><br><span class="line">        mDataIS = DataInputStream(mSocket.inputStream)</span><br><span class="line">        mDataOS = DataOutputStream(mSocket.outputStream)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> len: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">var</span> fileOS: FileOutputStream? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Log.d(javaClass.name, <span class="string">"receive start"</span>)</span><br><span class="line">                <span class="keyword">val</span> tag = mDataIS.readInt()</span><br><span class="line">                <span class="keyword">if</span> (tag == FILE_SEND) &#123;</span><br><span class="line">                    <span class="keyword">val</span> size = mDataIS.readInt()</span><br><span class="line">                    <span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">val</span> f = File(mFilePath, <span class="string">"bluetooth-shared-<span class="subst">$&#123;System.currentTimeMillis()&#125;</span>.jpg"</span>)</span><br><span class="line">                    <span class="keyword">val</span> dirs = File(f.parent?:mFilePath)</span><br><span class="line">                    dirs.takeIf &#123; !it.exists() &#125;?.apply &#123; mkdirs() &#125;</span><br><span class="line">                    f.createNewFile()</span><br><span class="line">                    fileOS = FileOutputStream(f)</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        len = mDataIS.read(mBuffer)</span><br><span class="line">                        length += len</span><br><span class="line">                        Log.d(javaClass.name, <span class="string">"size: <span class="variable">$size</span> receive <span class="variable">$len</span>"</span>)</span><br><span class="line">                        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        fileOS.write(mBuffer, <span class="number">0</span>, len)</span><br><span class="line">                        <span class="comment">// 记录接收的大小，在传输完成后跳出此次循环，避免一直阻塞在此</span></span><br><span class="line">                        <span class="keyword">if</span> (length &gt;= size) &#123;</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Log.d(javaClass.name, <span class="string">"receive end: <span class="subst">$&#123;f.absolutePath&#125;</span> size: <span class="variable">$size</span>"</span>)</span><br><span class="line">                    write(<span class="string">"received <span class="subst">$&#123;f.path&#125;</span>"</span>.toByteArray())</span><br><span class="line">                    <span class="keyword">val</span> msg = Message.obtain()</span><br><span class="line">                    msg.what = BluetoothServerActivity.MESSAGE_RECEIVE_FILE</span><br><span class="line">                    msg.obj = f.absolutePath</span><br><span class="line">                    mHandler.sendMessage(msg)</span><br><span class="line">            &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                Log.e(javaClass.name, <span class="string">"readFile error"</span>, e)</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                fileOS?.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">(bytes: <span class="type">ByteArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> outputStream = mSocket.outputStream</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream.write(bytes)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            Log.e(javaClass.name, <span class="string">"writeFile error"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancle</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mSocket.close()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            Log.e(javaClass.name, <span class="string">"close error"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/977ab323c0a5" target="_blank" rel="noopener">Android-经典蓝牙(BT)-建立长连接传输短消息和文件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Glide源码分析</title>
      <link href="/2019/08/11/Android%20Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/08/11/Android%20Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Android-Glide源码分析（4-9-0）"><a href="#Android-Glide源码分析（4-9-0）" class="headerlink" title="Android Glide源码分析（4.9.0）"></a>Android Glide源码分析（4.9.0）</h1><p>通常使用Glide就是如下的一个链式使用</p><p><code>Glide.with(context).load(url).into(imageView);</code></p><p>这是最基本的一个用法，下面就主要看看这三个步骤主要干了什么</p><h2 id="with"><a href="#with" class="headerlink" title="with()"></a>with()</h2><p>with可以重载以下的几个方法，然后返回一个RequestManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个重载的方法无非就是根据Context的来源不用进行的一个重载，最后都是获取一个Context对象，调用<code>getRetriever()</code>来获取一个RequestManagerRetriever对象，然后获取对应的RequestManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title">getRetriever</span><span class="params">(@Nullable Context context)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(context,</span><br><span class="line">        <span class="string">"You cannot start a load on a not yet attached View or a Fragment where getActivity() "</span></span><br><span class="line">            + <span class="string">"returns null (which usually occurs when getActivity() is called before the Fragment "</span></span><br><span class="line">            + <span class="string">"is attached or after the Fragment is destroyed)."</span>);</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getRetriever()</code>对Context进行检查，Context是不能为null的，然后就是通过Glide的get方法来获取了一个RequestManagerRetriever</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">          checkAndInitializeGlide(context);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Glide的get方法就主要是获取Glide的单例实例，Glide没有实例化就会触发一次实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkAndInitializeGlide</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        initializeGlide(context);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    initializeGlide(context, <span class="keyword">new</span> GlideBuilder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(@NonNull Context context, @NonNull GlideBuilder builder)</span> </span>&#123;</span><br><span class="line">    Context applicationContext = context.getApplicationContext();</span><br><span class="line">    <span class="comment">//根据注解获取对应的Module</span></span><br><span class="line">    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();</span><br><span class="line">    <span class="comment">//获取manifest中的Module</span></span><br><span class="line">    List&lt;com.bumptech.glide.<span class="keyword">module</span>.GlideModule&gt; manifestModules = Collections.emptyList();</span><br><span class="line">    <span class="keyword">if</span> (annotationGeneratedModule == <span class="keyword">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;</span><br><span class="line">        manifestModules = <span class="keyword">new</span> ManifestParser(applicationContext).parse();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置RequestManagerFactory</span></span><br><span class="line">    RequestManagerRetriever.RequestManagerFactory factory =</span><br><span class="line">annotationGeneratedModule != <span class="keyword">null</span>    ? annotationGeneratedModule.getRequestManagerFactory() : <span class="keyword">null</span>;</span><br><span class="line">    builder.setRequestManagerFactory(factory);</span><br><span class="line">    <span class="comment">//自定义的GlideModule</span></span><br><span class="line">    <span class="keyword">for</span> (com.bumptech.glide.<span class="keyword">module</span>.GlideModule <span class="keyword">module</span> : manifestModules) &#123;</span><br><span class="line">        <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">        annotationGeneratedModule.applyOptions(applicationContext, builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个Glide</span></span><br><span class="line">    Glide glide = builder.build(applicationContext);</span><br><span class="line">    ...</span><br><span class="line">        applicationContext.registerComponentCallbacks(glide);</span><br><span class="line">    <span class="comment">//保存到单例中</span></span><br><span class="line">    Glide.glide = glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化Glide会调用<code>initializeGlide(context)</code>方法，然后会创建一个GlideBuilder，再重载一次<code>initializeGlide(context, glideBuilder)</code>方法，进行初始化；</p><p>GlideBuilder根据命名就大致可以看出是干嘛的，利用了Builder模式，来构造Glide，可以通过GlideBuilder来进行Glide的配置，如果不进行配置，就使用GlideBuilder中默认的配置咯；当然这里就是一次new，没有通过build来进行创建，但是在后面会进行build的</p><p>在调用<code>initializeGlide(context, glideBuilder)</code>中，会从注解和 Manifest 中获取 GlideModule，并根据各 GlideModule 中的方法对 Glide 进行自定义；这就意味着通过GlideBuilder我们基本上初始化了一个Glide，然后保存到了单例中 </p><p>看看GlideBuilder的build方法时，我们初始化了哪些默认参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Glide <span class="title">build</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//请求的Executor</span></span><br><span class="line">    <span class="keyword">if</span> (sourceExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sourceExecutor = GlideExecutor.newSourceExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//磁盘缓存的Executor</span></span><br><span class="line">    <span class="keyword">if</span> (diskCacheExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (animationExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        animationExecutor = GlideExecutor.newAnimationExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内存大小计算的</span></span><br><span class="line">    <span class="keyword">if</span> (memorySizeCalculator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        memorySizeCalculator = <span class="keyword">new</span> MemorySizeCalculator.Builder(context).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查连接的</span></span><br><span class="line">    <span class="keyword">if</span> (connectivityMonitorFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        connectivityMonitorFactory = <span class="keyword">new</span> DefaultConnectivityMonitorFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Bitmap池，缓存Bitmap的</span></span><br><span class="line">    <span class="keyword">if</span> (bitmapPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = memorySizeCalculator.getBitmapPoolSize();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bitmapPool = <span class="keyword">new</span> BitmapPoolAdapter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arrayPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        arrayPool = <span class="keyword">new</span> LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内存缓存</span></span><br><span class="line">    <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        memoryCache = <span class="keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//磁盘缓存</span></span><br><span class="line">    <span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//网络请求的Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">        engine = <span class="keyword">new</span> Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, GlideExecutor.newUnlimitedSourceExecutor(), GlideExecutor.newAnimationExecutor(), isActiveResourceRetentionAllowed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultRequestListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaultRequestListeners = Collections.emptyList();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化RequestManagerRetriever，requestManagerFactory是Glide通过setRequestManagerFactory方法设置进来的</span></span><br><span class="line">    RequestManagerRetriever requestManagerRetriever = <span class="keyword">new</span> RequestManagerRetriever(requestManagerFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Glide(context, engine, memoryCache, bitmapPool, arrayPool, requestManagerRetriever, connectivityMonitorFactory, logLevel, defaultRequestOptions.lock(), defaultTransitionOptions, defaultRequestListeners, isLoggingRequestOriginsEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一些配置的初始化，直接就可以看懂了</p><p>由此，我们通过<code>Glide.get()</code>就获取了Glide的单实例，接着通过<code>getRequestManagerRetriever()</code>获取了RequestManagerRetriever</p><p>也就是<code>getRetriever(context)</code>最后得到了RequestManagerRetriever对象，然后通过<code>get(context)</code>获取对应的RequestManger，这里重载了很多get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You cannot start a load on a null Context"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是不管前面根据Activity、Fragment还是View、Context，都会调用对应的一个get方法</p><p>以Activity为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在后台线程</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则会使用无 UI 的 Fragment 进行管理</span></span><br><span class="line">        assertNotDestroyed(activity);</span><br><span class="line">        android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">return</span> fragmentGet(</span><br><span class="line">            activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里就可以看出，Glide都是通过一个无UI的Fragment来进行管理生命周期的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(@NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @NonNull android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">        Glide glide = Glide.get(context);</span><br><span class="line">        requestManager =</span><br><span class="line">            factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先获取到了<code>RequestManagerFragment</code>和当前的<code>RequestManager</code>，接着获取Glide实例，从 <code>RequestManagerFragment</code> 中通过 <code>getGlideLifecycle()</code> 获取到了 <code>Lifecycle</code> 对象。<code>Lifecycle</code> 对象提供了一系列的、针对 Fragment 生命周期的方法。它们将会在 Fragment 的各个生命周期方法中被回调。然后，我们将该 <code>Lifecycle</code> 传入到 <code>RequestManager</code> 中，以 <code>RequestManager</code> 中的两个方法为例，<code>RequestManager</code> 会对 <code>Lifecycle</code> 进行监听，从而达到了对 Fragment 的生命周期进行监听的目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttach(activity);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDetach();</span><br><span class="line">    unregisterFragmentWithRoot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    lifecycle.onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    lifecycle.onDestroy();</span><br><span class="line">    unregisterFragmentWithRoot();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，最后通过<code>with()</code>我们就得到了一个RequestManager对象</p><h2 id="load"><a href="#load" class="headerlink" title="load()"></a>load()</h2><p>前面通过<code>with()</code>拿到了RequestManager，接下来就是调用load方法了</p><p>在RequestManager中，因为实现了ModelTypes接口，所以重载了很多load方法，这就是为了方便我们使用，这样我们就是加载不同来源的图片了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span><span class="params">(@Nullable Bitmap bitmap)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(@Nullable Drawable drawable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(@Nullable String string)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(@Nullable Uri uri)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(@Nullable File file)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(@RawRes @DrawableRes @Nullable Integer resourceId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(@Nullable URL url)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(@Nullable <span class="keyword">byte</span>[] model)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">(@Nullable Object model)</span></span>;</span><br></pre></td></tr></table></figure><p>在RequestManager中，所有的load方法都是返回了<code>RequestBuilder&lt;Drawable&gt;</code>这个对象的，所以基本上处理的逻辑大致差不多</p><p>我们就选常用的string这个吧，因为常用的就是网络图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>asDrawable()</code>就是获取到一个RequestBuilder（是一个Drawable的），这又是一个Builder模式，接着就调用了load方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TranscodeType只是一个泛型表示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，不论我们使用了 <code>load()</code> 的哪个重载方法，最终都会调用到下面的方法。它的逻辑也比较简单，就是将我们的图片资源信息赋值给 <code>RequestBuilder</code> 的局部变量就完事了。至于图片如何被加载和显示，则在 <code>into()</code> 方法中进行处理。</p><h2 id="into"><a href="#into" class="headerlink" title="into()"></a>into()</h2><p>前面通过<code>with()</code>和<code>load()</code>分别先后获取了Glide的单例，然后将要加载的图片资源信息保存到了RequestBuilder中，接着就是最后一步也是最重要的一步，<code>into()</code>，这一步既包含了加载图片也包含了展示</p><p>这一步大致包含了以下几个过程</p><h3 id="开启DecodeJob"><a href="#开启DecodeJob" class="headerlink" title="开启DecodeJob"></a>开启DecodeJob</h3><p><code>DecodeJob</code> 负责从缓存或者从原始的数据源中加载图片资源，对图片进行变换和转码，是 Glide 图片加载过程的核心。<code>DecodeJob</code> 继承了 <code>Runnable</code>，实际进行图片加载的时候会将其放置到线程池当中执行。这个阶段我们重点介绍的是从 <code>RequestBuilder</code> 构建一个 <code>DecodeJob</code> 并开启 <code>DecodeJob</code> 任务的过程。即构建一个 <code>DecodeJob</code> 并将其丢到线程池里的过程。</p><p>into方法也是有几个重载的，我们直接看ImageView这个就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(@NonNull ImageView view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保证在UI线程执行</span></span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"><span class="comment">//获取RequestOptions</span></span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> into(</span><br><span class="line">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">        <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">        requestOptions,</span><br><span class="line">        Executors.mainThreadExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是保证当前是在UI线程，接着into方法接着调用了内部的into方法，其中<code>glideContext.buildImageViewTarget(view, transcodeClass)</code>是将ImageView封装成了一个BitmapImageViewTarget对象（transcodeClass是前面创建RequestBuilder时设置的Drawable，这是一个泛型），<code>Executors.mainThreadExecutor());</code>是获取主线程的线程池，方便最后回调用UI线程</p><p>先看看创建Target吧，不然后面结果回调不知道这个Target具体是什么</p><p>创建Target是根据GlideContext来创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;X&gt; <span class="function">ViewTarget&lt;ImageView, X&gt; <span class="title">buildImageViewTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull ImageView imageView, @NonNull Class&lt;X&gt; transcodeClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> imageViewTargetFactory.buildTarget(imageView, transcodeClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用了ImageViewTargetFactory来进行创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Z&gt; <span class="function">ViewTarget&lt;ImageView, Z&gt; <span class="title">buildTarget</span><span class="params">(@NonNull ImageView view,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                @NonNull Class&lt;Z&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"Unhandled class: "</span> + clazz + <span class="string">", try .as*(Class).transcode(ResourceTranscoder)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就会根据clazz来判断创建什么样的Target，通过前面可以知道我们需要的是一个Drawable对象，所以这里就会创建一个DrawableImageViewTarget对象</p><p>好了，接着看重载的into吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查封装的ViewTarget</span></span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must call #load() before calling #into()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Request</span></span><br><span class="line">    Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line"></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">    <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看根据Target和主线程回调线程池这些来创建的Request</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequest</span><span class="params">(Target&lt;TranscodeType&gt; target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, BaseRequestOptions&lt;?&gt; requestOptions, Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildRequestRecursive(target, targetListener, <span class="comment">/*parentCoordinator=*/</span> <span class="keyword">null</span>, transitionOptions, requestOptions.getPriority(), requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight(), requestOptions, callbackExecutor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.</span></span><br><span class="line">    ErrorRequestCoordinator errorRequestCoordinator = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (errorBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        errorRequestCoordinator = <span class="keyword">new</span> ErrorRequestCoordinator(parentCoordinator);</span><br><span class="line">        parentCoordinator = errorRequestCoordinator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建主要的Request，也就是我们需要加载的图片的Request 这里主要就是根据这些参数最后得到一个SingleRequest对象，同时将持有这个Target对象（DrawableImageViewTarget）</span></span><br><span class="line">    Request mainRequest = buildThumbnailRequestRecursive(target, targetListener, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight, requestOptions, callbackExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errorRequestCoordinator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mainRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> errorOverrideWidth = errorBuilder.getOverrideWidth();</span><br><span class="line">    <span class="keyword">int</span> errorOverrideHeight = errorBuilder.getOverrideHeight();</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)</span><br><span class="line">        &amp;&amp; !errorBuilder.isValidOverride()) &#123;</span><br><span class="line">        errorOverrideWidth = requestOptions.getOverrideWidth();</span><br><span class="line">        errorOverrideHeight = requestOptions.getOverrideHeight();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果设置了error，就会创建一个erroe的Request，进行加载error的图片资源</span></span><br><span class="line">    Request errorRequest = errorBuilder.buildRequestRecursive(target, targetListener, errorRequestCoordinator, errorBuilder.transitionOptions, errorBuilder.getPriority(), errorOverrideWidth, errorOverrideHeight, errorBuilder, callbackExecutor);</span><br><span class="line">    errorRequestCoordinator.setRequests(mainRequest, errorRequest);</span><br><span class="line">    <span class="keyword">return</span> errorRequestCoordinator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>buildRequest()</code>直接调用了内部的<code>buildRequestRecursive()</code>方法</p><p>会根据我们是否调用过 <code>RequestBuilder</code> 的 <code>error()</code> 方法设置过图片加载出错时候显示的图片来决定返回 <code>mainRequest</code> 还是 <code>errorRequestCoordinator</code>。因为我们没有设置该参数，所以会直接返回 <code>mainRequest</code>（最后是生成的SingleRequest对象，具体可以见源码的调用）</p><p>回到前面的into方法，得到了Request后，就会通过<code>requestManager.track(target, request);</code>来执行这个Request</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(@NonNull Target&lt;?&gt; target, @NonNull Request request)</span> </span>&#123;</span><br><span class="line">    targetTracker.track(target);</span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的主要作用有两个：</p><ol><li>调用 <code>TargetTracker</code> 的 <code>track()</code> 方法对对当前 <code>Target</code> 的生命周期进行管理，就是DrawableImageViewTarget；</li><li>调用 <code>RequestTracker</code> 的 <code>runRequest()</code> 方法对当前请求进行管理，当 Glide 未处于暂停状态的时候，会直接使用 <code>Request</code> 的 <code>begin()</code> 方法开启请求。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(@NonNull Request request)</span> </span>&#123;</span><br><span class="line">    requests.add(request);</span><br><span class="line">    <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">        <span class="comment">//开始请求</span></span><br><span class="line">        request.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request.clear();</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Paused, delaying request"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果暂停的或，会加入到pendingRequests这个list中等待后面执行</span></span><br><span class="line">        pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Request是一个SingleRequest，所以看它里面的begin方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertNotCallingCallbacks();</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="comment">//这个model是在SingleRequest创建的时候设置的（最开始其实是load方法设置的），如果前面没有load()的参数是null就不会进行后面的操作</span></span><br><span class="line">    <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">            width = overrideWidth;</span><br><span class="line">            height = overrideHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> logLevel = getFallbackDrawable() == <span class="keyword">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">        onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">"Received null model"</span>), logLevel);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot restart a running request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 如果我们在完成之后重新启动（通常通过诸如 notifyDataSetChanged() 之类的方法，</span></span><br><span class="line">    <span class="comment">// 在相同的目标或视图中启动相同的请求），我们可以使用我们上次检索的资源和大小</span></span><br><span class="line">    <span class="comment">// 并跳过获取新的大小。所以，如果你因为 View 大小发生了变化而想要重新加载图片</span></span><br><span class="line">    <span class="comment">// 就需要在开始新加载之前清除视图 (View) 或目标 (Target)。</span></span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">        <span class="comment">//已经有了图片数据源</span></span><br><span class="line">        onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="comment">//保证size&gt;0</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        <span class="comment">//在这里进行请求</span></span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接从target中获取</span></span><br><span class="line">        target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">        <span class="comment">//Target的生命周期</span></span><br><span class="line">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">        logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法几个步骤都在注释中了，当<code>status == Status.RUNNING</code>会调用<code>target.onLoadStarted(getPlaceholderDrawable());</code>触发Target的第一个生命周期</p><p>看看<code>onSizeReady()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一些检验，status必须是Status.WAITING_FOR_SIZE</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//接着改变为RUNNING</span></span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">    <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">    <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">        logV(<span class="string">"finished setup for calling load in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">    loadStatus =</span><br><span class="line">        engine.load(</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        requestOptions.getSignature(),</span><br><span class="line">        <span class="keyword">this</span>.width,</span><br><span class="line">        <span class="keyword">this</span>.height,</span><br><span class="line">        requestOptions.getResourceClass(),</span><br><span class="line">        transcodeClass,</span><br><span class="line">        priority,</span><br><span class="line">        requestOptions.getDiskCacheStrategy(),</span><br><span class="line">        requestOptions.getTransformations(),</span><br><span class="line">        requestOptions.isTransformationRequired(),</span><br><span class="line">        requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">        requestOptions.getOptions(),</span><br><span class="line">        requestOptions.isMemoryCacheable(),</span><br><span class="line">        requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">        requestOptions.getUseAnimationPool(),</span><br><span class="line">        requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">        <span class="keyword">this</span>,</span><br><span class="line">        callbackExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != Status.RUNNING) &#123;</span><br><span class="line">        loadStatus = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">        logV(<span class="string">"finished onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改变状态，然后通过Engine调用load方法进行请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(<span class="comment">/**这里是参数，太多了*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line"><span class="comment">//生成一个EngineKey，标识这一次Request</span></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">                                        resourceClass, transcodeClass, options);</span><br><span class="line"><span class="comment">//如果已经有了源数据，直接进行加载</span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//回调</span></span><br><span class="line">        cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果有缓存，获取缓存，防止重复网络请求</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//从缓存的EngineJob获取</span></span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        current.addCallback(cb, callbackExecutor);</span><br><span class="line">        <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//管理资源加载以及当资源加载完毕的时候通知回调，内部维护了一个线程池</span></span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">        key,</span><br><span class="line">        isMemoryCacheable,</span><br><span class="line">        useUnlimitedSourceExecutorPool,</span><br><span class="line">        useAnimationPool,</span><br><span class="line">        onlyRetrieveFromCache);</span><br><span class="line"><span class="comment">//否则开启一个任务进行请求</span></span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">        glideContext,</span><br><span class="line">        model,</span><br><span class="line">        key,</span><br><span class="line">        signature,</span><br><span class="line">        width,</span><br><span class="line">        height,</span><br><span class="line">        resourceClass,</span><br><span class="line">        transcodeClass,</span><br><span class="line">        priority,</span><br><span class="line">        diskCacheStrategy,</span><br><span class="line">        transformations,</span><br><span class="line">        isTransformationRequired,</span><br><span class="line">        isScaleOnlyOrNoTransform,</span><br><span class="line">        onlyRetrieveFromCache,</span><br><span class="line">        options,</span><br><span class="line">        engineJob);</span><br><span class="line"><span class="comment">//存入Jobs缓存</span></span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line"><span class="comment">//设置回调，后面要分析结果怎么返回的</span></span><br><span class="line">    engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">    <span class="comment">//执行DecodeJob</span></span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EngineJob</code> 内部维护了线程池，用来管理资源加载，以及当资源加载完毕的时候通知回调。 <code>DecodeJob</code> 继承了 <code>Runnable</code>，是线程池当中的一个任务。就像上面那样，我们通过调用 <code>engineJob.start(decodeJob)</code> 来开始资源加载。</p><ul><li>从ActiveResuorces中获取，看能否直接获取到，否则进行下一步</li><li>从Cache中获取，没有则进行下一步</li><li>从缓存的EngineJob中获取，等待执行回调，没有则进行下一步</li><li>创建一个DecodeJob来进行请求</li></ul><h3 id="打开网络流"><a href="#打开网络流" class="headerlink" title="打开网络流"></a>打开网络流</h3><p>在上一段内容中，我们知道了如果不能直接获取到结果，就会创建一个EngineJob和DecodeJob，将DecodeJob这个Runnable放到EngineJob的线程池中执行</p><p>看看DecodeJob的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">            notifyFailed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        runWrapped();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CallbackException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ..</span><br><span class="line">        <span class="keyword">if</span> (localFetcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">            localFetcher.cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        GlideTrace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是调用了<code>runWrapped()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">            stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">            currentGenerator = getNextGenerator();</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">            decodeFromRetrievedData();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>runReason</code> 是一个枚举类型，它包含的枚举值即为上面的三种类型。当我们在一个过程执行完毕之后会回调 <code>DecodeJob</code> 中的方法修改 <code>runReason</code>，然后根据新的状态值执行新的逻辑。</p><p>除了 <code>runReason</code>，<code>DecodeJob</code> 中还有一个变量 <code>stage</code> 也是用来决定 <code>DecodeJob</code> 状态的变量。同样，它也是一个枚举，用来表示将要加载数据的数据源以及数据的加载状态。它主要在加载数据的时候在 <code>runGenerators()</code>、<code>runWrapped()</code> 和 <code>getNextStage()</code> 三个方法中被修改。通常它的逻辑是，先从（大小、尺寸等）转换之后的缓存中拿数据，如果没有的话再从没有转换过的缓存中拿数据，最后还是拿不到的话就从原始的数据源中加载数据。</p><p>对于一个新的任务，会在 <code>DecodeJob</code> 的 <code>init()</code> 方法中将 <code>runReason</code> 置为 <code>INITIALIZE</code>，所以，我们首先会进入到上述 <code>switch</code> 中的 <code>INITIALIZE</code> 中执行。然后，因为我们没有设置过磁盘缓存的策略，因此会使用默认的 <code>AUTOMATIC</code> 缓存方式。于是，我们将会按照上面所说的依次从各个缓存中拿数据。由于我们是第一次加载，并且暂时我们不考虑缓存的问题，所以，最终数据的加载会交给 <code>SourceGenerator</code> 进行。</p><p>先看看<code>getNextGenerator();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">        <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized stage: "</span> + stage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是前面所说的顺序</p><ul><li>先从转换之后的缓存中获取，如果没有则进行下一步</li><li>从没有转换过的缓存中获取，如果没有则进行下一步</li><li>从原始的数据源中获取数据</li></ul><p>stage值会在<code>runGenerators();</code>进行修改，这样一次一次向后调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    currentThread = Thread.currentThread();</span><br><span class="line">    startFetchTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">           &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">        <span class="comment">//这里就会根据stage去获取对应的数据</span></span><br><span class="line">        stage = getNextStage(stage);</span><br><span class="line">        currentGenerator = getNextGenerator();</span><br><span class="line">        <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">            reschedule();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">        notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>currentGenerator.startNext()</code>进行获取，<code>currentGenerator</code>就是对应的几个ResourceCacheGenerator、DataCacheGenerator、SourceGenerator</p><p>接着看看<code>getnextStage()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">                ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">        <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">                ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">        <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">            <span class="comment">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class="line">            <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unrecognized stage: "</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是判断有没有数据的</p><h4 id="从转换过的缓存中获取ResourceCacheGenerator"><a href="#从转换过的缓存中获取ResourceCacheGenerator" class="headerlink" title="从转换过的缓存中获取ResourceCacheGenerator"></a>从转换过的缓存中获取ResourceCacheGenerator</h4><h4 id="从没有转换过的缓存中获取DataCacheGenerator"><a href="#从没有转换过的缓存中获取DataCacheGenerator" class="headerlink" title="从没有转换过的缓存中获取DataCacheGenerator"></a>从没有转换过的缓存中获取DataCacheGenerator</h4><h4 id="从原始数据获取SourceGenerator"><a href="#从原始数据获取SourceGenerator" class="headerlink" title="从原始数据获取SourceGenerator"></a>从原始数据获取SourceGenerator</h4><p>如果是第一次的话，最后是通过SourceGenerator来获取数据的，看看它的<code>startNext()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object data = dataToCache;</span><br><span class="line">        dataToCache = <span class="keyword">null</span>;</span><br><span class="line">        cacheData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    loadData = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">        <span class="comment">//获取对应的ModelLoader</span></span><br><span class="line">        loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">        <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">                || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//获取ModelLoader的fetcher进行loadData</span></span><br><span class="line">            loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先使用 <code>DecodeHelper</code> 的 <code>getLoadData()</code> 方法从注册的映射表中找出当前的图片类型对应的 <code>ModelLoader</code>；</li><li>然后使用它的 <code>DataFetcher</code> 的 <code>loadData()</code> 方法从原始的数据源中加载数据。</li></ol><p>由于我们的图片时网络中的资源，在默认情况下会使用 Glide 内部的 <code>HttpUrlFetcher</code> 从网络中加载数据。其 <code>loadData()</code> 方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">                     @NonNull DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取到了InputStram流了</span></span><br><span class="line">        InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">        <span class="comment">//回调结果</span></span><br><span class="line">        callback.onDataReady(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>loadDataWithRedirects()</code>获取数据流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">loadDataWithRedirects</span><span class="params">(URL url, <span class="keyword">int</span> redirects, URL lastUrl,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//创建UrlConnection</span></span><br><span class="line">    urlConnection = connectionFactory.build(url);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</span><br><span class="line">        urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    urlConnection.setConnectTimeout(timeout);</span><br><span class="line">    urlConnection.setReadTimeout(timeout);</span><br><span class="line">    urlConnection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">    urlConnection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">    urlConnection.setInstanceFollowRedirects(<span class="keyword">false</span>);</span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    stream = urlConnection.getInputStream();</span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> statusCode = urlConnection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (isHttpOk(statusCode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isHttpRedirect(statusCode)) &#123;</span><br><span class="line">        String redirectUrlString = urlConnection.getHeaderField(<span class="string">"Location"</span>);</span><br><span class="line">        ...</span><br><span class="line">        URL redirectUrl = <span class="keyword">new</span> URL(url, redirectUrlString);</span><br><span class="line">        cleanup();</span><br><span class="line">        <span class="keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="number">1</span>, url, headers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode == INVALID_STATUS_CODE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(statusCode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(urlConnection.getResponseMessage(), statusCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是通过UrlConnection去·打开网络，获取数据流，下面具体的就不再看了</p><h3 id="将输入流转换为Drawable"><a href="#将输入流转换为Drawable" class="headerlink" title="将输入流转换为Drawable"></a>将输入流转换为Drawable</h3><p>在获取到数据流后，会将数据流进行回调，先是回调到SourceGenerator中，最后回调到DecodeJob中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,</span></span></span><br><span class="line"><span class="function"><span class="params">                               DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//赋值保存</span></span><br><span class="line">    <span class="keyword">this</span>.currentSourceKey = sourceKey;</span><br><span class="line">    <span class="keyword">this</span>.currentData = data;</span><br><span class="line">    <span class="keyword">this</span>.currentFetcher = fetcher;</span><br><span class="line">    <span class="keyword">this</span>.currentDataSource = dataSource;</span><br><span class="line">    <span class="keyword">this</span>.currentAttemptingKey = attemptedKey;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">        runReason = RunReason.DECODE_DATA;</span><br><span class="line">        callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GlideTrace.beginSection(<span class="string">"DecodeJob.decodeFromRetrievedData"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对数据进行decode得到期望得到的类型</span></span><br><span class="line">            decodeFromRetrievedData();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            GlideTrace.endSection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过接口回调，然后将数据流及相应的一些参数赋值保存，然后调用<code>decodeFromRetrievedData()</code>进行数据转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//进行具体的数据转换</span></span><br><span class="line">        resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runGenerators();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用内部的<code>decodeFromData()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromData</span><span class="params">(DataFetcher&lt;?&gt; fetcher, Data data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          DataSource dataSource)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">        <span class="comment">//进行decode</span></span><br><span class="line">        Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Decoded result "</span> + result, startTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查data后然后调用<code>decodeFromFetcher()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromFetcher</span><span class="params">(Data data, DataSource dataSource)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//注意这里的R泛型是在创建Request时（也就是SingleRequest）指定的，也就是Drawable</span></span><br><span class="line">    <span class="comment">//获取LoadPath</span></span><br><span class="line">    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</span><br><span class="line">    <span class="keyword">return</span> runLoadPath(data, dataSource, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用<code>runLoadPath()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Data, ResourceType&gt; <span class="function">Resource&lt;R&gt; <span class="title">runLoadPath</span><span class="params">(Data data, DataSource dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     LoadPath&lt;Data, ResourceType, R&gt; path)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Options options = getOptionsWithHardwareConfig(dataSource);</span><br><span class="line">    <span class="comment">//将数据流封装到DataRewinder中</span></span><br><span class="line">    DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用LoadPath中的load方法</span></span><br><span class="line">        <span class="keyword">return</span> path.load(</span><br><span class="line">            rewinder, options, width, height, <span class="keyword">new</span> DecodeCallback&lt;ResourceType&gt;(dataSource));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rewinder.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用LoadPath中的load方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">load</span><span class="params">(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//异常检查</span></span><br><span class="line">    List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        listPool.release(throwables);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用<code>loadWithExceptionList()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;Transcode&gt; <span class="title">loadWithExceptionList</span><span class="params">(DataRewinder&lt;Data&gt; rewinder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  @NonNull Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> width, <span class="keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  List&lt;Throwable&gt; exceptions)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;Transcode&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decodePaths.size(); i &lt; size; i++) &#123;</span><br><span class="line">        DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//进行decode</span></span><br><span class="line">            result = path.decode(rewinder, width, height, options, decodeCallback);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">            exceptions.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着通过DecodePath中的load方法进行decode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//将数据流转换成我们需要的类型</span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    <span class="comment">//继续处理并显示</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看<code>decodeResource()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResource</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> height, @NonNull Options options)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    List&lt;Throwable&gt; exceptions = Preconditions.checkNotNull(listPool.acquire());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeResourceWithList(rewinder, width, height, options, exceptions);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        listPool.release(exceptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResourceWithList</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> height, @NonNull Options options, List&lt;Throwable&gt; exceptions)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;ResourceType&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decoders.size(); i &lt; size; i++) &#123;</span><br><span class="line">        ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataType data = rewinder.rewindAndGet();</span><br><span class="line">            <span class="keyword">if</span> (decoder.handles(data, options)) &#123;</span><br><span class="line">                data = rewinder.rewindAndGet();</span><br><span class="line">                <span class="comment">//根据ResourceDecoder进行具体的转换</span></span><br><span class="line">                result = decoder.decode(data, width, height, options);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | RuntimeException | OutOfMemoryError e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decodeResource()</code>方法会调用内部的<code>decodeResourceWithList()</code>进行数据转换，在<code>decodeResourceWithList()</code>方法中，会获取所有的ResourceDecoder，然后调用decode方法进行具体的转换</p><p><code>ResourceDecoder</code> 具有多个实现类，比如 <code>BitmapDrawableDecoder</code>、<code>ByteBufferBitmapDecoder</code>等。从名字也可以看出来是用来将一个类型转换成另一个类型的。</p><p>在我们的程序中会使用 <code>ByteBufferBitmapDecoder</code> 来将 <code>ByteBuffer</code> 转成 <code>Bitmap</code>。它最终会在 <code>Downsampler</code> 的 <code>decodeStream()</code> 方法中调用 <code>BitmapFactory</code> 的 <code>decodeStream()</code> 方法来从输入流中得到 Bitmap。（我们的 <code>ByteBuffer</code> 在  <code>ByteBufferBitmapDecoder</code> 中先被转换成了输入流。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferBitmapDecoder</span> <span class="keyword">implements</span> <span class="title">ResourceDecoder</span>&lt;<span class="title">ByteBuffer</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Downsampler downsampler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteBufferBitmapDecoder</span><span class="params">(Downsampler downsampler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.downsampler = downsampler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(@NonNull ByteBuffer source, @NonNull Options options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> downsampler.handles(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(@NonNull ByteBuffer source, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @NonNull Options options)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将数据流还原成InputStream</span></span><br><span class="line">        InputStream is = ByteBufferUtil.toStream(source);</span><br><span class="line">        <span class="comment">//转换并返回Resource&lt;Bitmap&gt;</span></span><br><span class="line">        <span class="keyword">return</span> downsampler.decode(is, width, height, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ByteBufferBitmapDecoder的decode方法中，会先将数据流还原成InputStream类型，接着调用了<code>downsampler.decode(is, width, height, options);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(InputStream is, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(InputStream is, <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Options options, DecodeCallbacks callbacks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//转换成一个Bitmap对象</span></span><br><span class="line">        Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions, downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth, requestedHeight, fixBitmapToRequestedDimensions, callbacks);</span><br><span class="line">        <span class="keyword">return</span> BitmapResource.obtain(result, bitmapPool);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">decodeFromWrappedStreams</span><span class="params">(InputStream is,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        DecodeFormat decodeFormat, <span class="keyword">boolean</span> isHardwareConfigAllowed, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> requestedHeight, <span class="keyword">boolean</span> fixBitmapToRequestedDimensions,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        DecodeCallbacks callbacks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);</span><br><span class="line">    callbacks.onDecodeComplete(bitmapPool, downsampled);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">decodeStream</span><span class="params">(InputStream is, BitmapFactory.Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   DecodeCallbacks callbacks, BitmapPool bitmapPool)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = BitmapFactory.decodeStream(is, <span class="keyword">null</span>, options);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        TransformationUtils.getBitmapDrawableLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Downsampler中的decode方法会调用重载的另一个decode方法，然后通过<code>decodeFromWrappedStreams()</code>转换为Bitmap对象，在<code>decodeFromWrappedStreams()</code>中又会调用<code>decodeStream()</code>方法，最后通过<code>BitmapFactory.decodeStream()</code>将InputSteam转换为Bitmap，然后一层一层返回</p><p>回到之前的DecodePath的decode方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//返回到这里来</span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options); <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">//进行图片处理，如圆角等</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded); <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//这里会将处理后的Bitmap转为Drawable</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用 <code>callback</code> 的方法进行回调，它最终会回调到 <code>DecodeJob</code> 的 <code>onResourceDecoded()</code> 方法。其主要的逻辑是根据我们设置的参数进行变化，也就是说，如果我们使用了 <code>centerCrop</code> 等参数，那么这里将会对其进行处理。这里的 <code>Transformation</code> 是一个接口，它的一系列的实现都是对应于 <code>scaleType</code> 等参数的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;Z&gt; <span class="function">Resource&lt;Z&gt; <span class="title">onResourceDecoded</span><span class="params">(DataSource dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  @NonNull Resource&lt;Z&gt; decoded)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Class&lt;Z&gt; resourceSubClass = (Class&lt;Z&gt;) decoded.get().getClass();</span><br><span class="line">    Transformation&lt;Z&gt; appliedTransformation = <span class="keyword">null</span>;</span><br><span class="line">    Resource&lt;Z&gt; transformed = decoded;</span><br><span class="line">    <span class="comment">//对图片进行变换</span></span><br><span class="line">    <span class="keyword">if</span> (dataSource != DataSource.RESOURCE_DISK_CACHE) &#123;</span><br><span class="line">        appliedTransformation = decodeHelper.getTransformation(resourceSubClass);</span><br><span class="line">        transformed = appliedTransformation.transform(glideContext, decoded, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    Resource&lt;Z&gt; result = transformed;</span><br><span class="line">    <span class="keyword">boolean</span> isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);</span><br><span class="line">    <span class="comment">//进行数据缓存</span></span><br><span class="line">    <span class="keyword">if</span> (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,</span><br><span class="line">                                              encodeStrategy)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (encoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Registry.NoResultEncoderAvailableException(transformed.get().getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Key key;</span><br><span class="line">        <span class="keyword">switch</span> (encodeStrategy) &#123;</span><br><span class="line">            <span class="keyword">case</span> SOURCE:</span><br><span class="line">                key = <span class="keyword">new</span> DataCacheKey(currentSourceKey, signature);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRANSFORMED:</span><br><span class="line">                key =</span><br><span class="line">                    <span class="keyword">new</span> ResourceCacheKey(</span><br><span class="line">                    decodeHelper.getArrayPool(),</span><br><span class="line">                    currentSourceKey,</span><br><span class="line">                    signature,</span><br><span class="line">                    width,</span><br><span class="line">                    height,</span><br><span class="line">                    appliedTransformation,</span><br><span class="line">                    resourceSubClass,</span><br><span class="line">                    options);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown strategy: "</span> + encodeStrategy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LockedResource&lt;Z&gt; lockedResult = LockedResource.obtain(transformed);</span><br><span class="line">        deferredEncodeManager.init(key, encoder, lockedResult);</span><br><span class="line">        result = lockedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的方法中对图形进行变换之后还会根据图片的缓存策略决定对图片进行缓存。然后这个方法就直接返回了我们变换之后的图象</p><p>接着回到上一个的return：<code>return transcoder.transcode(transformed, options)</code>会返回<code>Resouces&lt;BitmapDrawable&gt;</code>对象，transcoder是<code>ResourceTranscoder&lt;ResourceType, Transcode&gt;</code>，那么我们这里就是一个BitmapDrawableTranscoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;BitmapDrawable&gt; <span class="title">transcode</span><span class="params">(@NonNull Resource&lt;Bitmap&gt; toTranscode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          @NonNull Options options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进行转换</span></span><br><span class="line">    <span class="keyword">return</span> LazyBitmapDrawableResource.obtain(resources, toTranscode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过BitmapDrawableTranscoder会返回一个<code>Resource&lt;BitmapDrawable&gt;</code>，也就是说这里就将Bitmap转换为了BitmapDrawable，然后一层一层返回</p><h3 id="将Drawable显示到ImageView上"><a href="#将Drawable显示到ImageView上" class="headerlink" title="将Drawable显示到ImageView上"></a>将Drawable显示到ImageView上</h3><p>前面说到不断向上 <code>return</code> 进行返回。所以，我们又回到了 <code>DecodeJob</code> 的 <code>decodeFromRetrievedData()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这是前面分析的</span></span><br><span class="line">        resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">        e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">        throwables.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//接下来执行到这里</span></span><br><span class="line">        notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runGenerators();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyEncodeAndRelease</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Resource&lt;R&gt; result = resource;</span><br><span class="line">    ...</span><br><span class="line">    notifyComplete(result, dataSource);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着会调用<code>notifyComplete()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyComplete</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    setNotifiedOrThrow();</span><br><span class="line">    callback.onResourceReady(resource, dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过callback进行回调，callback是在创建DecodeJob时传进来的，前面有，传进来的就是EngineJob（实现了DecodeJob.Callback），回调到EngineJob的<code>onResourceReady()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyCallbacksOfResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将结果保存在EngineJob中，同时调用<code>notifyCallbacksOfResult();</code>通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyCallbacksOfResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceCallbacksAndExecutors copy;</span><br><span class="line">    Key localKey;</span><br><span class="line">    EngineResource&lt;?&gt; localResource;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      copy = cbs.copy();</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;</span><br><span class="line">        <span class="comment">//进行结果回调</span></span><br><span class="line">        entry.executor.execute(<span class="keyword">new</span> CallResourceReady(entry.cb));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后遍历所有的ResourceCallbackAndExecutor，这个里面包含了Engine的cb，也就是SingleRequest实现的回调接口（在SingleRequest调用engine的load方法时，会将自己实现的callback传入，然后在Engine中创建DecodeJob后，在执行DecodeJob之前会先将这个回调设置到EngineJob中<code>addCallback()</code>，同时将主线程的executor也传进来了，在这个方法就会添加到cbs中），也就是我们这里遍历的copy就是cbs的一个复制（cbs就是一个Callback和Executor的集合）</p><p>所以在这里执行的<code>entry.executor.execute(new CallResourceReady(entry.cb));</code>其实是执行的SingleRequest传进来的Executor（这个Executor是RequestBuilder的load方法时获取的主线程Executor），执行的回调接口就是SingleRequest本身</p><p>看看CallResourceReady</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CallResourceReady</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceCallback cb;</span><br><span class="line"></span><br><span class="line">    CallResourceReady(ResourceCallback cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EngineJob.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cbs.contains(cb)) &#123;</span><br><span class="line">                <span class="comment">// Acquire for this particular callback.</span></span><br><span class="line">                engineResource.acquire();</span><br><span class="line">                callCallbackOnResourceReady(cb);</span><br><span class="line">                removeCallback(cb);</span><br><span class="line">            &#125;</span><br><span class="line">            decrementPendingCallbacks();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个线程，通过主线程的线程池执行，主要就是<code>callCallbackOnResourceReady()</code>来进行回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callCallbackOnResourceReady</span><span class="params">(ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//进行回调</span></span><br><span class="line">        cb.onResourceReady(engineResource, dataSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CallbackException(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，通过主线程的线程池，将结果回调到SingleRequest中了</p><p>接着看回调<code>onResourceReady()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;</span><br><span class="line">            Transition&lt;? <span class="keyword">super</span> R&gt; animation =</span><br><span class="line">                animationFactory.build(dataSource, isFirstResource);</span><br><span class="line">            <span class="comment">//将结果传给了target，这个前面说过，是DrawableImageViewTarget</span></span><br><span class="line">            target.onResourceReady(result, animation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isCallingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyLoadSuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onResourceReady()</code>调用了内部的<code>onResourceReady()</code>方法，在这个方法我们主要看到<code>target.onResourceReady(result, animation);</code>这一行，这个target就是我们在最后一步into方法传入ImageView时，会去构建一个Target对象（实际上DrawableImageViewTarget对象），这个target就持有了我们的ImageView，接下来看看DrawableImageViewTarget</p><p>通过看源码知道，DrawableImageViewTarget没有<code>onResourceReady()</code>方法的实现，但是它是继承自ImageViewTarget的，所以看看ImageViewTarget</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(@NonNull Z resource, @Nullable Transition&lt;? <span class="keyword">super</span> Z&gt; transition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没有动画的时候</span></span><br><span class="line">    <span class="keyword">if</span> (transition == <span class="keyword">null</span> || !transition.transition(resource, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        setResourceInternal(resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maybeUpdateAnimatable(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以知道了，我们会通过<code>setResourceInternal()</code>这加载显示图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setResourceInternal</span><span class="params">(@Nullable Z resource)</span> </span>&#123;</span><br><span class="line">    setResource(resource);</span><br><span class="line">    maybeUpdateAnimatable(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会去调用<code>setResource()</code>这个抽象方法，那么针对我们前面的Target是DrawableImageViewTarget，就看DrawableImageViewTarget中的实现吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(@Nullable Drawable resource)</span> </span>&#123;</span><br><span class="line">    view.setImageDrawable(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>view就是我们设置的ImageView，这里就直接调用View的<code>setImageDrawable()</code>就完了，这样，图片就展示出来了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>with</p><p>  <img src="https://user-gold-cdn.xitu.io/2019/1/6/16823422d928fb82?imageslim" alt></p></li><li><p>load</p></li><li><p>into</p></li></ul><h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><ul><li><a href="https://juejin.im/post/5c31fbdff265da610e803d4e" target="_blank" rel="noopener">Glide 系列-2：主流程源码分析（4.8.0）</a></li><li><a href="https://juejin.im/entry/586766331b69e60063d889ea" target="_blank" rel="noopener">Glide 源码分析</a></li><li><a href="https://blog.csdn.net/carson_ho/article/details/79212841" target="_blank" rel="noopener">Android源码分析：这是一份详细的图片加载库Glide源码讲解攻略</a></li><li><a href="https://www.jianshu.com/p/9bb50924d42a" target="_blank" rel="noopener">Glide 源码分析解读-基于最新版Glide 4.9.0</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android View绘制——硬件绘制和软件绘制</title>
      <link href="/2019/08/10/Android%20View%E7%BB%98%E5%88%B6%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6/"/>
      <url>/2019/08/10/Android%20View%E7%BB%98%E5%88%B6%E2%80%94%E2%80%94%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Android-View绘制——硬件绘制和软件绘制"><a href="#Android-View绘制——硬件绘制和软件绘制" class="headerlink" title="Android View绘制——硬件绘制和软件绘制"></a>Android View绘制——硬件绘制和软件绘制</h1><p>HardWareRenderer是硬件加速绘制的入口，实现是一个ThreadedRenderer对象，跟一个Render线程息息相关，不过ThreadedRenderer是在UI线程中创建的，作用如下：</p><ul><li><ol><li>在UI线程中完成DrawOp集的构建</li></ol></li><li><ol><li>负责跟渲染线程通信</li></ol></li></ul><p>ThreadedRenderer RenderProxy ——&gt; RenderThread 单例线程，不会出现多线程并发访问冲突的问题 ——&gt; ThreadedRenderer的draw函数 ——&gt; updateRootDisplayList构建RootDisplayList，构建View的DrawOp树 ——&gt; 递归完成DrawOp树的构建</p><p>软件绘制同硬件合成的区别主要是在绘制上，内存分配、合成等整体流程是一样的，只不过硬件加速相比软件绘制算法更加合理，同时减轻了主线程的负担。</p><ol><li>构建阶段 ，递归遍历所有视图，将需要的操作缓存下来，之后再交给单独的Render线程利用OpenGL渲染。</li><li>绘制阶段 ，View视图被抽象成一个个DrawOp(DisplayListOp)，比如View中drawLine，构建中就会被抽象成一个DrawLintOp，每个DrawOp有对应的OpenGL绘制命令，同时内部也握着绘图所需要的数据。</li></ol><p><img src="https://img-blog.csdnimg.cn/20190312232704592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW41MjBhbw==,size_16,color_FFFFFF,t_70" alt></p><p><a href="https://blog.csdn.net/qian520ao/article/details/81144167" target="_blank" rel="noopener">Android 屏幕绘制机制及硬件加速</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些快捷键汇总</title>
      <link href="/2019/06/11/%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/"/>
      <url>/2019/06/11/%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="一些快捷键汇总"><a href="#一些快捷键汇总" class="headerlink" title="一些快捷键汇总"></a>一些快捷键汇总</h1><ul><li>tab：整体缩进一个tab</li><li>shift+tab：整体取消所有的缩进</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android RxJava2源码浅析</title>
      <link href="/2019/06/11/Android%20RxJava2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/11/Android%20RxJava2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Android-RxJava2源码浅析（2-2-8）"><a href="#Android-RxJava2源码浅析（2-2-8）" class="headerlink" title="Android RxJava2源码浅析（2.2.8）"></a>Android RxJava2源码浅析（2.2.8）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一些类介绍：</p><ul><li>Observable：abstract class，被观察者，被订阅者，数据源，上游</li><li>Observer：interface，观察者，订阅者，下游，数据接收处理的地方</li><li>ObservableSource：interface，抽象订阅的接口，每一个Observable都实现了这个接口，可以将它和Observable同样看待</li><li>ObservableOnSubscribe：interface，描述订阅的过程，实现这个subscribe方法进行发送数据，生产数据</li><li>ObservableEmitter：interface，抽象的被订阅者发射器</li><li>Emitter：interface，公用的抽象发射器，共有的API</li><li>ObservableCreate：class，Observable的实例，继承自Observable，也就是一个Observable对象，可以说是原始的Observable对象，持有ObservableOnSubscribe，一个普通的使用可以通过它走完流程（即上游数据到下游数据）</li><li>CreateEmitter：class，ObservableCreate的一个内部类，继承自AtomicReference，实现了ObservableEmitter和Disposable，真正的一个数据发射器，持有外部的observer对象</li><li>AtomicReference：class，对象引用的自动原子更新</li><li>Disposable：interface，描述数据的是否处置</li><li>QueueDisposable：interface，队列形式的Disposable</li><li>ObservableMap：class，继承自AbstractObservableWithUpstream，也是一个Observable，map的Observable，使用map的时候，则是包装了这层Observable来进行数据转换处理</li><li>AbstractObservableWithUpstream：abstract class，继承自Observable，持有了上一级的Observable对象（也就是ObservableSource）</li><li>MapObserver：class，继承自BasicFuseableObserver，是一个Observer，map的Observer，在onNext中通过mapper进行数据转换</li><li>Function：interface，map使用的一个抽象接口</li><li>BasicFuseableObserver：abstract class，实现了Observer和QueueDisposable，持有了下一级的observer对象</li><li>ObservableSubscribeOn：class，继承自AbstractObservableWithUpstream，持有上一级的Observable和Scheduler，进行线程调度，订阅的Observable</li><li>SubscribeOnObserver：class，继承自AtomicReference，实现了Observer和Disposable，线程调度具体实现地方，订阅的Observer</li><li>SubscribeTask：class，就是一个Runnable，通过SubscribeOnObserver中的Scheduler去执行，run方法中就是订阅，只有第一次订阅才有效</li><li>ObservableObserveOn：class，继承自AbstractObservableWithUpstream，持有上一级的Observable和线程调度的Scheduler，订阅者的Observable，每一次订阅都有效</li><li>ObserveOnObserver：class，继承自BasicIntQueueDisposable，实现了Observer和Runnable，订阅者的Observer，Scheduler执行的就是它</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><strong>简单使用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onNext(<span class="number">2</span>);</span><br><span class="line">        emitter.onNext(<span class="number">3</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    .map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (integer.equals(<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Observable1 map"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (integer.equals(<span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Observable2 map"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Observable3 map"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这是一个简单的使用例子，创建Observable，发送了三个Integer（1，2，3），通过Map将数据进行了一次转换，转为String，在IO线程发送，在UI线程消费，在Observer中接收事件</p><p>整体来说，整个操作流程大致分为以下几步</p><ul><li>create：创建Observable，在上游来发送数据</li><li>map：不是必须的一步，转换数据，这个放在后面分析</li><li>subscribeOn：订阅线程，上游发送数据所在的线程</li><li>observeOn：消费线程，下游接收数据所在的线程</li><li>subscribe：订阅，关联起来</li></ul><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>（<strong>这里分析的是最原始的，没有map操作，也没有线程切换</strong>）</p><p>先看看<code>Observable</code>的创建，在使用中，我们通常是通过匿名实现<code>ObservableOnSubscribe</code>来创建的，看看<code>Observable</code>中的create方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们new出的ObservableOnSubscribe就是我们的数据源，也就是上游，在create方法中先是对null进行了判断，不能为空；接着就直接返回了<code>RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source))</code></p><p>RxJavaPlugins是RxJava中的一个工具类，用来注入一些RxJava操作，我们的Observable（被观察者）就是通过它来创建的，跟进去看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(@NonNull Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> apply(f, source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个关于hook的方法，关于hook我们暂且不表，不影响主流程，我们默认使用中都没有hook，所以这里就是直接返回source，也就是我们前面创建的对象<code>new ObservableCreate&lt;T&gt;(source)</code></p><p>先好好看看这个，从<code>create()</code>方法的返回值，我们需要的<code>Observable</code>对象，但这里返回的是根据<code>ObservableOnSubscribe</code>创建的<code>ObservableCreate</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObservableCreate</code>就是<code>Observable</code>的一个实现类，持有了<code>ObservableOnSubscribe</code>这个<code>source</code>，关于<code>ObservableCreate</code>就先看这么多，后面还会再看这个的</p><p>下面再看看<code>ObservableOnSubscribe</code>这个是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableOnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个接口，内部定义了<code>subscribe()</code>方法，那再看看这个<code>ObservableEmitter</code>又是什么，从这里的注释可以知道它是一个发射器，用来抽象上关联<code>Observable</code>和<code>Observer</code>的，我们发射数据也是通过它来及进行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDisposable</span><span class="params">(@Nullable Disposable d)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCancellable</span><span class="params">(@Nullable Cancellable c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">ObservableEmitter&lt;T&gt; <span class="title">serialize</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(@NonNull Throwable t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObservableEmitter</code>又是继承自<code>Emitter</code>，同时自己也实现了一些API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable error)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Emitter</code>是一个公用的一个接口，定义了几个方法来标识一种状态（信号），这里面的几个API我们常用到，特别是在下游消费事件的时候</p><p><code>create()</code>方法我们先就看这么多，通过create方法得到了<code>ObservableCreate</code>对象</p><h3 id="subsribe"><a href="#subsribe" class="headerlink" title="subsribe"></a>subsribe</h3><p>接着我们看如何进行订阅接收数据的</p><p>通过<code>subscribe(Observer&lt;T&gt; observer)</code>方法来进行订阅，在Observer中接收数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"</span>);</span><br><span class="line"></span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，先是null检查，然后可能会抛出的一些异常捕获；</p><p>然后主要看看try语句块中的：<code>observer = RxJavaPlugins.onSubscribe(this, observer);</code>也是通过<code>RxJavaPlugins</code>来进行一个关于hook的处理，如果没有hook，其实返回的就是传入的observer；然后就是再一次null检查，接着就调用了<code>subscribeActual(observer);</code>方法</p><p><code>subscribeActual()</code>方法是一个抽象方法，需要靠子类去实现，那么前面<code>Observable</code>的创建，得到的<code>Observable</code>对象实际是<code>ObservableCreate</code></p><p>那就看看<code>ObservableCreate</code>中的<code>subscribeActual()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建CreateEmitter实例</span></span><br><span class="line">    CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将ObservableOnSubscribe（上游）与CreateEmitter（Observer，下游）关联起来</span></span><br><span class="line">        source.subscribe(parent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(ex);</span><br><span class="line">        <span class="comment">//错误回调</span></span><br><span class="line">        parent.onError(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建了<code>CreateEmitter</code>对象，这是<code>ObservableCreate</code>的一个静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line"></span><br><span class="line">    CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observer = observer;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CreateEmitter</code>继承自<code>AtomicReference</code>（一个可以通过原子方式来进行自动更新的类，<strong>对象引用的自动原子更新</strong>），实现了<code>ObservableEmitter</code>（这个在<code>Observable</code>的创建中我们提到过）和<code>Disposable</code>（用来描述资源是否被处置）</p><p>回到前面的<code>subscribeActual()</code>方法</p><p>接着通过<code>observer</code>回调了<code>onSubscribe(parent)</code>方法，这个参数就是刚new出的CreateEmitter（实现了Disposable）；然后通过<code>source</code>调用了<code>subscribe()</code>方法，这个<code>source</code>就是我们创建<code>ObservableCreate</code>时传入的<code>ObservableOnSubscribe</code>，也就是我们在代码里写的<code>ObservableOnSubscribe</code>，那么这里就是回调到了我们外面的<code>ObservableOnSubscribe</code>的<code>subscribe()</code>方法，这样就上游发射、下游接收就关联起来了</p><p>然后我们看看数据是怎么进行发射和接收的</p><p>在代码中，我们在<code>ObservableOnSubscribe</code>的<code>subscribe()</code>方法中进行数据的发射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emitter.onNext(<span class="number">1</span>);</span><br><span class="line">emitter.onNext(<span class="number">2</span>);</span><br><span class="line">emitter.onNext(<span class="number">3</span>);</span><br><span class="line">emitter.onComplete();</span><br></pre></td></tr></table></figure><p>比如我们通过发射器<code>ObservableEmitter</code>发射了1、2、3三个整型，这个<code>ObservableEmitter</code>就是前面创建的<code>CreateEmitter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onError(<span class="keyword">new</span> NullPointerException(<span class="string">"onNext called with null. Null values are generally not allowed in 2.x operators and sources."</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">        observer.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对数据进行一个null检查，同时有<code>Disposable</code>来监控一个取消的状态，当还没有处理的时候，就直接通过<code>Observer</code>的<code>onNext()</code>进行回调了</p><p>其他的onError、onComplete等都是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryOnError(t)) &#123;</span><br><span class="line">        RxJavaPlugins.onError(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = <span class="keyword">new</span> NullPointerException(<span class="string">"onError called with null. Null values are generally not allowed in 2.x operators and sources."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            observer.onError(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            observer.onComplete();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DisposableHelper.isDisposed(get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用<code>onError()</code>或者<code>onComplete()</code>方法后，都会调用<code>dispose();</code>，来中断后续的操作了</p><p>基本上每个操作API都会用到<code>isDisposed()</code>来进行判断，我们就好好看看这个怎么来判断的</p><p>首先看看<code>DisposableHelper</code>这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DisposableHelper implements Disposable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The singleton instance representing a terminal, disposed state, don't leak it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DISPOSED</span><br><span class="line">    ;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个枚举类，拥有自身的单例，同时实现了Disposable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d == DISPOSED;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dispose</span><span class="params">(AtomicReference&lt;Disposable&gt; field)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 通过断点查看，默认情况下,field的值是"null"，并非引用是null哦！大坑大坑大坑</span></span><br><span class="line">    <span class="comment">//但是current是null引用</span></span><br><span class="line">    Disposable current = field.get();</span><br><span class="line">    Disposable d = DISPOSED;</span><br><span class="line">    <span class="comment">//2 null不等于DISPOSED</span></span><br><span class="line">    <span class="keyword">if</span> (current != d) &#123;</span><br><span class="line">        <span class="comment">//3 field是DISPOSED了，current还是null</span></span><br><span class="line">        current = field.getAndSet(d);</span><br><span class="line">        <span class="keyword">if</span> (current != d) &#123;</span><br><span class="line">            <span class="comment">//4 默认情况下 走不到这里，这里是在设置了setCancellable()后会走到。</span></span><br><span class="line">            <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                current.dispose();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isDisposed()</code>就是简单的比较引用是否相同</p><p><code>dispose()</code>方法，这个通过把当前的<code>CreateEmitter</code>（继承自<code>AtomicReference</code>）传入，进行dispose（这里就直接看<a href="https://blog.csdn.net/zxt0601" target="_blank" rel="noopener">张旭童</a>的<a href="https://blog.csdn.net/zxt0601/article/details/61614799" target="_blank" rel="noopener">RxJava2 源码解析（一）</a>中引用的部分了）</p><p>又出现了<code>AtomicReference</code>，简单说一下相关的API吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回当前的引用。</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前值与给定的expect引用相等，（注意是引用相等而不是equals()相等），更新为指定的update值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span></span></span><br><span class="line"><span class="function"><span class="comment">//原子地设为给定值并返回旧值。</span></span></span><br><span class="line"><span class="function">V <span class="title">getAndSet</span><span class="params">(V newValue)</span></span></span><br></pre></td></tr></table></figure><p>好了，自此我们就在下游获取到了数据</p><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><p>接着我们加上线程切换来看看是怎么回事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.subscribeOn(Schedulers.io())</span><br></pre></td></tr></table></figure><p>这是订阅的线程，跟进去看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查null，然后同样是<code>RxJavaPlugins</code>就不再多说，返回的就是<code>ObservableSubscribeOn</code>对象，看看类的继承结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">U</span>&gt; <span class="keyword">implements</span> <span class="title">HasUpstreamObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以知道，<code>ObservableSubscribeOn</code>也是一个<code>Observable</code>对象</p><p>接着看看它的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(source);</span><br><span class="line">    <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用super方法，传入了source，在其父类<code>AbstractObservableWithUpstream</code>中只是简单的持有了source这个对象，也就是说<code>ObservableSubscribeOn</code>持有了上一次的<code>Observable</code>对象（也是<code>ObservableSource</code>，前面说过它们的关系）和线程调度器<code>Scheduler</code></p><p>然后我们就接着看是怎么订阅上的，最后subscribe的时候，同普通的时候一样，会调用<code>subscribeActual(observer);</code>方法，但这里就不是<code>ObservableCreate</code>中的了，而是<code>ObservableSubscribeOn</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(observer);</span><br><span class="line">    <span class="comment">//回调方法，传入上一级的observer onSubscribe()方法执行在 订阅处所在的线程</span></span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line">    <span class="comment">//线程的处理 setDisposable()是为了将子线程的操作加入Disposable管理中</span></span><br><span class="line">    parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，创建了<code>SubscribeOnObserver</code>（也是一个<code>Observer</code>对象），这个类是对传入的<code>observer</code>进行一个持有</p><p>然后创建了<code>SubscribeTask</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里就进行了真正的订阅</span></span><br><span class="line">        source.subscribe(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个Runnable，持有<code>SubscribeOnObserver</code>对象，进行了真正的订阅</p><p>然后将<code>SubscribeTask</code>传到了<code>scheduler</code>的<code>scheduleDirect()</code>方法，就是去执行<code>SubscribeOnObserver</code>中的代码，这样就做到了线程的调度</p><p>如此，我们的订阅的流程都是在我们所指定的<code>scheduler</code>中执行了</p><p>然后我们看看<code>SubscribeOnObserver</code>中的<code>onNext()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    downstream.onNext(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    downstream.onError(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    downstream.onComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，不管是<code>onNext()</code>、<code>onError()</code>还是<code>onComplete()</code>，都是直接通过downstream（这里就是我们设置的observer）直接回调了</p><h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h3><p><code>observeOn()</code>大致思想都差不多，只不过这里是消费的线程了（订阅者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回了<code>ObservableObserveOn</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> delayError;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableObserveOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同样保留上一次的Observable——ObservableSource</span></span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">        <span class="keyword">this</span>.delayError = delayError;</span><br><span class="line">        <span class="keyword">this</span>.bufferSize = bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">        source.subscribe(observer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建出一个 主线程的Worker</span></span><br><span class="line">        Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line">        <span class="comment">//2 订阅上游数据源</span></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样也是创建了一个<code>Observer</code>，不过这里的<code>Observer</code>是<code>ObserveOnObserver</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下游的观察者</span></span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; downstream;</span><br><span class="line">    <span class="comment">//对应Scheduler里的Worker</span></span><br><span class="line">    <span class="keyword">final</span> Scheduler.Worker worker;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> delayError;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line">    <span class="comment">//上游被观察者 push 过来的数据都存在这里</span></span><br><span class="line">    SimpleQueue&lt;T&gt; queue;</span><br><span class="line">    Disposable upstream;</span><br><span class="line">    <span class="comment">//如果onError了，保存对应的异常</span></span><br><span class="line">    Throwable error;</span><br><span class="line">    <span class="comment">//是否完成</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> done;</span><br><span class="line">    <span class="comment">//是否取消</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> disposed;</span><br><span class="line">    <span class="comment">// 代表同步发送 异步发送 </span></span><br><span class="line">    <span class="keyword">int</span> sourceMode;</span><br><span class="line">    <span class="keyword">boolean</span> outputFused;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来简单分析几个API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.upstream, d)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.upstream = d;</span><br><span class="line">        <span class="keyword">if</span> (d <span class="keyword">instanceof</span> QueueDisposable) &#123;</span><br><span class="line">            ...</span><br><span class="line">                <span class="comment">//同步</span></span><br><span class="line">                <span class="keyword">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//异步</span></span><br><span class="line">            <span class="keyword">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个queue 用于保存上游 onNext() push的数据</span></span><br><span class="line">        queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line">        <span class="comment">//回调下游观察者onSubscribe方法</span></span><br><span class="line">        downstream.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onSubscribe()</code>多了同步异步的判断和处理，同时创建了queue来保存上游的<code>onNext()</code>发送的数据</p><p>再看看<code>onNext()</code>等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果数据源类型不是异步的， 默认不是</span></span><br><span class="line">    <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">        <span class="comment">//将上游push过来的数据 加入 queue里</span></span><br><span class="line">        queue.offer(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始进入对应Workder线程，在线程里 将queue里的t 取出 发送给下游Observer</span></span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        RxJavaPlugins.onError(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    error = t;</span><br><span class="line">    done = <span class="keyword">true</span>;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    done = <span class="keyword">true</span>;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都会判断是否完成，调用<code>onError()</code>和<code>onComplete()</code>都会让done置为true，然后都会调用<code>schedule()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//该方法需要传入一个线程， 注意看本类实现了Runnable的接口，所以查看对应的run()方法</span></span><br><span class="line">        worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认false</span></span><br><span class="line">    <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">        drainFused();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//取出queue里的数据 发送</span></span><br><span class="line">        drainNormal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>drainNormal()</code>来进行数据发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> missed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = downstream;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//如果已经 终止 或者queue空，则跳出函数</span></span><br><span class="line">        <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> d = done;</span><br><span class="line">            T v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从queue里取出一个值</span></span><br><span class="line">                v = q.poll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//再次检查 是否 终止  如果满足条件 跳出函数</span></span><br><span class="line">            <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上游还没结束数据发送，但是这边处理的队列已经是空的，不会push给下游 Observer</span></span><br><span class="line">            <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                <span class="comment">//仅仅是结束这次循环，不发送这个数据而已，并不会跳出函数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送给下游</span></span><br><span class="line">            a.onNext(v);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要就是死循环，不断从队列中取，然后进行null检查已经检查是否种植，发送给下游，回调</p><h3 id="map操作符"><a href="#map操作符" class="headerlink" title="map操作符"></a>map操作符</h3><p>得到了<code>ObservableCreate</code>对象后，在其<code>subscribe()</code>方法发送数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emitter.onNext(<span class="number">1</span>);</span><br><span class="line">emitter.onNext(<span class="number">2</span>);</span><br><span class="line">emitter.onNext(<span class="number">3</span>);</span><br><span class="line">emitter.onComplete();</span><br></pre></td></tr></table></figure><p>接着，我们可以选择使用map操作符，来对数据进行一个转换操作（这是RxJava非常强大的地方之一了）</p><p>使用的时候，主要是创建了Function来做这个数据如何变换，在<code>apply()</code>方法中会接收到前面发送的数据，这个时候我们就可以进行对应的数据转换操作了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (integer.equals(<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Observable1 map"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (integer.equals(<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Observable2 map"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Observable3 map"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后将这个Function设置给<code>Observable</code>对象，也就是前面的<code>ObservableCreate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(mapper, <span class="string">"mapper is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又出现了<code>RxJavaPlugins</code>这个类，其实进去看源码知道，如果没有hook的情况下，都会返回你传进去的参数，传进去是什么，返回的就是什么，如果有hook就有对应的一些处理；默认是没有hook的，所以我们就不再看有hook的情况了</p><p>那么这里就是这里new出了<code>ObservableMap</code>，并返回了它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">U</span>&gt; <span class="keyword">implements</span> <span class="title">HasUpstreamObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个类的继承关系，就知道，<code>ObservableMap</code>也是一个<code>Observable</code>对象（<code>ObservableCreate</code>），所以我们前面能够直接返回</p><p>看看这个<code>ObservableMap</code>对象的构造方法，因为参数是<code>(this, mapper)</code>这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObservableMap</span><span class="params">(ObservableSource&lt;T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(source);</span><br><span class="line">    <span class="keyword">this</span>.function = function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObservableSource</code>是什么？<code>ObservableSource</code>是一个接口，从前面传参的时候，说明<code>Observable</code>是实现了这个接口的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它代表了一个标准的无背压的 源数据接口</p><p>那么现在知道了这个source是什么了（从另一方面来说，<code>ObservableSource</code>其实是和<code>Observable</code>（<code>ObservableCreate</code>）等价的，可能只是为了从<code>Observable</code>众多的操作剥离出这个抽象来），同时我们得到了source是为了在<code>AbstractObservableWithUpstream</code>保存这个上游的<code>ObservableSource</code>，也就是我们一开始创建的<code>ObservableCreate</code>对象</p><p>那么现在再看看<code>ObservableMap</code>，它首先持有了进行数据转换的Function，它还继承自<code>AbstractObservableWithUpstream</code>，这个类里也保存了转换之前的<code>Observable</code>（上游）</p><p>也就是说，如果我们使用了map操作，最后得到的<code>Observable</code>对象其实是<code>ObservableMap</code>对象，那么在接下来调用订阅的时候<code>subscribe()</code>，会调用到<code>ObservableMap</code>中的<code>subscribeActual()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里的t就是外面的observer，function就是之前通过map定义的Function进行数据转换的，source就是之前的Observable，建立了和MapObserver的关联</span></span><br><span class="line">    source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里直接创建了一个<code>MapObserver</code>，这是<code>ObservableMap</code>的静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        MapObserver(Observer&lt;? <span class="keyword">super</span> U&gt; actual, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(actual);</span><br><span class="line">        <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapObserver</code>继承自<code>BasicFuseableObserver</code>，从类名就应该能猜出这就是一个Observer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">QueueDisposable</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//下游的订阅者 observer</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> R&gt; downstream;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicFuseableObserver</span><span class="params">(Observer&lt;? <span class="keyword">super</span> R&gt; downstream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.downstream = downstream;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>BasicFuseableObserver</code>的继承结构看到，它实现了<code>Observer</code>，所以它也是一个<code>Observer</code>，同时保存了我们传入的<code>Observer</code>，它还实现了队列的Disposable<code>QueueDisposable</code>，这就说明了我们的map操作是一个一个执行的，按队列执行的</p><p>所以<code>MapObserver</code>和<code>BasicFuseableObserver</code>都是对<code>Observer</code>的再一层包装；<code>ObservableMap</code>也是对之前的<code>Observable</code>的一层包装，保留了之前的<code>Observable</code>（source就是上一次的<code>ObservableSource</code>，最开始创建的<code>ObservableCreate</code>）</p><p>和没有map的时候一样，前面<code>Observable</code>发送数据，通过<code>onNext()</code>发送，<code>onComplete()</code>结束，那么看看<code>MapObserver</code>中的<code>onNext()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用onComplete和onError方法，会在BasicFuseableObserver中置为true</span></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceMode != NONE) &#123;</span><br><span class="line">        downstream.onNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    U v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        fail(ex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    downstream.onNext(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T是转换前的数据类型，U是转换后的数据类型，在这个方法中，很直观的看到，通过调用<code>mapper.apply(t)</code>来进行了数据类型的转换（这个mapper就是我们通过map设置的数据转换Function），将T转换为U，然后通过downstream（就是我们代码设置的Observer）回调，这样就进行了我们的数据转换</p><p>梳理一下map的流程</p><p>订阅的过程，是从下游到上游依次订阅的：</p><ol><li>即终点 <code>Observer</code> 订阅了 map 返回的<code>ObservableMap</code>。</li><li>然后map的<code>Observable</code>(<code>ObservableMap</code>)在被订阅时，会订阅其内部保存上游<code>Observable</code>（创建的<code>ObservableCreate</code>），用于订阅上游的<code>Observer</code>是<code>MapObserver</code>，内部保存了下游（本例是终点）<code>Observer</code>，以便上游发送数据过来时，能传递给下游。</li><li>以此类推，直到源头<code>Observable</code>被订阅，根据前面的内容，它开始向<code>Observer</code>发送数据。</li></ol><p>数据传递的过程，当然是从上游push到下游的：</p><ol><li>源头<code>Observable</code>（<code>ObservableCreate</code>）传递数据给下游<code>Observer</code>（这里就是<code>MapObserver</code>）</li><li>然后<code>MapObserver</code>接收到数据，对其变换操作后(实际的function在这一步执行)，再调用内部保存的下游<code>Observer</code>的<code>onNext()</code>发送数据给下游</li><li>以此类推，直到终点<code>Observer</code></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>没有其他操作时</p><p>  <img src="https://img-blog.csdnimg.cn/20190611174554298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="RxJava2没有其他操作时"></p></li><li><p>加上map</p><p>  <img src="https://img-blog.csdnimg.cn/20190611180410578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="RxJava2有map"></p><ol><li>内部对上游Observable进行订阅</li><li>内部订阅者接收到数据后，将数据转换，发送给下游Observer.</li><li>操作符返回的Observable和其内部订阅者、是装饰者模式的体现。</li><li>操作符数据变换的操作，也是发生在订阅后。</li></ol></li><li><p>加上线程调度</p><p>  <img src="https://img-blog.csdnimg.cn/20190611182202538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="加上线程调度"></p><ul><li>线程调度subscribeOn()：</li></ul><ol><li>内部先切换线程，在切换后的线程中对上游Observable进行订阅，这样上游发送数据时就是处于被切换后的线程里了。</li><li>也因此多次切换线程，最后一次切换（离源数据最近）的生效。</li><li>内部订阅者接收到数据后，直接发送给下游Observer.</li><li>引入内部订阅者是为了控制线程（dispose）</li><li>线程切换发生在Observable中。</li></ol><ul><li>线程调度observeOn():</li></ul><ol><li>使用装饰的Observer对上游Observable进行订阅</li><li>在Observer中onXXX()方法里，将待发送数据存入队列，同时请求切换线程处理真正push数据给下游。</li><li>多次切换线程，都会对下游生效。</li></ol></li></ul><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><ul><li><a href="https://blog.csdn.net/zxt0601/article/details/61614799" target="_blank" rel="noopener">RxJava2 源码解析（一）</a></li><li><a href="https://blog.csdn.net/zxt0601/article/details/61637439" target="_blank" rel="noopener">RxJava2 源码解析（二）</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android OkHttp3源码分析</title>
      <link href="/2019/06/03/Android%20OkHttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/03/Android%20OkHttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Android-OkHttp3源码分析"><a href="#Android-OkHttp3源码分析" class="headerlink" title="Android OkHttp3源码分析"></a>Android OkHttp3源码分析</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>OKHttp优点</p><ol><li>支持HTTP2/SPDY（SPDY是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。）</li><li>socket自动选择最好路线，并支持自动重连，拥有自动维护的socket连接池，减少握手次数，减少了请求延迟，共享Socket,减少对服务器的请求次数。</li><li>基于Headers的缓存策略减少重复的网络请求。</li><li>拥有Interceptors轻松处理请求与响应（自动处理GZip压缩）。</li></ol><p>OKHttp的功能</p><ol><li>PUT，DELETE，POST，GET等请求</li><li>文件的上传下载</li><li>加载图片(内部会图片大小自动压缩)</li><li>支持请求回调，直接返回对象、对象集合</li><li>支持session的保持</li></ol><p><strong>一些类介绍</strong>：</p><ul><li><p>OkHttpClient：</p><p>  OkHttp框架的客户端，是一个用户面板；通过它对OkHttp进行各种设置，网络请求都是通过OkHttpClient完成的，每个OkHttpClient内部都维护了自己的任务队列、连接池、Cache、拦截器等</p></li><li><p>Call：</p><p>  描述一个实际的访问请求，用户的每一个网络请求都是一个Call实例；实际实现是RealCall和AsyncCall</p></li><li><p>Dispatcher：</p><p>  任务调度器，维护了一个线程池，维护了三个双端队列，一个用于同步请求，两个用于异步请求</p></li><li><p>ExchangeCodec：</p><p>  协议层，分别支持HTTP1.1和HTTP2.0，对HTTP请求编码和响应解码</p></li><li><p>Exchange：</p><p>  传输单个HTTP请求和响应对，处理ExchangeCodec这个实际I/O</p></li><li><p>ExchangeFinder：</p><p>  Exchange辅助查找类</p></li><li><p>RealConnection：</p><p>  描述一个物理socket连接，连接池中维护多个RealConnection实例</p></li><li><p>RealConnectionPool：</p><p>  连接池，存储RealConnection连接</p></li><li><p>ConnectionPool：</p><p>  连接池，内部持有RealConnectionPool，通过它来及进行连接池的复用</p></li><li><p>StreamAllocation：</p><p>  由于Http/2支持多路复用，一个RealConnection可以支持多个网络访问请求，所以OkHttp又引入了StreamAllocation来描述一个实际的网络请求开销（从逻辑上一个Stream对应一个Call，但在实际网络请求过程中一个Call常常涉及到多次请求。如重定向，Authenticate等场景。所以准确地说，一个Stream对应一次请求，而一个Call对应一组有逻辑关联的Stream），一个RealConnection对应一个或多个StreamAllocation,所以StreamAllocation可以看做是RealConenction的计数器，当RealConnection的引用计数变为0，且长时间没有被其他请求重新占用就将被释放。</p></li><li><p>Request：</p><p>  请求对象，构造网络请求，包含头部这些</p></li><li><p>Response：</p><p>  响应对象，构造网络响应，包含头部这些</p></li><li><p>Transmitter：</p><p>  发射器，更准确的说是用来通知和调度网络请求的，作用在整个网络请求生命周期；OkHttp的应用程序和网络层之间的桥梁。此类公开高级应用程序层：连接，请求，响应和流；==也是用来计算RealConnection的连接引用，判定是否为空闲连接==</p></li><li><p>RealCall：</p><p>  默认实现的Call对象，同步也是通过它来进行</p></li><li><p>AsyncCall：</p><p>  异步请求对象，执行异步请求</p></li><li><p>RealInterceptorChain：</p><p>  拦截器链对象，操作整个链式，每一次调用一个拦截器</p></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">              .addInterceptor(<span class="keyword">new</span> Interceptor() &#123;&#125;)</span><br><span class="line">              .addNetworkInterceptor(<span class="keyword">new</span> Interceptor() &#123;&#125;)</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">              .url(<span class="string">"http://"</span>)</span><br><span class="line">              .build();</span><br><span class="line">      okHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>一次简单的网络请求大致就这样了，接下来看看具体怎么来进行请求的吧</p><h3 id="OkHttpClient的创建"><a href="#OkHttpClient的创建" class="headerlink" title="OkHttpClient的创建"></a>OkHttpClient的创建</h3><p>首先我们通过Builder模式创建了OkHttpClient，最后发起网络请求的也是它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任务调度器，主要用于控制并发的请求，异步的时候就需要通过它来调度所有的网络请求</span></span><br><span class="line">    Dispatcher dispatcher;</span><br><span class="line">    <span class="comment">//代理类，用于一些代理设置，如Http、socks等</span></span><br><span class="line">    <span class="meta">@Nullable</span> Proxy proxy;</span><br><span class="line">    <span class="comment">//协议集合</span></span><br><span class="line">    List&lt;Protocol&gt; protocols;</span><br><span class="line">    <span class="comment">//连接的配置 如指定Http通过socket连接</span></span><br><span class="line">    List&lt;ConnectionSpec&gt; connectionSpecs;</span><br><span class="line">    <span class="comment">//拦截器集合，拦截器链</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//网络拦截器，针对网络请求的拦截器，比如经常用到了日志拦截器</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//事件监听器</span></span><br><span class="line">    EventListener.Factory eventListenerFactory;</span><br><span class="line">    <span class="comment">//代理选择器</span></span><br><span class="line">    ProxySelector proxySelector;</span><br><span class="line">    <span class="comment">//http cookis 持久化策略</span></span><br><span class="line">    CookieJar cookieJar;</span><br><span class="line">    <span class="comment">//缓存cache</span></span><br><span class="line">    <span class="meta">@Nullable</span> Cache cache;</span><br><span class="line">    <span class="comment">//OkHttp内部缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span> InternalCache internalCache;</span><br><span class="line">    <span class="comment">//socket工厂</span></span><br><span class="line">    SocketFactory socketFactory;</span><br><span class="line">    <span class="comment">//SSL socket工厂</span></span><br><span class="line">    <span class="meta">@Nullable</span> SSLSocketFactory sslSocketFactory;</span><br><span class="line">    <span class="comment">//证书链的清理类 CA证书</span></span><br><span class="line">    <span class="meta">@Nullable</span> CertificateChainCleaner certificateChainCleaner;</span><br><span class="line">    <span class="comment">//对host基本接口的验证</span></span><br><span class="line">    HostnameVerifier hostnameVerifier;</span><br><span class="line">    <span class="comment">//约束的信任证书</span></span><br><span class="line">    CertificatePinner certificatePinner;</span><br><span class="line">    <span class="comment">//代理认证</span></span><br><span class="line">    Authenticator proxyAuthenticator;</span><br><span class="line">    Authenticator authenticator;</span><br><span class="line">    <span class="comment">//连接池 复用连接</span></span><br><span class="line">    ConnectionPool connectionPool;</span><br><span class="line">    <span class="comment">//DNS解析</span></span><br><span class="line">    Dns dns;</span><br><span class="line">    <span class="comment">//SSL重定向</span></span><br><span class="line">    <span class="keyword">boolean</span> followSslRedirects;</span><br><span class="line">    <span class="comment">//重定向</span></span><br><span class="line">    <span class="keyword">boolean</span> followRedirects;</span><br><span class="line">    <span class="comment">//是否失败自动重连</span></span><br><span class="line">    <span class="keyword">boolean</span> retryOnConnectionFailure;</span><br><span class="line">    <span class="comment">//完整调用请求超时时间</span></span><br><span class="line">    <span class="keyword">int</span> callTimeout;</span><br><span class="line">    <span class="comment">//连接超时时间</span></span><br><span class="line">    <span class="keyword">int</span> connectTimeout;</span><br><span class="line">    <span class="comment">//读取数据超时时间</span></span><br><span class="line">    <span class="keyword">int</span> readTimeout;</span><br><span class="line">    <span class="comment">//发送数据超时时间</span></span><br><span class="line">    <span class="keyword">int</span> writeTimeout;</span><br><span class="line">    <span class="comment">//时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> pingInterval;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">      protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">      connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">      eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">      proxySelector = ProxySelector.getDefault();</span><br><span class="line">      <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">        proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">      &#125;</span><br><span class="line">      cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">      socketFactory = SocketFactory.getDefault();</span><br><span class="line">      hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">      certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">      proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">      authenticator = Authenticator.NONE;</span><br><span class="line">      connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">      dns = Dns.SYSTEM;</span><br><span class="line">      followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">      followRedirects = <span class="keyword">true</span>;</span><br><span class="line">      retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">      callTimeout = <span class="number">0</span>;</span><br><span class="line">      connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">      readTimeout = <span class="number">10_000</span>;</span><br><span class="line">      writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">      pingInterval = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Builder(OkHttpClient okHttpClient) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dispatcher = okHttpClient.dispatcher;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder的成员属性注释在代码中了，OkHttpClient基本上跟Builder是对应的；接着在Builder创建的时候，会将这些参数设置一个默认值；还可以通过OkHttpClient来再创建一个</p><ul><li>dispatcher：创建一个Dispatcher，后面看同步、异步的时候会看到</li><li>protocols：默认使用HTTP_1_1（http/1.1）和HTTP_2（http/2）两种HTTP协议</li><li>connectionSpecs：默认连接规格——MODERN_TLS（现代TLS）和CLEARTEXT（明文）</li><li>eventListenerFactory ：默认是一个空实现</li><li>proxySelector：默认是系统代理，如果是null则设置为没有代理（NullProxySelector）</li><li>cookieJar：默认没有cookis（空实现）</li><li>socketFactory：DCL返回的默认socketFactory（DefaultSocketFactory），原始的Java Socket</li><li>hostnameVerifier：默认OkHostnameVerifier</li><li>certificatePinner：默认CertificatePinner</li><li>proxyAuthenticator：默认没有代理认证</li><li>authenticator：默认没有</li><li>connectionPool：创建连接复用池</li><li>dns：默认使用系统的DNS</li><li>followSslRedirects：true表示遵循SSL重定向</li><li>followRedirects：true表示开启普通重定向</li><li>retryOnConnectionFailure：true表示默认开启连接失败后自动重连</li><li>callTimeout ：默认请求超时0</li><li>connectTimeout：默认连接超时时间10_000</li><li>readTimeout：默认读取超时时间10_000</li><li>writeTimeout：默认发送超时时间10_000</li><li>pingInterval：默认时间间隔0</li></ul><p>然后就是通过Builder模式的API我们可以自定义这些设置，下面我们随便看几个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">callTimeout</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">callTimeout = checkDuration(<span class="string">"timeout"</span>, timeout, unit);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interceptor == null"</span>);</span><br><span class="line">      interceptors.add(interceptor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addNetworkInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interceptor == null"</span>);</span><br><span class="line">networkInterceptors.add(interceptor);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>超时时间检验后就直接赋值，拦截器也是直接添加到对应的拦截器集合中，没啥特殊的</p><p>接着看Builder的build方法，创建OkHttpClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OkHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接就是new了OkHttpClient，将Builder作为参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dispatcher = builder.dispatcher;</span><br><span class="line">    <span class="keyword">this</span>.proxy = builder.proxy;</span><br><span class="line">    <span class="keyword">this</span>.protocols = builder.protocols;</span><br><span class="line">    <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</span><br><span class="line">    <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);</span><br><span class="line">    <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);</span><br><span class="line">    <span class="keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;</span><br><span class="line">    <span class="keyword">this</span>.proxySelector = builder.proxySelector;</span><br><span class="line">    <span class="keyword">this</span>.cookieJar = builder.cookieJar;</span><br><span class="line">    <span class="keyword">this</span>.cache = builder.cache;</span><br><span class="line">    <span class="keyword">this</span>.internalCache = builder.internalCache;</span><br><span class="line">    <span class="keyword">this</span>.socketFactory = builder.socketFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isTLS = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;</span><br><span class="line">      isTLS = isTLS || spec.isTls();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (builder.sslSocketFactory != <span class="keyword">null</span> || !isTLS) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;</span><br><span class="line">      <span class="keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      X509TrustManager trustManager = Util.platformTrustManager();</span><br><span class="line">      <span class="keyword">this</span>.sslSocketFactory = newSslSocketFactory(trustManager);</span><br><span class="line">      <span class="keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sslSocketFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Platform.get().configureSslSocketFactory(sslSocketFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;</span><br><span class="line">    <span class="keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</span><br><span class="line">        certificateChainCleaner);</span><br><span class="line">    <span class="keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;</span><br><span class="line">    <span class="keyword">this</span>.authenticator = builder.authenticator;</span><br><span class="line">    <span class="keyword">this</span>.connectionPool = builder.connectionPool;</span><br><span class="line">    <span class="keyword">this</span>.dns = builder.dns;</span><br><span class="line">    <span class="keyword">this</span>.followSslRedirects = builder.followSslRedirects;</span><br><span class="line">    <span class="keyword">this</span>.followRedirects = builder.followRedirects;</span><br><span class="line">    <span class="keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;</span><br><span class="line">    <span class="keyword">this</span>.callTimeout = builder.callTimeout;</span><br><span class="line">    <span class="keyword">this</span>.connectTimeout = builder.connectTimeout;</span><br><span class="line">    <span class="keyword">this</span>.readTimeout = builder.readTimeout;</span><br><span class="line">    <span class="keyword">this</span>.writeTimeout = builder.writeTimeout;</span><br><span class="line">    <span class="keyword">this</span>.pingInterval = builder.pingInterval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interceptors.contains(<span class="keyword">null</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Null interceptor: "</span> + interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (networkInterceptors.contains(<span class="keyword">null</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Null network interceptor: "</span> + networkInterceptors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在OkHttpClient的构造函数中，就是一个简单的赋值和检验</p><p>需要注意的是，如果在Builder中没有配置sslSocketFactory和certificateChainCleaner，那么它们就是null，在OkHttpClient的构造函数中，会进行null判断，为null的时候会通过X509TrustManager去创建对应的默认值</p><p>interceptors和networkInterceptors中是不能包含null的，否则会抛出异常</p><p>至此，配置好各种参数，一个OkHttpClient就创建完成了</p><h3 id="Request的创建"><a href="#Request的创建" class="headerlink" title="Request的创建"></a>Request的创建</h3><p>接着网络请求第二步，创建我们的请求Request，同样是通过Builder模式来创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="meta">@Nullable</span> HttpUrl url;</span><br><span class="line">    <span class="comment">//请求方法</span></span><br><span class="line">    String method;</span><br><span class="line">    <span class="comment">//请求头 Builder</span></span><br><span class="line">    Headers.Builder headers;</span><br><span class="line">    <span class="comment">//请求body</span></span><br><span class="line">    <span class="meta">@Nullable</span> RequestBody body;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Object&gt; tags = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.method = <span class="string">"GET"</span>;</span><br><span class="line">      <span class="keyword">this</span>.headers = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Builder(Request request) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = request.url;</span><br><span class="line">      <span class="keyword">this</span>.method = request.method;</span><br><span class="line">      <span class="keyword">this</span>.body = request.body;</span><br><span class="line">      <span class="keyword">this</span>.tags = request.tags.isEmpty()</span><br><span class="line">          ? Collections.emptyMap()</span><br><span class="line">          : <span class="keyword">new</span> LinkedHashMap&lt;&gt;(request.tags);</span><br><span class="line">      <span class="keyword">this</span>.headers = request.headers.newBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request的Builder就很简单，不像OkHttpClient那么多参数了；默认请求方法method是GEt方法，请求头headers也是直接new的；接着看一下Builder中的API吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">url</span><span class="params">(HttpUrl url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"url == null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">url</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"url == null"</span>);</span><br><span class="line">    <span class="comment">// Silently replace web socket URLs with HTTP URLs.</span></span><br><span class="line">    <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"ws:"</span>, <span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">        url = <span class="string">"http:"</span> + url.substring(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"wss:"</span>, <span class="number">0</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        url = <span class="string">"https:"</span> + url.substring(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url(HttpUrl.get(url));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addHeader</span><span class="params">(String name, String value)</span> </span>&#123;</span><br><span class="line">    headers.add(name, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>先看一下请求头的设置吧，其实很简单，就是通过Headers的Builder去设置</p><p>重点看一下URL的设置吧，通常我们的URL是一个String，那么在Request中确实HttpUrl，那就说明需要进行转换</p><p>首先针对web socket的URL和HTTP的URL做了一个替换，接着通过<code>HttpUrl.get()</code>方法转为HttpUrl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpUrl <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder().parse(<span class="keyword">null</span>, url).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过HttpUrl的Builder进行构造HttpUrl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Builder <span class="title">parse</span><span class="params">(@Nullable HttpUrl base, String input)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos = skipLeadingAsciiWhitespace(input, <span class="number">0</span>, input.length());</span><br><span class="line">    <span class="keyword">int</span> limit = skipTrailingAsciiWhitespace(input, pos, input.length());</span><br><span class="line">    <span class="comment">// Scheme.</span></span><br><span class="line">    <span class="keyword">int</span> schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);</span><br><span class="line">    <span class="keyword">if</span> (schemeDelimiterOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input.regionMatches(<span class="keyword">true</span>, pos, <span class="string">"https:"</span>, <span class="number">0</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">          <span class="keyword">this</span>.scheme = <span class="string">"https"</span>;</span><br><span class="line">          pos += <span class="string">"https:"</span>.length();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.regionMatches(<span class="keyword">true</span>, pos, <span class="string">"http:"</span>, <span class="number">0</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">          <span class="keyword">this</span>.scheme = <span class="string">"http"</span>;</span><br><span class="line">          pos += <span class="string">"http:"</span>.length();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Expected URL scheme 'http' or 'https' but was '"</span></span><br><span class="line">              + input.substring(<span class="number">0</span>, schemeDelimiterOffset) + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scheme = base.scheme;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"Expected URL scheme 'http' or 'https' but no colon was found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Authority.</span></span><br><span class="line">    <span class="keyword">boolean</span> hasUsername = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasPassword = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> slashCount = slashCount(input, pos, limit);</span><br><span class="line">    <span class="keyword">if</span> (slashCount &gt;= <span class="number">2</span> || base == <span class="keyword">null</span> || !base.scheme.equals(<span class="keyword">this</span>.scheme)) &#123;</span><br><span class="line">        pos += slashCount;</span><br><span class="line">        authority:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> componentDelimiterOffset = delimiterOffset(input, pos, limit, <span class="string">"@/\\?#"</span>);</span><br><span class="line">          <span class="keyword">int</span> c = componentDelimiterOffset != limit</span><br><span class="line">              ? input.charAt(componentDelimiterOffset)</span><br><span class="line">              : -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'@'</span>:</span><br><span class="line">              <span class="comment">// User info precedes.</span></span><br><span class="line">              <span class="keyword">if</span> (!hasPassword) &#123;</span><br><span class="line">                <span class="keyword">int</span> passwordColonOffset = delimiterOffset(</span><br><span class="line">                    input, pos, componentDelimiterOffset, <span class="string">':'</span>);</span><br><span class="line">                String canonicalUsername = canonicalize(input, pos, passwordColonOffset, USERNAME_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">this</span>.encodedUsername = hasUsername</span><br><span class="line">                    ? <span class="keyword">this</span>.encodedUsername + <span class="string">"%40"</span> + canonicalUsername : canonicalUsername;</span><br><span class="line">                <span class="keyword">if</span> (passwordColonOffset != componentDelimiterOffset) &#123;</span><br><span class="line">                  hasPassword = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">this</span>.encodedPassword = canonicalize(input, passwordColonOffset + <span class="number">1</span>, componentDelimiterOffset, PASSWORD_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                hasUsername = <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.encodedPassword = <span class="keyword">this</span>.encodedPassword + <span class="string">"%40"</span> + canonicalize(input, pos,</span><br><span class="line">                    componentDelimiterOffset, PASSWORD_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">                    pos = componentDelimiterOffset + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">              <span class="comment">// Host info precedes.</span></span><br><span class="line">              <span class="keyword">int</span> portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);</span><br><span class="line">              <span class="keyword">if</span> (portColonOffset + <span class="number">1</span> &lt; componentDelimiterOffset) &#123;</span><br><span class="line">                        host = canonicalizeHost(input, pos, portColonOffset);</span><br><span class="line">                        port = parsePort(input, portColonOffset + <span class="number">1</span>, componentDelimiterOffset);</span><br><span class="line">                        <span class="keyword">if</span> (port == -<span class="number">1</span>) &#123;</span><br><span class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid URL port: \""</span></span><br><span class="line">                              + input.substring(portColonOffset + <span class="number">1</span>, componentDelimiterOffset) + <span class="string">'"'</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        host = canonicalizeHost(input, pos, portColonOffset);</span><br><span class="line">                        port = defaultPort(scheme);</span><br><span class="line">                  &#125;</span><br><span class="line">              <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            INVALID_HOST + <span class="string">": \""</span> + input.substring(pos, portColonOffset) + <span class="string">'"'</span>);</span><br><span class="line">              &#125;</span><br><span class="line">                  pos = componentDelimiterOffset;</span><br><span class="line">                  <span class="keyword">break</span> authority;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is a relative link. Copy over all authority components. Also maybe the path &amp; query.</span></span><br><span class="line">        <span class="keyword">this</span>.encodedUsername = base.encodedUsername();</span><br><span class="line">        <span class="keyword">this</span>.encodedPassword = base.encodedPassword();</span><br><span class="line">        <span class="keyword">this</span>.host = base.host;</span><br><span class="line">        <span class="keyword">this</span>.port = base.port;</span><br><span class="line">        <span class="keyword">this</span>.encodedPathSegments.clear();</span><br><span class="line">        <span class="keyword">this</span>.encodedPathSegments.addAll(base.encodedPathSegments());</span><br><span class="line">        <span class="keyword">if</span> (pos == limit || input.charAt(pos) == <span class="string">'#'</span>) &#123;</span><br><span class="line">          encodedQuery(base.encodedQuery());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Resolve the relative path.</span></span><br><span class="line">    <span class="keyword">int</span> pathDelimiterOffset = delimiterOffset(input, pos, limit, <span class="string">"?#"</span>);</span><br><span class="line">    resolvePath(input, pos, pathDelimiterOffset);</span><br><span class="line">    pos = pathDelimiterOffset;</span><br><span class="line">    <span class="comment">// Query.</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; limit &amp;&amp; input.charAt(pos) == <span class="string">'?'</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> queryDelimiterOffset = delimiterOffset(input, pos, limit, <span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">this</span>.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(</span><br><span class="line">            input, pos + <span class="number">1</span>, queryDelimiterOffset, QUERY_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">        pos = queryDelimiterOffset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fragment.</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; limit &amp;&amp; input.charAt(pos) == <span class="string">'#'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.encodedFragment = canonicalize(</span><br><span class="line">            input, pos + <span class="number">1</span>, limit, FRAGMENT_ENCODE_SET, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是对String进行解析了，通过字符匹配，最后得到对应的HttpUrl需要的参数，最后通过HttpUrl的Builder的build方法，创建了HttpUrl</p><p>这样，Request中的url就得到了</p><p>先看一下HTTP请求报文结构</p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-d7902f55efac6d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP报文结构"></p><p>再看一下网上找的HTTP请求报文图吧</p><p><img src="http://dl.iteye.com/upload/attachment/0069/3451/412b4451-2738-3ebc-b1f6-a0cc13b9697b.jpg" alt="HTTP请求报文"></p><p><img src="http://dl.iteye.com/upload/attachment/0069/3492/bddb00b6-a3e1-3112-a4f4-4b3cb8687c70.jpg" alt="HTTP相应报文"></p><h3 id="得到Call对象newCall"><a href="#得到Call对象newCall" class="headerlink" title="得到Call对象newCall"></a>得到Call对象newCall</h3><p>接着第三步，通过OkHttpClient的newCall方法得到一个Call对象，然后通过enqueue方法进行网络请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用newCall方法，默认返回了RealCall对象，进行网络请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.transmitter = <span class="keyword">new</span> Transmitter(client, call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建RealCall的时候，需要有OkHttpClient、Request，还有一个布尔值forWebSocket，标识是否为Web Sokcet，从前面知道，默认是false</p><p>然后直接创建了RealCall对象，同时也创建了Transmitter（发射机，OkHttp的应用程序和网络层之间的桥梁）</p><p>在后面的分析前先看看这个Transmitter，这个贯穿了整个网络请求，每一个RealCall都对应着一个Transmitter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//OkHttpClient</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">    <span class="comment">//连接池 RealConnectionPool</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RealConnectionPool connectionPool;</span><br><span class="line">  <span class="comment">//Call对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Call call;</span><br><span class="line">  <span class="comment">//事件监听</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener eventListener;</span><br><span class="line">  <span class="comment">//异步超时计时器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AsyncTimeout timeout = <span class="keyword">new</span> AsyncTimeout() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">timedOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      cancel();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">//call的堆栈</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Object callStackTrace;</span><br><span class="line"><span class="comment">//请求Request</span></span><br><span class="line">  <span class="keyword">private</span> Request request;</span><br><span class="line">  <span class="comment">//Exchange的辅助查找类</span></span><br><span class="line">    <span class="keyword">private</span> ExchangeFinder exchangeFinder;</span><br><span class="line">  <span class="comment">//连接</span></span><br><span class="line">  <span class="keyword">public</span> RealConnection connection;</span><br><span class="line">    <span class="comment">//Exchange，传输单个HTTP请求和响应对。在处理实际的I/O的 ExchangeCodec上的这层连接管理和事件</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Exchange exchange;</span><br><span class="line">    <span class="comment">//请求结束</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> exchangeRequestDone;</span><br><span class="line">  <span class="comment">//响应结束</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> exchangeResponseDone;</span><br><span class="line">    <span class="comment">//是否取消</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line">  <span class="comment">//超时退出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> timeoutEarlyExit;</span><br><span class="line">  <span class="comment">//没有更多的Exchange</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> noMoreExchanges;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Transmitter</span><span class="params">(OkHttpClient client, Call call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());</span><br><span class="line">    <span class="keyword">this</span>.call = call;</span><br><span class="line">    <span class="keyword">this</span>.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Transmitter的构造方法中，得到了OkHttpClient、ConnectionPool、Call等参数，从后面网络请求可以知道，Transmitter维持着整个网络请求的进行和消息通知</p><h3 id="同步请求execute"><a href="#同步请求execute" class="headerlink" title="同步请求execute"></a>同步请求execute</h3><p>如果是同步请求，就是调用execute方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//添加到同步队列</span></span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>executed</code>表示对应的<code>call</code>是否已经执行, 这里同步锁可以避免了竞态条件的出现, 可以看出一个<code>call</code>实例只能被执行一次, 是一个”消耗品”；通过Transmitter来通知和通信，然后这个方法主要做了两件事：一是通过OkHttpClient的dispatcher来进行分发（其实是添加到同步队列，交由Dispatcher分发），二是通过拦截器链进行请求并得到结果</p><ul><li><p>添加到Dispatcher的同步队列</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在Dispatcher中的executed方法，直接调用runningSyncCalls，将RealCall添加进去，runningSyncCalls是一个双端队列，里面保存了每一个同步请求的RealCall对象</p><p>  也就是说，RealCall默认的是一个同步请求的Call</p><p>  execute就是将RealCall添加到Dispatcher的双端队列中，等待执行（其实Dispatcher维护了一个线程池，会在这里调度所有的网络请求，后面讲咯）</p></li><li><p>在看通过拦截器链之前，先看看请求结束后做了什么，不然后面篇幅过长容易忘</p><p>  调用dispatcher的finished方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Dispatcher中有重载的finished方法，不过我们这里自然就是RealCall这个了</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上锁的形式，从runningSyncCalls中移除了RealCall</p><p>  至于后面的isRunning是对异步的一些操作和一些准备工作，后面异步请求再说</p></li><li><p>通过拦截器链：<code>getResponseWithInterceptorChain()</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//自定义拦截器</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//失败重连或重定向拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    <span class="comment">//请求和响应的转换拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//缓存拦截器 从缓存中请求并将响应写入缓存</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//建立连接拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        <span class="comment">//自定义的network拦截器</span></span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个拦截器，处理网络调用服务器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"><span class="comment">//责任链的包装，去调用拦截器</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response = chain.proceed(originalRequest);</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">        closeQuietly(response);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  首先就是添加拦截器，把所有的拦截器都添加到一个集合，自定义的拦截器在前，再加上RetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、CallServerInterceptor等几个，然后通过RealInterceptorChain开始第一个拦截器的调用</p><p>  response是通过<code>chain.proceed(originalRequest)</code>得到，chain就是RealInterceptorChain，跟进去看一下</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    <span class="comment">//一些检查</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">//请求下一个责任链</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">    <span class="comment">//获取当前的拦截器</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">//执行, 返回响应</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"><span class="comment">//后面是一些检查</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  首先就是重载了一次proceed方法，然后还是通过包装RealInterceptorChain，来尽心下一个拦截器的使用，可以注意到这里的index+1，也就是说最后是遍历完整个interceptors集合的，然后就是取出拦截器，通过intercept方法对response进行拦截过滤（这里就留着后面看拦截器的时候再看）</p><p>  整个拦截器链的调用大致如下</p><p>  <img src="https://img-blog.csdnimg.cn/20190604104031300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="拦截器链"></p></li></ul><h3 id="异步请求enqueue"><a href="#异步请求enqueue" class="headerlink" title="异步请求enqueue"></a>异步请求enqueue</h3><p>后面就是执行Call的enqueue方法，那么默认就是RealCall的enqueue方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样交给Dispatcher一个Call，异步就是AsyncCall</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">        <span class="comment">// the same host.</span></span><br><span class="line">        <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">        AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将AsyncCall添加到readyAsyncCalls中，readyAsyncCalls也是一个双端队列，这是一个准备执行状态的请求队列，同时还有一个runningAsyncCalls，就是正在执行状态的请求队列</p><p>然后调用<code>promoteAndExecute()</code>进行调度，将符合条件的从准备状态队列添加到正在执行队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall asyncCall = i.next();</span><br><span class="line"><span class="comment">//判断当前异步请求数是否小于最大请求数 以及 同主机的请求数是否小于每个主机的最大请求数</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">        i.remove();</span><br><span class="line">            asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">            executableCalls.add(asyncCall);</span><br><span class="line">            runningAsyncCalls.add(asyncCall);</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">      AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">      asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历readyAsyncCalls，如果runningAsyncCalls到达最大连接数（maxRequests默认最大64）跳出循环，如果请求主机数达到最大（maxRequestsPerHost默认为5），则将readyAsyncCalls中的请求取出添加到runningAsyncCalls和executableCalls中</p><p>然后遍历executableCalls可执行的Call，调用<code>asyncCall.executeOn(executorService())</code>，其中<code>executorService()</code>方法就是准备线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executorService就是一个线程池，保活是60s，采用SynchronousQueue</p><p>接着回到之前看看AsyncCall的executeOn方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">"executor rejected"</span>);</span><br><span class="line">        ioException.initCause(e);</span><br><span class="line">        transmitter.noMoreExchanges(ioException);</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里主要就是通过executorService线程池来执行当前的AsyncCall请求</p><p>AsyncCall继承自NamedRunnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String oldName = Thread.currentThread().getName();</span><br><span class="line">        Thread.currentThread().setName(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          execute();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          Thread.currentThread().setName(oldName);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamedRunnable实现了Runnable，重写了run方法，在run方法中，调用了抽象方法<code>execute()</code>，具体实现就是我们的AsyncCall，所以线程池执行的代码就是AsyncCall的execute方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">          <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">          Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要的就是通过<code>getResponseWithInterceptorChain()</code>获取Response，这个就跟前面同步请求一样了，通过责任链的方式去调用所有的拦截器，得到response，然后回调</p><p>结束后，调用dispatcher的finished方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    call.callsPerHost().decrementAndGet();</span><br><span class="line">    finished(runningAsyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从runningAsyncCalls移除这个AsyncCall，再次通过<code>promoteAndExecute()</code>来判断调度当前异步请求数是否超过最大请求, 如果没有, 则会从异步请求等待队列中获取出来再进行请求执行</p><h3 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h3><p>整个拦截器调用大致如下，下面我就只分析默认的情况下的拦截器链</p><p><img src="https://img-blog.csdnimg.cn/20190604104031300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="拦截器链"></p><h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><p>通过死循环实现重连，在连接失败后进行重新连接，必要时进行重定向，如果调用被取消，可能会抛出IOException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取Request</span></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    <span class="comment">//拦截器链</span></span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    <span class="comment">//发射器 用于通信</span></span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//通知准备连接 初始化ExchangeFinder等</span></span><br><span class="line">      transmitter.prepareToConnect(request);</span><br><span class="line"><span class="comment">//是否取消 因为transmitter的存在，是可以随时取消，中断网络请求的</span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Response response;</span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过拦截器链，调用下一个拦截器</span></span><br><span class="line">        response = realChain.proceed(request, transmitter, <span class="keyword">null</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//异常情况，通知释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          transmitter.exchangeDoneDueToException();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果前一个有Response，检测前一个Response</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                        .body(<span class="keyword">null</span>)</span><br><span class="line">                        .build())</span><br><span class="line">                .build();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//创建Exchange，传输单个HTTP请求和响应对。这层连接管理和事件</span></span><br><span class="line">      Exchange exchange = Internal.instance.exchange(response);</span><br><span class="line">        <span class="comment">//连接用于到达抽象源服务器的具体路由。创建连接时，客户端有很多选项</span></span><br><span class="line">      Route route = exchange != <span class="keyword">null</span> ? exchange.connection().route() : <span class="keyword">null</span>;</span><br><span class="line">      Request followUp = followUpRequest(response, route);</span><br><span class="line"><span class="comment">//followUp为null，表示不要重定向，释放资源并且返回response</span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; exchange.isDuplex()) &#123;</span><br><span class="line">          transmitter.timeoutEarlyExit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//如果是不可重复的请求体，抛出异常</span></span><br><span class="line">      RequestBody followUpBody = followUp.body();</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="keyword">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      closeQuietly(response.body());</span><br><span class="line">      <span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">        exchange.detachWithViolence();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//最大重定向次数20</span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">      request = followUp;</span><br><span class="line">      priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取到Request、RealInterceptorChain和Transmitter，都是从拦截器链中获取的</p><p>通过死循环</p><ul><li>针对请求Request，通过拦截器链RealInterceptorChain，调用下一个拦截器，出现异常，则通过Transmitter通知并停止该次请求，释放资源</li><li>针对响应Response，检查上次的Response，创建Exchange来传输单个HTTP请求和响应对，结合Route路由；接着就是检查是否需要重定向，是否达到最大重定向次数</li></ul><h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><p>构建访问网络的桥梁，首先，将用户请求转换成网络请求，然后访问网络，最后将网络响应转换成用户响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    <span class="comment">//通过Builder复制一个Request</span></span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"><span class="comment">//将用户的Request构造成服务器的Request</span></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="comment">//请求体存在，进行转换</span></span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">        <span class="comment">//类型这些都很简单明了了</span></span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Host主机</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//保持连接</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Gzip压缩</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//设置Cookies</span></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//传入已构造好的服务器Request，调用下一个拦截器，获取服务器的networkResponse </span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"><span class="comment">//后面是对Response的处理</span></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">        &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">        <span class="comment">//移除一些信息</span></span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">              .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">              .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">              .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">        <span class="comment">//响应体构造为RealResponseBody</span></span><br><span class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先将用户的Request（也就是我们自己构造的Request）复制一份，然后转换请求体，变成服务器需要的请求——主要是请求头的处理；然后通过拦截器链调用下一个拦截器</li><li>针对服务器返回的Response，进行处理和转换，转为用户Response</li></ul><h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><p>缓存拦截器，从缓存中获取服务器请求，或者把服务器响应写入缓存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//获取缓存策略</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"><span class="comment">//从缓存中追踪Response</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果缓存不适用，则关闭</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果网络被禁止，且缓存为空，则返回失败</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">              .request(chain.request())</span><br><span class="line">              .protocol(Protocol.HTTP_1_1)</span><br><span class="line">              .code(<span class="number">504</span>)</span><br><span class="line">              .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">              .body(Util.EMPTY_RESPONSE)</span><br><span class="line">              .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">              .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不需要网络时，从缓存中获取</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">              .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">              .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用下一个拦截者，从网络获取Response</span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 关闭body，防止内存泄露</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果缓存中存在Response，同时检测networkResponse是否被修改</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line">            networkResponse.body().close(); </span><br><span class="line">            <span class="comment">//更新缓存中的数据至最新</span></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构建response </span></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//把之前未缓存的添加至缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">              <span class="comment">// The cache cannot be written.</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><p>打开一个连接，去连接目标服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line">    <span class="comment">//默认GET请求</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">//如果不是，则需要做转换</span></span><br><span class="line">    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"><span class="comment">//调用下一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Transmitter的newExchange去捕获新的Request和Response</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Exchange <span class="title">newExchange</span><span class="params">(Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line"><span class="comment">//连接池</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (noMoreExchanges) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (exchange != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot make a new request because the previous response "</span></span><br><span class="line">            + <span class="string">"is still open: please call response.close()"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取ExchangeCodec对象，对HTTP请求编码和响应解码</span></span><br><span class="line">    ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">//构建转换后的结果，创建了Exchange对象</span></span><br><span class="line">    Exchange result = <span class="keyword">new</span> Exchange(<span class="keyword">this</span>, call, eventListener, exchangeFinder, codec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">this</span>.exchange = result;</span><br><span class="line">      <span class="keyword">this</span>.exchangeRequestDone = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">this</span>.exchangeResponseDone = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExchangeFinder是一个辅助查找Exchange类，看看<code>exchangeFinder.find(client, chain, doExtensiveHealthChecks)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeCodec <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//找到一个可用的健康的连接，如果没有健康安全的连接，则会一直查找直到有为止</span></span><br><span class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">        <span class="comment">//根据具体的resultConnection 创建ExchangeCodec</span></span><br><span class="line">      <span class="keyword">return</span> resultConnection.newCodec(client, chain);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">      trackFailure();</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      trackFailure();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到Connection，RealConnection是整个协议部分，socket、握手等动作；</p><p>先看看如何通过<code>findHealthyConnection()</code>找到连接的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是一个新连接，也需要检查</span></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查，如果不是一个好连接，则从连接池中移除，继续查找</span></span><br><span class="line">      <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        candidate.noNewExchanges();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过死循环，通过<code>findConnection()</code>查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line">    RealConnection result = <span class="keyword">null</span>;</span><br><span class="line">    Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">    RealConnection releasedConnection;</span><br><span class="line">    Socket toClose;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      hasStreamFailure = <span class="keyword">false</span>; <span class="comment">// This is a fresh attempt.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//尝试用已经有了的连接，直接从Transmitter的引用拿去</span></span><br><span class="line">      releasedConnection = transmitter.connection;</span><br><span class="line">        <span class="comment">//releaseConnectionNoEvents方法来判断这个连接是不是已经释放了</span></span><br><span class="line">      toClose = transmitter.connection != <span class="keyword">null</span> &amp;&amp; transmitter.connection.noNewExchanges</span><br><span class="line">              ? transmitter.releaseConnectionNoEvents()</span><br><span class="line">              : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (transmitter.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果不为null，赋给result</span></span><br><span class="line">            result = transmitter.connection;</span><br><span class="line">            releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//为null，尝试从连接池中获取，并将RealConnection和Transmitter关联上，这个方法里如果找到了连接，会将该连接的transmitters（连接引用，Trnsmitter）进行+1</span></span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="keyword">null</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">              foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">              result = transmitter.connection;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//路由</span></span><br><span class="line">              selectedRoute = nextRouteToTry;</span><br><span class="line">             nextRouteToTry = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCurrentRoute()) &#123;</span><br><span class="line">              selectedRoute = transmitter.connection.route();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭socket</span></span><br><span class="line">    closeQuietly(toClose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果result不为null，说明直接从Transmitter中或者从连接池中找到了这个连接，返回</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否需要一个新的路由</span></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">      newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">      routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Route&gt; routes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">            <span class="comment">//重新设置路由后，再一次尝试从连接池获取这个连接</span></span><br><span class="line">            routes = routeSelection.getAll();</span><br><span class="line">            <span class="comment">//具体分析请看后面的连接池部分</span></span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">                address, transmitter, routes, <span class="keyword">false</span>)) &#123;</span><br><span class="line">              foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">              result = transmitter.connection;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//如果还是没有找到连接</span></span><br><span class="line">      <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">              selectedRoute = routeSelection.next();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建一个新的连接</span></span><br><span class="line">            result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">            connectingConnection = result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果第二次从连接池中找到，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时是一个新连接，需要进行connect，进行TCP和TLS握手</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br><span class="line">    <span class="comment">//更新连接池中的路由信息</span></span><br><span class="line">    connectionPool.routeDatabase.connected(result.route());</span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      connectingConnection = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//再次尝试从连接池中获取，避免多线程下重复添加</span></span><br><span class="line">      <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// We lost the race! Close the connection we created and return the pooled connection.</span></span><br><span class="line">            result.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">            socket = result.socket();</span><br><span class="line">            result = transmitter.connection;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新连接，存入连接池</span></span><br><span class="line">            connectionPool.put(result);</span><br><span class="line">            transmitter.acquireConnectionNoEvents(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找连接主要做了以下几件事：</p><ol><li>直接从Transmitter中获取这个连接，看是否能直接获取到；如果没有，进行2</li><li>第一次尝试从连接池中获取连接，将连接关联到对应的Transmitter中；如果没有，进行3</li><li>更新路由信息后，再一次从连接池中获取，关联到Transmitter中；如果没有，进行4</li><li>创建一个新的连接，进行TCP+TLS握手，连接，同时更新连接池中的路由信息</li><li>第三次从连接池中获取，是否有连接存在（这里我想主要是多线程同时创建了这个新连接）；如果没有，则将新连接放入到连接池中；然后返回</li></ol><p>然后我们还需要注意到其中的一个调用，109行<code>transmitter.acquireConnectionNoEvents(result);</code>这是将该Transmitter设置到连接中去，因为每一个连接中有一个引用计数，记的就是Transmitter引用（因为每一个Call是一个Transmitter，就是一次请求，但是可以复用同一个RealConnection）；这行代码主要是针对新连接的调用，那么针对从连接池或者直接从Transmitter获取的连接，也会调用<code>transmitter.acquireConnectionNoEvents(result);</code>这个方法，进行连接引用计数+1，只不过后面的两种是通过连接池去调用的这个方法，具体可以在连接池的<code>connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)</code>中看到，后面连接池有讲到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireConnectionNoEvents</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    connection.transmitters.add(<span class="keyword">new</span> TransmitterReference(<span class="keyword">this</span>, callStackTrace));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要就是将这个连接的引用计数里面再加一次（因为又连接了一次），主要就是通过TransmitterReference的List</p><p>接着<code>resultConnection.newCodec(client, chain)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ExchangeCodec <span class="title">newCodec</span><span class="params">(OkHttpClient client, Interceptor.Chain chain)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (http2Connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Http2ExchangeCodec(client, <span class="keyword">this</span>, chain, http2Connection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      socket.setSoTimeout(chain.readTimeoutMillis());</span><br><span class="line">      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);</span><br><span class="line">      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Http1ExchangeCodec(client, <span class="keyword">this</span>, source, sink);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据connection，返回对应的ExchangeCodec（真正进行I/O流的地方），有HTTP2和HTTP1对应的两种</p><p>回到ConnectInterceptor的intercept方法，获取到新的Request和Response后，调用下一个拦截器</p><h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><p>拦截器链中的最后一个链点，通过网络请求服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Exchange exchange = realChain.exchange();</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//写入请求头</span></span><br><span class="line">    exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//检测是否有body的请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果请求头是"100-continue"，等待服务器的响应</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">            exchange.flushRequest();</span><br><span class="line">            responseHeadersStarted = <span class="keyword">true</span>;</span><br><span class="line">            exchange.responseHeadersStart();</span><br><span class="line">            responseBuilder = exchange.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将请求体转换成sink，并封装在CountingSink 内部</span></span><br><span class="line">            <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">                <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">                exchange.flushRequest();</span><br><span class="line">              BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                  exchange.createRequestBody(request, <span class="keyword">true</span>));</span><br><span class="line">              request.body().writeTo(bufferedRequestBody);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">              BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                  exchange.createRequestBody(request, <span class="keyword">false</span>));</span><br><span class="line">              request.body().writeTo(bufferedRequestBody);</span><br><span class="line">              bufferedRequestBody.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exchange.noRequestBody();</span><br><span class="line">            <span class="keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">              exchange.noNewExchangesOnConnection();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.body() == <span class="keyword">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">      exchange.responseHeadersStart();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//从httpCodec中获取响应头</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构建response</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = response.code();</span><br><span class="line">    <span class="comment">//如果服务器返回的状态码是100，再次尝试读取具体的response</span></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      response = exchange.readResponseHeaders(<span class="keyword">false</span>)</span><br><span class="line">              .request(request)</span><br><span class="line">              .handshake(exchange.connection().handshake())</span><br><span class="line">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      code = response.code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response);</span><br><span class="line"><span class="comment">//如果是WebSocket，并且返回状态码为101，表示响应body为空</span></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//读取body</span></span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果响应头部是"close"，关闭流</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">        || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//协议异常</span></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">          <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接池复用"><a href="#连接池复用" class="headerlink" title="连接池复用"></a>连接池复用</h2><p>当然大量的连接每次连接关闭都要三次握手四次分手的很显然会造成性能低下，因此http有一种叫做keepalive connections的机制，它可以在传输数据后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手</p><p><img src="https://img-blog.csdn.net/20160828174519845" alt="连接复用"></p><p>Okhttp支持5个并发KeepAlive，默认链路生命为5分钟(链路空闲后，保持存活的时间)。</p><p>创建连接池实在OkHttpClient初始化的时候，ConnectinoPool通过直接new出的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> RealConnectionPool delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> maxIdleConnections, <span class="keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = <span class="keyword">new</span> RealConnectionPool(maxIdleConnections, keepAliveDuration, timeUnit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns the number of idle connections in the pool. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">idleConnectionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.idleConnectionCount();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns total number of connections in the pool. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connectionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.connectionCount();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Close and remove all idle connections in the pool. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    delegate.evictAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里就可以看到，默认的是5个并发KeepAlive，默认链路生命是5分钟，直接创建了RealConnectionPool对象</p><h3 id="RealConnectionPool"><a href="#RealConnectionPool" class="headerlink" title="RealConnectionPool"></a>RealConnectionPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnectionPool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">      Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class="line">      <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">"OkHttp ConnectionPool"</span>, <span class="keyword">true</span>));</span><br><span class="line">  <span class="comment">//空闲的socket最大连接数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleConnections;</span><br><span class="line">    <span class="comment">//socket的keepAlive时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveDurationNs;</span><br><span class="line">    <span class="comment">//用来进行自动清理无用的连接</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">          <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">                waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (RealConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    RealConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">//双端队列维护RealConnection</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">//路由数据库，它用来记录连接失败的Route的黑名单，当连接失败的时候就会把失败的线路加进去</span></span><br><span class="line">    <span class="keyword">final</span> RouteDatabase routeDatabase = <span class="keyword">new</span> RouteDatabase();</span><br><span class="line">  <span class="comment">//是否自动回收空闲连接</span></span><br><span class="line">    <span class="keyword">boolean</span> cleanupRunning;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在RealConnectionPool中维护了一个线程池，来进行回收和复用；connections是一个记录连接的双端队列；routeDatabase是记录路由失败的线路，cleanupRunnable是用来进行自动回收连接的。</p><p>然后我们重点看一下cleanupRunnable：首先是一个死循环，一直执行，通过cleanup方法进行回收连接，并返回了下次清理的间隔时间（以纳米为单位，下次调用这个方法的时间），-1表示不需要再进行回收，则跳出循环，否则一直进行回收，同时让连接池RealConnectionPool等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//遍历所有的连接</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            RealConnection connection = i.next();</span><br><span class="line">            <span class="comment">//判断是否正在使用 </span></span><br><span class="line">            <span class="comment">//查询此连接的StreamAllocation的引用数量，如果大于0则inUseConnectionCount数量加1，否则idleConnectionCount加1</span></span><br><span class="line">            <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              inUseConnectionCount++;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            idleConnectionCount++;</span><br><span class="line">            <span class="comment">//确定这个连接需要进行回收 标记连接</span></span><br><span class="line">            <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">            <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">              longestIdleDurationNs = idleDurationNs;</span><br><span class="line">              longestIdleConnection = connection;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//如果空闲连接keepAlive时间超过5分钟，或者空闲连接数超过5个，则从Deque中移除此连接</span></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">            <span class="comment">//从connections中移除</span></span><br><span class="line">            connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果空闲连接大于0，则返回此连接即将到期的时间</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有空闲连接，并且活跃连接大于0则返回5分钟</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没有连接</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据连接中的引用计数来计算空闲连接数和活跃连接数，然后标记出空闲的连接，如果空闲连接keepAlive时间超过5分钟，或者空闲连接数超过5个，则从Deque中移除此连接。接下来根据空闲连接或者活跃连接来返回下次需要清理的时间数：如果空闲连接大于0则返回此连接即将到期的时间，如果都是活跃连接并且大于0则返回默认的keepAlive时间5分钟，如果没有任何连接则跳出循环并返回-1</p><p>看看怎么来判断活跃连接的1<code>pruneAndGetAllocationCount()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    List&lt;Reference&lt;Transmitter&gt;&gt; references = connection.transmitters;</span><br><span class="line">    <span class="comment">//遍历引用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">      Reference&lt;Transmitter&gt; reference = references.get(i);</span><br><span class="line"><span class="comment">//如果还在使用</span></span><br><span class="line">      <span class="keyword">if</span> (reference.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// We've discovered a leaked transmitter. This is an application bug.</span></span><br><span class="line">      TransmitterReference transmitterRef = (TransmitterReference) reference;</span><br><span class="line">      String message = <span class="string">"A connection to "</span> + connection.route().address().url()</span><br><span class="line">          + <span class="string">" was leaked. Did you forget to close a response body?"</span>;</span><br><span class="line">      Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);</span><br><span class="line"><span class="comment">//如果没有使用，则移除</span></span><br><span class="line">      references.remove(i);</span><br><span class="line">      connection.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果列表为空则说明此连接没有被引用了，则返回0，表示此连接是空闲连接</span></span><br><span class="line">      <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">        connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则还有引用</span></span><br><span class="line">    <span class="keyword">return</span> references.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历RealConnection的transmitters列表，通过前面，我们知道每一次Call都会有一个Transmitter，这就对应着这个连接是否是空闲的，Transmitter越多，代表Call越多，连接次数越多，transmitters不为空，就不是空闲连接是活跃连接</p><p>回到cleanup方法，我们看看最后的<code>closeQuietly(longestIdleConnection.socket())</code>关闭连接</p><p>在Utils中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeQuietly</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAndroidGetsocknameError(e)) <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RuntimeException rethrown) &#123;</span><br><span class="line">        <span class="keyword">throw</span> rethrown;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就很简单了，关闭套接字Socket就可以了</p><p>这样，一个空闲连接就被回收关闭了</p><h3 id="缓存操作"><a href="#缓存操作" class="headerlink" title="缓存操作"></a>缓存操作</h3><ul><li><p>put</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">      cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">      executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    connections.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  put操作就很简单，根据cleanupRunning判断是否在进行自动回收，没有则先通过线程池执行cleanupRunnable进行回收，然后将连接connection添加到双端队列connections中</p></li><li><p>get</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">transmitterAcquirePooledConnection</span><span class="params">(Address address, Transmitter transmitter,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable List&lt;Route&gt; routes, <span class="keyword">boolean</span> requireMultiplexed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed()) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">continue</span>;</span><br><span class="line">      transmitter.acquireConnectionNoEvents(connection);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个方法就是尝试从连接池中获取连接；遍历connections，根据address和route来判断是不是所需要的连接，如果找到了对应的连接，就放到对应的Transmitter中，返回true，否则返回false</p><p>  找到连接后，会调用<code>transmitter.acquireConnectionNoEvents(connection);</code>将这个连接的引用次数+1</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireConnectionNoEvents</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    connection.transmitters.add(<span class="keyword">new</span> TransmitterReference(<span class="keyword">this</span>, callStackTrace));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  创建了一个TransmitterReference引用，添加到连接的transmitters中</p><p>  <code>final List&lt;Reference&lt;Transmitter&gt;&gt; transmitters = new ArrayList&lt;&gt;();</code></p><p>  这个transmitters就是一个连接引用的list，记录所有引用这个连接的Transmitter</p></li><li><p>关闭所有空闲连接</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;RealConnection&gt; evictedConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line">        <span class="keyword">if</span> (connection.transmitters.isEmpty()) &#123;</span><br><span class="line">              connection.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">              evictedConnections.add(connection);</span><br><span class="line">              i.remove();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : evictedConnections) &#123;</span><br><span class="line">      closeQuietly(connection.socket());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  取出所有空闲连接，然后通过closeQuietly关闭</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次不想写总结了，直接放图吧，太多了</p><p><img src="https://img-blog.csdnimg.cn/20190605100153475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="OkHttp3"></p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><ul><li><a href="https://blog.csdn.net/u010256388/article/details/68491509" target="_blank" rel="noopener">HTTP请求行、请求头、请求体详解</a></li><li><a href="https://xiaozhuanlan.com/topic/4023695781" target="_blank" rel="noopener">okHttp3源码解析(一)</a></li><li><a href="https://juejin.im/post/5af93575518825426539917b" target="_blank" rel="noopener">OkHttp3 源码解析执行流程</a></li><li><a href="https://blog.csdn.net/itachi85/article/details/52085256" target="_blank" rel="noopener">Android网络编程（七）源码解析OkHttp前篇 请求网络</a></li><li><a href="https://blog.csdn.net/itachi85/article/details/52335403" target="_blank" rel="noopener">Android网络编程（八）源码解析OkHttp后篇[复用连接池]</a></li><li><a href="https://blog.csdn.net/zhangqiluGrubby/article/details/80169374" target="_blank" rel="noopener">Android OkHttp3源码详解——整体框架</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Retrofit2源码分析</title>
      <link href="/2019/06/02/Andorid%20Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/02/Andorid%20Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="Android-Retrofit2源码分析"><a href="#Android-Retrofit2源码分析" class="headerlink" title="Android Retrofit2源码分析"></a>Android Retrofit2源码分析</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Retrofit2是Retrofit的一个升级版，底层基于OkHttp3的一个网络请求框架，更直白的说，Retrofit2就是对OkHttp3的一种封装，可以让使用者避免很多重复的网络请求代码，同时灵活性很高，可以自定义OkHttpClient、数据转换器、请求转换器等</p><p>在Retrofit2中的改进</p><ul><li><p>使用了运行时注解，可以根据需要来将业务调用接口转换成Http请求接口</p></li><li><p>可以取消正在进行中的业务，Service的模式变成Call的形式</p></li><li><p>Converter从Retrofit2中删除，通过addConverterFactory来添加转换器</p></li><li><p>需要OkHttp的支持，网络请求完全由OkHttp3进行</p><p><strong>看一下一些重要的类</strong></p></li><li><p>Call：interface，向服务器发送请求并返回响应的调用</p></li><li><p>CallAdapter：interface，Call的适配器，用来包装Call</p></li><li><p>CallBack：interface，Call执行时的回调</p></li><li><p>Converter：interface，数据转换器，将一个对象转换为另一个对象</p></li><li><p>CallAdapter.Factory：abstract class，数据转换器Converter的工厂，可以转换结果和请求</p></li><li><p>RequestFactory：class，创建OkHttp请求的Request，通过解析Method</p></li><li><p>RequestFactoryParser ：class，解析网络请求方法的注解和参数，生成RequestFactory。（会用到requestBodyConverter，stringConverter）</p></li><li><p>OkHttpCall：class，实现Call接口，获取传入的Call（代理Call，通过Retrofit.callFactory生成的）执行请求，实际上内部会创建一个okhttp3.Call进行真正的网络请求，获取数据并使用responseConverter进行解析</p></li><li><p>Retrofit：class，整个网络请求的配置和控制，产生动态代理对象的地方</p></li><li><p>Retrofit.Builder：class，Builder模式创建Retrofit</p></li><li><p>ServiceMethod：cabstract lass，每一个网络请求方法就会对应已给ServiceMethod，在2.5.0中，具体实现采用了HttpServiceMethod进行了一个解耦</p></li><li><p>HttpServiceMethod：class，ServiceMethod的实现类，对应每一次网络请求，每一次请求都会通过动态代理，调用invoke方法，最后得到对应的Call对象，持有Retrofit的引用，并通过Retrofit和Method得到CallAdapterFactory和ConverterFactory（responseConverter）</p></li><li><p>Platform：class，平台对象，主要有Android、Java；用于获取一些默认值，比如CallAdapterFactory、ConverterFactory以及线程切换的Executor</p></li><li><p>ExecutorCallAdapterFactory：class，默认的CallAdapterFactory</p></li><li><p>ExecutorCallbackCall：class，一个Call对象 ，是ExecutorCallAdapterFactory的内部类，默认得到的Call；在调用时，内部的Call对象取决与invoke方法中的实例化，默认是OkHttpCall</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2019060320361839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="Retrofit2"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>业务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String BASE_URL = <span class="string">"http://"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建retrofit，通过Builder模式</span></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">               .baseUrl(ApiService.BASE_URL)</span><br><span class="line">       <span class="comment">//设置OkClient 默认会自己new一个 可以不用配置</span></span><br><span class="line">               .client(<span class="keyword">new</span> OkHttpClient())</span><br><span class="line">       <span class="comment">//对数据的转换 GSON 可以不用</span></span><br><span class="line">               .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">       <span class="comment">//对RxJava2的适配，可以不用</span></span><br><span class="line">               .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">               .build();</span><br><span class="line"><span class="comment">//创建接口对象ApiService</span></span><br><span class="line">ApiService apiService = retrofit.create(ApiService.class);</span><br><span class="line">Call&lt;User&gt; userCall = apiService.getUser();</span><br><span class="line">   userCall.enqueue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;User&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>这就是一个正常的请求流程了</p><h3 id="Retrofit的创建"><a href="#Retrofit的创建" class="headerlink" title="Retrofit的创建"></a>Retrofit的创建</h3><p>首先我们就来看看Retrofit的创建</p><p>Retrofit的创建很明显就是通过Builder模式来构造的，通过Builder模式来设置需要的参数，最后通过build进行创建</p><p>先看看Builder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">//平台，可以获取很多默认参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">        <span class="comment">//okhhtp3的</span></span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> HttpUrl baseUrl;</span><br><span class="line">        <span class="comment">//存储converters 转化数据</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储callAdapters 对call进行转化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//传递回调到ui线程</span></span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">        Builder(Platform platform) &#123;</span><br><span class="line">          <span class="keyword">this</span>.platform = platform;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>(Platform.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过Retrofit构建</span></span><br><span class="line">        Builder(Retrofit retrofit) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//配置OkClient</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">client</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> callFactory(checkNotNull(client, <span class="string">"client == null"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//配置callFactory</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">callFactory</span><span class="params">(okhttp3.Call.Factory factory)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.callFactory = checkNotNull(factory, <span class="string">"factory == null"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//请求地址 一个Retrofit一个url</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(String baseUrl)</span> </span>&#123;</span><br><span class="line">          checkNotNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">          <span class="keyword">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class="line">          checkNotNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">          List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class="line">          <span class="keyword">if</span> (!<span class="string">""</span>.equals(pathSegments.get(pathSegments.size() - <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"baseUrl must end in /: "</span> + baseUrl);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//转换器工厂</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addConverterFactory</span><span class="params">(Converter.Factory factory)</span> </span>&#123;</span><br><span class="line">          converterFactories.add(checkNotNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//适配器工厂</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class="line">          callAdapterFactories.add(checkNotNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">callbackExecutor</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.callbackExecutor = checkNotNull(executor, <span class="string">"executor == null"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//创建Retrofit实例</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">            <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">          <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//有一个默认实现 根据platform</span></span><br><span class="line">              callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">          &#125;</span><br><span class="line">          List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories); </span><br><span class="line">            <span class="comment">//默认实现的callAdapter</span></span><br><span class="line">  callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line">          List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line"> <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">          converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">          converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">          converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Retrofit的Builder是一个静态内部类，通过Builder，我们可以配置以下</p><ul><li><p>converterFactory：针对数据，对数据转换</p></li><li><p>callAdapterFactory：针对call，对call进行转化</p></li><li><p>callbackExecutor：用来将回调传递到UI线程；</p><p>  利用platform对象，对平台进行判断，判断主要是利用Class.forName(“”)进行查找，如果是Android平台，会自定义一个Executor对象，并且利用Looper.getMainLooper()实例化一个handler对象，在Executor内部通过handler.post(runnable)</p></li><li><p>okHttpClient：肯定需要啊，进行网络请求</p></li><li><p>baseUrl：最重要的，请求地址</p></li><li><p>validateEagerly：在调用时的验证配置的标志量，不设置为null</p></li></ul><p>在配置Factories的时候，可以设置多个，然后是放在其对应的list中的</p><p>最后<code>build()</code>方法new出了一个Retrofit，并将参数通过Retrofit的构造方法传进去</p><p><strong>这里需要注意的是</strong>如果baseUrl为null，会抛出异常；如果没有设置callFactory，则默认直接<code>new OkHttpClient()</code>；如果没有设置callbackExecutor，就会通过platform来获取一个默认的；然后将callAdapterFactories添加到一个新的list中（如果没有配置callAdapterFactory，就会根据platform获取默认的实现——ExecutorCallAdapterFactory）；同样将conerterFactories添加到新的list中，同时添加了默认的几个（如BuiltInConverters和从platform中获取的）</p><p>我们来看看这些默认值的获取，毕竟我们可以不设置这些参数</p><ul><li><p>首先就是platform是啥</p><p>  platform是我们Retrofit运行的平台，在创建Builder的时候得到的</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(Platform.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  接着看看这个具体的get方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line"> &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过get方法获取的是Platform的单例，最后是通过<code>findPlatform()</code>来获取的</p><p>  在<code>findPlatform()</code>中，通过Class.forName(“”)进行查找，如果是Android平台，返回了一个Android平台的Platform（就是继承自Platform的内部类，Java也是同样的），如果是Java平台，返回的是Java8的，否则返回一个什么都没实现的Platform（通过查看源码可以知道，很多方法返回的都是null）</p><p>  主要看看Android平台的</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Platform.Android这个内部类继承自Platform，根据特性，进行自己的方法实现，具体我们就看后面的吧</p></li><li><p><code>callbackExecutor = platform.defaultCallbackExecutor()</code>这个时候就应该是Platform.Android中的<code>defaultCallbackExecutor()</code>方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="function">Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>defaultCallbackExecutor()</code>方法new了一个MainThreadExecutor，这个类继承子Executor，同时持有了主线程的Looper，然后通过post方法，将回调传递到UI线程</p></li><li><p><code>platform.defaultCallAdapterFactories(callbackExecutor)</code>方法，同上</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories(</span><br><span class="line">        <span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line"><span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">ExecutorCallAdapterFactory executorFactory = <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line"><span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span></span><br><span class="line">        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)</span><br><span class="line">        : singletonList(executorFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  由于前面的callbackExecutor 是MainThreadExecutor，所以不会抛出异常，同时创建了ExecutorCallAdapterFactory，根据Android的版本做了一些调整，大于24的则多了一个CompletableFutureCallAdapterFactory，这里就不继续看这两个CallAdapter的实现了，后面会看到，到时候我们再继续看</p></li><li><p><code>platform.defaultConverterFactories()</code>，同上</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> List&lt;? extends Converter.Factory&gt; defaultConverterFactories() &#123;</span><br><span class="line">      <span class="keyword">return</span> Build.VERSION.SDK_INT &gt;= <span class="number">24</span></span><br><span class="line">          ? singletonList(OptionalConverterFactory.INSTANCE)</span><br><span class="line">          : Collections.&lt;Converter.Factory&gt;emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  根据Android API是否大于等于24返回，24及以上版本的，返回了OptionalConverterFactory。以下的，返回了一个空的</p></li></ul><p>接着看看Retrofit的的一些成员属性和构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ServiceMethod缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">    <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, </span><br><span class="line">             List&lt;Converter.Factory&gt; converterFactories, </span><br><span class="line">             List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">      <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="keyword">boolean</span> validateEagerly) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Retrofit的创建我们就看这么多</p><h3 id="创建接口对象"><a href="#创建接口对象" class="headerlink" title="创建接口对象"></a>创建接口对象</h3><p>获取到Retrofit后，通过Retrofit的<code>create()</code>方法，我们得到了ApiService</p><p>我们就看看这个create方法做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="comment">//创建Retrofit时配置的，默认null</span></span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">        eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回动态代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这是是针对API大于等于24的时候的一个优化</span></span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就比较关键了，<code>create()</code>方法根据传进来的接口ApiService直接返回了一个动态代理对象，这是Java中的动态代理；当我们调用ApiSerivce时就会调用代理对象的<code>invoke()</code>方法</p><p>这后面就跟2.4.0版本有所不同了，但大致的思想是没变了得</p><p>在invoke方法中，最后返回了<code>loadServiceMethod(method).invoke(args != null ? args : emptyArgs);</code>它，来看看是个啥吧</p><p><code>loadServiceMethod(method)</code>就是Retrofit中的一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">       ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">       <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">         result = serviceMethodCache.get(method);</span><br><span class="line">         <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">           result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">           serviceMethodCache.put(method, result);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，通过Method，最后返回了一个ServiceMethod对象，这个就和之前2.0版本的ServiceMethod对应了</p><p>在这个方法中，先是通过method在serviceMethodCache去获取ServiceMethod；serviceMethodCache就是我们前面看Retrofit中的一个Map成员属性，是一个ConcurrentHashMap，Method为key，ServiceMethod为value的缓存；如果result（ServiceMethod）不为null就直接返回，否则就要根据这个Method进行创建一个ServiceMethod</p><p>首先，synchronized再一次对serviceMethodCache加锁，保证安全，再一次确定缓存中没有对应的ServiceMethod才会去通过<code>ServiceMethod.parseAnnotations(this, method)</code>创建，然后存入缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据注解解析出</span></span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"></span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceMethod现在是一个抽象类（记得2.4.0不是的），<code>parseAnnotations()</code>方法中，先是获取了requestFactory，先来看看这个<code>RequestFactory.parseAnnotations(retrofit, method);</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">      <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">      <span class="keyword">this</span>.method = method;</span><br><span class="line">      <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">      <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">      <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是通过builder模式创建了RequestFactory，通过Method解析了注解、参数类型、参数注解等</p><p>最后通过<code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</code>创建了一个ServiceMethod并返回</p><p>ServiceMethod中的invoke方法是一个抽象方法，稍后会讲到</p><p>接着看一下<code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">"'"</span></span><br><span class="line">          + Utils.getRawType(responseType).getName()</span><br><span class="line">          + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (requestFactory.httpMethod.equals(<span class="string">"HEAD"</span>) &amp;&amp; !Void.class.equals(responseType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">"HEAD method must use Void as response type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HttpServiceMethod的parseAnnotations方法中（这还是个static方法），根据retrofit和method先后获取了callAdapter、responseType、responseConverter、okClient</p><ul><li><p>createCallAdapter</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">      <span class="keyword">throw</span> methodError(method, e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  根据Method的返回类型和注解，从retrofit中取出了对应的callAdapter</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(<span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">      Annotation[] annotations) &#123;</span><br><span class="line">    checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在retrofit中通过nextCallAdapter来获取CallAdapter，遍历callAdapterFactories中的所有CallAdapter，返回符合条件的CallAdapter，从前面Retrofit的创建知道，如果没有设置，则会获取默认的ExecutorCallAdapterFactory</p></li><li><p>createResponseConverter</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, Type responseType)</span> </span>&#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">      <span class="keyword">throw</span> methodError(method, e, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  根据Method的注解和response类型，从retrofit中获取了responseConverter结果转换器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">          converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  responseConverter也是同样的方式，遍历所有的converter，从converterFactories返回符合的responseConverter，如果没有设置，则会获取默认的null（API&gt;=24是一个OptionalConverterFactory），这可以从前面Retrofit的创建知道</p></li></ul><p>在HttpServiceMethod的parseAnnotations方法最后，直接new了HttpServiceMethod，这就是现在关键的大BOSS了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceMethod</span>&lt;<span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HttpServiceMethod</span><span class="params">(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">          CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter,</span></span></span><br><span class="line"><span class="function"><span class="params">          Converter&lt;ResponseBody, ResponseT&gt; responseConverter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">        <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">        <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">        <span class="keyword">this</span>.responseConverter = responseConverter;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这还是私有的构造方法，也就意味着我们只能通过前面的方式来构建HttpServiceMethod，然后保留了这些参数requestFacotry、callFactory、callAdapter、responseConverter等</p><p>从HttpServiceMethod的继承关系来看，继承自ServiecMethod，所以前面一连串的调用下来，最后返回了HttpServiceMethod</p><p>回到前面Retrofit的<code>create()</code>方法，现在我们知道了<code>loadServiceMethod(method)</code>方法就是返回了一个ServiceMethod（具体实现是HttPServiceMethod），在Retrofit的<code>create()</code>方法中，通过动态代理得到动态代理对象，会调用invoke方法，invoke方法返回的是<code>loadServiceMethod(method).invoke(args != null ? args : emptyArgs)</code>，现在我们就知道后面调用的invoke方法是ServiceMethod中的invoke方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面创建ServiceMethod的时候，我们知道真正实现是HttpServiceMethod，那就接着看HttpServiceMethod的invoke方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callAdapter.adapt(</span><br><span class="line">        <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HttpServiceMethod的invoke方法中，创建了一个OkHttpCall（网络请求需要）到callAdapter中，将OkHttpCall通过callAdapter转化为需要的Call并返回（例如<code>getUser()</code>方法。需要的Call是<code>Call&lt;User&gt;</code>，那就创建ServiceMethod的时候就是User这个泛型，最后返回的就是<code>Call&lt;User&gt;</code>），如果我们前面Retrofit通过Builder设置了<code>addCallAdapterFactory(RxJava2CallAdapterFactory.create())</code>，那么返回的就是RxJava2对应的Call，就可以很好的配合RxJava2使用，这就不得不感叹适配器模式的伟大</p><p>在这里我们知道是new了一个OkHttpCall的，接着就create这个方法就完了。通过<code>ApiService.getUser()</code>来调用<code>getUser()</code>方法，会生成对应的动态代理对象，调用接口中对应的方法，通过注解等获取<code>getUser()</code>的参数、返回类型等信息，最终得到一个需要的Call对象</p><p>从前面分析知道，callAdapter在Retrofit创建时没有配置的话，也会有一个默认的CallAdapterFactory——ExecutorCallAdapterFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> responseType;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在ExecutorCallAdapterFactory的adapt方法，返回了ExecutorCallbackCall，这个类是ExecutorCallAdapterFactory的内部类，一个Call的实现类</p><p>然后我们关心一下ExecutorCallbackCall的几个参数：callbackExecutor，这个是在创建Retrofit时通过Platform得到的，并借此实例化了ExecutorCallAdapterFactory；call，就是前面的OkHttpCall了，里面拥有了配置的requestFactory，callFactory,，responseConverter和方法参数等</p><h3 id="执行enqueue"><a href="#执行enqueue" class="headerlink" title="执行enqueue"></a>执行enqueue</h3><p>拿到了Call对象，就是进行网络请求了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userCall.enqueue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;User&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>调用enqueue方法，同时设置回调Callback</p><p>Call是一个接口，我们要找到具体的实现类，通过前面的分析，我们最后的Call是ExecutorCallAdapterFactory的内部类ExecutorCallbackCall，它持有了new出的OkHttpCall以及传递回调的callbackExecutor（拥有主线程的Looper）</p><p>接着就看看ExecutorCallbackCall吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isExecuted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      delegate.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isCanceled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>) <span class="comment">// Performing deep clone.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重点关注我们的enqueue方法，又调用了<code>delegate.enqueue()</code>方法，同时通过匿名实现方式，创建了Callback的回调，再回调到我们传进来的Callback中；那这个delegate又是什么，就是一个Call对象？</p><p>别忘了ExecutorCallbackCall怎么实例化的，前面提到，这个delegate其实就是我们的OhHttpCall</p><p>这就好理解了，通过OkHttpCall去进行网络请求</p><h3 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h3><p>看看OkHttpCall中的enqueue方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//拿到OkHttp3.Call</span></span><br><span class="line">      call = rawCall;</span><br><span class="line">      failure = creationFailure;</span><br><span class="line">      <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//第一次需要创建call</span></span><br><span class="line">                call = rawCall = createRawCall();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                throwIfFatal(t);</span><br><span class="line">                failure = creationFailure = t;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//失败回调</span></span><br><span class="line">    <span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">      callback.onFailure(<span class="keyword">this</span>, failure);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//取消</span></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过OkHttp3.Call执行</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//解析返回结果</span></span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          throwIfFatal(e);</span><br><span class="line">          callFailure(e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建OkHttp3-Call"><a href="#创建OkHttp3-Call" class="headerlink" title="创建OkHttp3.Call"></a>创建OkHttp3.Call</h4><p>在这个方法中，首先是通过synchronized代码块来获取到OkHttp3.Call，如果为null，就通过<code>createRawCall()</code>来创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Call.Factory returned null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callFactory是在OkHttpCall实例化的时候，Retrofit配置的时候设置的OkClient，通过newCall方法创建；requestFactory.create(args)得到了okhttp3.Request对象；requestFactory又是我们在生成HttpServiceMethod（具体应该在ServiceMethod中）时，创建出来的，args就是我们Method中的方法参数了（动态代理对象调用方法的参数，invoke传入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">okhttp3.<span class="function">Request <span class="title">create</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// It is an error to invoke a method with the wrong arg types.</span></span><br><span class="line">    ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> argumentCount = args.length;</span><br><span class="line">    <span class="keyword">if</span> (argumentCount != handlers.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Argument count ("</span> + argumentCount</span><br><span class="line">          + <span class="string">") doesn't match expected count ("</span> + handlers.length + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建了RequestBuilder</span></span><br><span class="line">    RequestBuilder requestBuilder = <span class="keyword">new</span> RequestBuilder(httpMethod, baseUrl, relativeUrl,</span><br><span class="line">        headers, contentType, hasBody, isFormEncoded, isMultipart);</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; argumentList = <span class="keyword">new</span> ArrayList&lt;&gt;(argumentCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; argumentCount; p++) &#123;</span><br><span class="line">      argumentList.add(args[p]);</span><br><span class="line">      handlers[p].apply(requestBuilder, args[p]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过RequestBuilder创建Request</span></span><br><span class="line">    <span class="keyword">return</span> requestBuilder.get()</span><br><span class="line">        .tag(Invocation.class, <span class="keyword">new</span> Invocation(method, argumentList))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着回到OkHttpCall中的enqueue方法，看第二步解析结果</p><h4 id="解析返回结果"><a href="#解析返回结果" class="headerlink" title="解析返回结果"></a>解析返回结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">Response&lt;T&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          throwIfFatal(e);</span><br><span class="line">          callFailure(e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          t.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过OkHttp3的Call执行真正的网络请求，最后结果会通过okhttp3.Callback回调，接着调用的是<code>response = parseResponse(rawResponse);</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">        .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//获取code码，判定错误，抛出</span></span><br><span class="line">    <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">    <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">        ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">        <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rawBody.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//204和205关闭流，但是访问是成功的</span></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">      <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//包装一下Response</span></span><br><span class="line">    ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过我们在HttpServiceMethod中设置的responseConverter再进行解析，进行数据转换</span></span><br><span class="line">      T body = responseConverter.convert(catchingBody);</span><br><span class="line">      <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      catchingBody.throwIfCaught();</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析结果的时候，会先进行一些状态码的判断，然后通过包装一层ResponseBody，再交给我们HttpServiceMethod中的responseConverter解析成对应的数据类型，然后返回，通过前面的callback回调到</p><p>我们看看默认的BuiltInConverters</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">      Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == ResponseBody.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class="line">          ? StreamingResponseBodyConverter.INSTANCE</span><br><span class="line">          : BufferingResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == Void.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkForKotlinUnit) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == Unit.class) &#123;</span><br><span class="line">          <span class="keyword">return</span> UnitResponseBodyConverter.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoClassDefFoundError ignored) &#123;</span><br><span class="line">        checkForKotlinUnit = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) &#123;</span><br><span class="line">      <span class="keyword">return</span> RequestBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>requestBodyConverter方法就根据判断，返回不同类型的RequestBody，比如Void型、Unit型、或者不变的；从下面的convert方法就可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VoidResponseBodyConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> VoidResponseBodyConverter INSTANCE = <span class="keyword">new</span> VoidResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Void <span class="title">convert</span><span class="params">(ResponseBody value)</span> </span>&#123;</span><br><span class="line">      value.close();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitResponseBodyConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">Unit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> UnitResponseBodyConverter INSTANCE = <span class="keyword">new</span> UnitResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Unit <span class="title">convert</span><span class="params">(ResponseBody value)</span> </span>&#123;</span><br><span class="line">      value.close();</span><br><span class="line">      <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBodyConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">RequestBody</span>, <span class="title">RequestBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> RequestBodyConverter INSTANCE = <span class="keyword">new</span> RequestBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> RequestBody <span class="title">convert</span><span class="params">(RequestBody value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingResponseBodyConverter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StreamingResponseBodyConverter INSTANCE = <span class="keyword">new</span> StreamingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferingResponseBodyConverter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> BufferingResponseBodyConverter INSTANCE = <span class="keyword">new</span> BufferingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">        <span class="keyword">return</span> Utils.buffer(value);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        value.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">Object</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ToStringConverter INSTANCE = <span class="keyword">new</span> ToStringConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看每一个convert方法，对应着不同的实现，</p><h3 id="2-5-0和之前版本的区别"><a href="#2-5-0和之前版本的区别" class="headerlink" title="2.5.0和之前版本的区别"></a>2.5.0和之前版本的区别</h3><ul><li>抽离了ServiceMethod，使用了具体实现HttpServiceMethod，减轻了ServiceMethod的负重，更多的放到了HttpServiceMethod中，以及通过层层参数的传递，进行了解耦</li><li>不管是CallAdapter还是ResponseConverter都是再创建HttpServiceMethod时都从Retrofit中找出，存放到自己HttpServiceMethod中</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Retrofit的创建：</p><p>  通过Builder模式，设置请求地址url，选择性设置callbackExecutor、client、callAdapterFactory、converterFactory等，通过build方法创建Retrofit，同时设置配置的参数</p><p>  如果没有设置client（OkClient）、callbackExecutor（将回调接口传递到UI线程）、callAdapterFactory（call适配器工厂）、converterFactory（结果转换器工厂）等；client默认是new一个OkClient对象；callbackExecutor是通过Platform获取的默认值，具体是通过Android平台的Platform得到的一个拥有主线程Looper的Executor；callAdapterFactory是通过Platform和callbackExecutor得到的一个默认实现ExecutorCallAdapterFactory，如果API 大于等于24，还会有一个CompletableFutureCallAdapterFactory；converterFactory也是通过Android的Platform得到一个默认的，但是是一个空list，同样大于等于24会多一个OptionalConverterFactory，当让converterFactory真正默认的是BuiltInConverters</p><p>  通过Retrofit的创建配置了相应的参数到Retrofit中，后面每一个方法ServiceMethod创建的时候会从这里面拿到需要的callAdapter、converter</p></li><li><p>动态代理得到接口对象：</p><p>  接着通过Retrofit的create方法来得到Service请求接口的代理对象；具体在create方法中，用了Java的动态代理<code>Proxy.newProxyInstance</code>，通过这个动态代理呢，运行时在具体调用某个请求方法的时候，会生成对应得代理对象，最后会调用到这个动态代理类的invoke方法，在这个invoke方法中，能够获取到我们调用请求方法的所有信息；最后返回的是<code>loadServiceMethod(method).invoke(args != null ? args : emptyArgs)</code></p><p>  先是通过loadServiceMethod方法获取ServiceMethod，具体就是先是在Retrofit的缓存serviceMethodCache（线程安全的HashMap）中获取，没有的话，就通过ServiceMethod的parseAnnotations方法创建一个ServieMethod方法（根据retrofit引用和method），在ServiceMethod的parseAnnotations方法先是根据Retrofit和method解析注解，创建一个RequestFactory，接着检查返回类型，通过HttpServiceMethod来创建一个ServiceMethod；HttpServiceMethod就是继承自ServiceMethod的，同样在parseAnnotations方法中：</p><ul><li><p>通过retrofit和method，从retrofit的callAdapterFactories中获取到对应的callAdapterFactory，同时检查responseType和requestFactory中的httpMethod；</p></li><li><p>通过retrofit和method及方法的注解，从converterFactories中得到对应的converterFactory（responseConverter）；</p></li><li><p>获取Retrofit中的okClient</p></li><li><p>最后new了HttpServiceMethod</p><p>然后就是调用ServiceMethod的invoke方法，动态代理对象也是返回的这个；具体就是调用HttpServiceMethod的invoke方法，在HttpServiceInvoke中返回了callAdapter的adapt方法，同时根据HttpServiceMethod持有的<code>requestFactory，callFactory，responseConverter</code>以及动态代理的参数<code>args</code>创建了OkHttpCall对象，并传到了adapt中；</p><p>由于默认的callAdapterFactory是ExecutorCallAdapterFactory，所以在ExecutorCallAdapterFactory的adapt方法中根据实例化的OkHttpCall创建了ExecutorCallbackCall并返回，整个create方法到此结束</p></li></ul></li><li><p>执行enqueue：</p><p>  通过Call的enqueue方法执行，实际上调用的是ExecutorCallbackCall的enqueue方法（前面有总结到），在ExecutorCallbackCall的嗯queue方法中对callback进行了一层封装，通过OkHttpCall执行真正的enqueue方法进行网络请求，在OkHttpCall的匿名callback中，通过callbackExecutor来做线程切换，将最终的结果返回到UI线程，通过我们设置的callback返回</p></li><li><p>真正通过OkHttpCall进行网络请求：</p><p>  OkHttpCall的enqueue方法中，主要做了两件事：</p><ul><li><p>获取okhttp3.Call</p><p>  通过设置的OkClient创建一个Call实例，通过RequestFactory创建一个okhttp3.Request，通过okhttp3.Call进行请求</p></li><li><p>解析结果</p><p>  在返回结果之前，会通过设置的responseConverter（converterFactory）来进行对应的数据转换</p></li></ul></li></ul><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><ul><li><a href="https://juejin.im/post/5b97d08df265da0ac138fd5f" target="_blank" rel="noopener">Retrofit2源码解析——网络调用流程(上)</a></li><li><a href="https://juejin.im/post/5b992acfe51d451a3f4bde83" target="_blank" rel="noopener">Retrofit2源码解析——网络调用流程(下)</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/51304204" target="_blank" rel="noopener">Retrofit2 完全解析 探索与okhttp之间的关系</a></li><li><a href="http://www.qinglinyi.com/posts/retrofit/" target="_blank" rel="noopener">Retrofit2 源码解析</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android——Binder机制</title>
      <link href="/2019/06/02/Android%20Binder%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/06/02/Android%20Binder%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Android——Binder机制"><a href="#Android——Binder机制" class="headerlink" title="Android——Binder机制"></a>Android——Binder机制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="Linux下的IPC方式"><a href="#Linux下的IPC方式" class="headerlink" title="Linux下的IPC方式"></a>Linux下的IPC方式</h3><ul><li>管道：创建时会分配一个page大小的内存，缓存区大小比较有限</li><li>消息队列：信息复制两次，额外的CPU消耗，不适合频繁或信息量大的通信</li><li>共享内存：无需复制，共享缓存区直接附加到进程虚拟地址空间，速度快；但进程间的同步问题写操作系统不能控制，必须各进程使用同步工具</li><li>套接字socket：更通用的接口，传输效率低，主要用于不同机器或跨网络的通信</li><li>信号量：在Linux下常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问资源，可以作为进程间的同步手段</li><li>信号：不适用于信息交换，更适用于进程中断控制，如非法内存访问、杀死某个进程</li></ul><blockquote><p> Android是基于Linux开发的系统，所以很多Linux能用的IPC，Android都可以使用，但是Android开发了自己的一套IPC机制——Binder</p></blockquote><h3 id="为什么要用Binder"><a href="#为什么要用Binder" class="headerlink" title="为什么要用Binder"></a>为什么要用Binder</h3><ul><li><p>从性能角度，数据拷贝次数来说：</p><p>  Binder数据只需要拷贝一次，而管道、消息队列、Socket等都需要两次数据的拷贝，但共享内存一次都不需要，可以直接访问；从性能来说，Binder仅次于共享内存</p></li><li><p>从稳定性角度：</p><p>  Binder基于C/S架构（Client和Server，客户端有什么需求直接发送给服务端去完成，两端相对独立），而共享内存实现方式复杂，没有客户端与服务端之别，需要充分考虑到访问临界资源的并发同步问题，否则会出现死锁问题；从稳定性来说，Binder优于共享内存</p></li><li><p>从安全角度：</p><p>  Android由于开源，App来源广，容易数据泄露、后台耗电等问题，所以安全特别重要，传统Linux无任何保护措施，完全由上层协议来确保</p><p>  传统Linux IPC的接收方无法获取对方进程可靠的UID/PID，从而无法鉴别身份；</p><p>  Android为每个安装好的应用程序分配了自己的UID，因此进程的UID就是最好鉴别进程身份的标志；前面说到的C/S架构，Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限（目前权限控制很多时候是通过弹出权限对话框，让用户选择，低版本没有）；Android 6.0之前，所有权限申请都是在安装的时候有一个权限清单，一些不需要的权限让用户无法拒绝，因为拒绝后App无法正常使用，在6.0（M）后，Google对此做了调整，安装时不是一并询问所有权限，而是在运行过程中，需要什么权限再由用户授权，对权限进行了细化，这样也导致了更多的弹窗；在后面的8.0、9.0中，对权限的控制更加严格</p><p>  传统IPC只能由用户在数据包里填入UID/PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p></li><li><p>从语言层面角度：</p><p>  Linux基于C语言，Android基于Java语言；Binder也符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程，它的引用可以位于多个进程。Binder模糊化了进程边界，淡化考虑进程间的通信过程。从语言层面来说，Binder属于面向对象，使用Android人员</p><p>  当然Binder更多用于system_server进程与上传APP层的IPC</p></li></ul><blockquote><p>Binder是基于开源的 <a href="https://link.zhihu.com/?target=http%3A//www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="noopener">OpenBinder</a>实现的，OpenBinder是一个开源的系统IPC机制,最初是由 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Be_Inc." target="_blank" rel="noopener">Be Inc.</a> 开发，接着由<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Palm%2C_Inc." target="_blank" rel="noopener">Palm, Inc.</a>公司负责开发，现在OpenBinder的作者在Google工作，既然作者在Google公司，在用户空间采用Binder 作为核心的IPC机制，再用Apache-2.0协议保护，自然而然是没什么问题，减少法律风险，以及对开发成本也大有裨益的，那么从公司战略角度，Binder也是不错的选择</p></blockquote><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><ul><li><a href="https://www.zhihu.com/question/39440766" target="_blank" rel="noopener">为什么 Android 要采用 Binder 作为 IPC 机制？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序学习笔记</title>
      <link href="/2019/05/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/05/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="小程序学习笔记"><a href="#小程序学习笔记" class="headerlink" title="小程序学习笔记"></a>小程序学习笔记</h1><ul><li>实现阴影：<code>box-shadow: h-shadow v-shadow blur spread color inset;</code><ul><li><code>h-shadow</code>：必需。水平阴影的位置。允许负值。</li><li><code>v-shadow</code>：必需。垂直阴影的位置。允许负值。</li><li><code>blur</code>：可选。模糊距离。</li><li><code>spread</code>：可选。阴影的尺寸。</li><li><code>color</code>：可选。阴影的颜色。</li><li><code>inset</code>：可选。将外部阴影 (<code>outset</code>) 改为内部阴影。默认的是外部阴影。所以如果是</li><li><code>outset</code>那么就可以直接省略。如果是内阴影再写上<code>inset</code>.</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端开发学习笔记</title>
      <link href="/2019/05/20/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/05/20/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前端学习笔记"><a href="#前端学习笔记" class="headerlink" title="前端学习笔记"></a>前端学习笔记</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><ul><li>img：<code>&lt;img src=&quot;图片地址&quot; alt=&quot;图片无法加载时显示，可替换的额文本&quot; width=&quot;&quot; height=&quot;&quot;&gt;</code></li><li>map：图像地图</li><li>area：图像地图中可点击区域</li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li>table：定义表格，border（边框属性）</li><li>th：表头</li><li>tr：定义行</li><li>td：定义每行的格数，也就是单元格的数据内容</li><li>caption：表格标题</li><li>colgroup：定义表格列的组</li><li>col：定义表格列的属性</li><li>tbody：表格的主体</li><li>tfoot：表格的页脚</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>ul：无序列表</li><li>ol：有序列表</li><li>li：列表项</li><li>dl：自定义列表</li><li>dd：自定义列表的项的描述</li><li>dt：自定义列表项目</li></ul><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><ul><li>div：区块元素，属于块级元素</li><li>span：内联元素，文本容器</li></ul><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><ul><li>form：允许输入内容</li><li>input：输入标签，输入类型由tyoe决定<ul><li>text：文本内容</li><li>password：密码</li><li>radio：单选按钮</li><li>checkbox：复选框</li><li>submit：提交按钮</li></ul></li><li>textarea：文本域，一个多行输入的控件</li><li>label：input的输入标题</li><li>fieldset：相关表单元素，使用外框包含</li><li>legend：定义fieldset元素的标题</li><li>select：下拉选项列表</li><li>optgroup：选项组</li><li>option：下拉列表中的选项</li><li>button：按钮</li><li>datalist：指定一个预先定义的输入控件选项列表</li><li>keygen：定义了表单的密钥对生成器字段</li><li>output：定义一个计算结果</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li>iframe：<code>&lt;iframe src=“展示的html” width=&quot;&quot; height=&quot;&quot; frameborder=&quot;0（一处边框）&quot;</code></li></ul><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><ul><li>script：一般是JS脚本</li><li>noscript：提供无法使用脚本时的替代内容</li></ul><h3 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h3><ul><li>&amp;lt，&amp;#60，&amp;#060：小于符号（&lt;）</li><li>&amp;gt，&amp;#62：大于符号</li><li>&amp;amp，&amp;#38：&amp;符号</li><li>&amp;quot，&amp;#34：“引号</li><li>&amp;cent，&amp;#39：‘撇号</li><li>&amp;nbsp：不间断空格</li><li>&amp;times，&amp;#215：x乘号</li><li>&amp;divide，&amp;#247：除号</li><li>音标符</li></ul><h3 id="H5新元素"><a href="#H5新元素" class="headerlink" title="H5新元素"></a>H5新元素</h3><ul><li>canvas：定义图形，绘图API</li><li>audio：音频内容</li><li>video：视频内容</li><li>source：多媒体资源</li><li>embed：嵌入的内容，比如插件</li><li>track：为video、audio规定外部文本轨道</li><li>article：页面独立的内容区域</li><li>aside：页面的侧边栏内容</li><li>bdi：允许设置一段文本，使其脱离其父元素的文本方向设置</li><li>command：命令按钮</li><li>derails：用于描述文档和文档某个部分的细节</li><li>dialog：定义对话框</li><li>summary：标签包含details元素的标题</li><li>figure：规定独立的流内容</li><li>figcaption：定义figure元素的标题</li><li>footer：页脚</li><li>header：文档的头部区域</li><li>mark：带有记号的文本</li><li>nav：导航链接部分</li><li>progress：任务进度</li><li>ruby：定义ruby注释</li><li>rt：定义字符的解释或发音</li><li>rp：在ruby中使用</li><li>section：定义文档的节</li><li>time：定义日期或时间</li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="id和class"><a href="#id和class" class="headerlink" title="id和class"></a>id和class</h3><ul><li>class：class选择器，指定style</li><li>id</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><p>background：简写属性，按照后续的顺序</p></li><li><p>background-color：背景颜色</p></li><li><p>background-image：背景图片<code>{background-image:url(&#39;bgdesert.jpg&#39;);}</code></p></li><li><p>background-repeat：水平或者垂直平铺，repeat-x——水平，repeat-y——垂直，no-repeat——不平铺</p></li><li><p>background-attachment：北京图像是否固定或者随着页面的其余滚动</p></li><li><p>background-position：设置定位，和no-repear一起使用，right top</p></li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ul><li>color：文本颜色</li><li>direction：文本方向</li><li>letter-spacing：字符间距</li><li>line-height：行高</li><li>text-align：文本对齐方式，center——居中，right——右对齐，justify——每一行被展开为宽度相等，左，右外边距是对齐</li><li>text-decoration：用来设置或删除文本的装饰</li><li>text-transform：文本转换属性，用来指定在一个文本中的大写和小写字母，uppercase——大写，lowercase——小写，capitalize——首字母大写</li><li>text-indent：文本缩进，指定第一行的缩进</li><li>text-shadow：文本阴影</li><li>vertical-align：设置元素的垂直对齐</li><li>white-space：设置元素中空白的处理方式</li><li>word-spacing：字间距</li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li>font：所有字体属性，简写</li><li>font-family：字体系列</li><li>font-size：字体大小</li><li>font-style：字体样式，normal——正常，italic——斜体，oblique——倾斜的文字</li><li>font-variant：小型大写字体或者正常字体显示文本</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>link：未访问，可以设置color、background-color、text-decoration等</li><li>visitid：已访问</li><li>hover：鼠标移动到链接上</li><li>active：鼠标点击时</li></ul><h3 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h3><ul><li>list-style：简写属性</li><li>list-style-type：指定列表项标记的类型，circle、square、upper-roman、lower-alpha</li><li>list-style-position：列表项标志的位置</li><li>list-style-image：指定列表项标记的图像，url()</li></ul><h3 id="表格-1"><a href="#表格-1" class="headerlink" title="表格"></a>表格</h3><ul><li>border：边框，<code>border: 1px solid black;</code>宽度、类型、颜色</li><li>border-collapse：折叠边框，collapse</li><li>width</li><li>height</li><li>text-algin：</li><li>padding：</li><li>color：表格颜色</li><li>background-color：背景颜色</li></ul><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul><li>border-style：边框样式，简写设置依次是上、右、下、左<ul><li>none——默认无样式</li><li>dotted——点线边框</li><li>dashed——虚线边框</li><li>solid——实线边框</li><li>double——两个边框</li><li>groove：3D沟槽边框</li><li>ridge：3D脊边框</li><li>inset：3D嵌入边框</li><li>outset：3D突出边框</li></ul></li><li>border-width：宽度</li><li>border-color：边框颜色</li><li>border-top-style：设置上边框的样式，或者上边框的颜色、宽度等，同理还有右、下、左</li></ul><h3 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h3><ul><li>outline：轮廓属性</li><li>outline-color：轮廓颜色</li><li>outline-style：轮廓样式</li><li>outline-width：轮廓宽度</li></ul><h3 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a>定位position</h3><ul><li>static：没有定位。默认值，遵循正常的文档流</li><li>fixed：元素的位置相对于浏览器窗口是固定位置</li><li>relative：相对位置</li><li>absolute：绝对定位</li><li>sticky：粘性定位</li></ul><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架整理(二)——HashMap源码分析</title>
      <link href="/2019/05/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%BA%8C)%E2%80%94%E2%80%94HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86(%E4%BA%8C)%E2%80%94%E2%80%94HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="HashMap源码分析（1-8）"><a href="#HashMap源码分析（1-8）" class="headerlink" title="HashMap源码分析（1.8）"></a>HashMap源码分析（1.8）</h1><p>[TOC]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><ol><li><strong>HashMap</strong>是一个键值对的集合容器，继承自Map</li><li>是线程不安全的（线程安全的是ConcurrentHashMap），允许key为null，value为null</li><li>是无序集合，遍历时是无序的</li><li>是一个关联数组、哈希表，内部的数据结构是一个数组，称之为哈希桶，每个桶里放的是一个链表，链表的节点就是最后存放的元素（1.8 当链表的节点数大于8，链表转为红黑树，节点数小于6，红黑树转为链表）</li><li>开放地址法，解决哈希冲突，具体体现在上一点的数据结构实现上</li><li>默认初始桶长16，默认加载因子0.75，最大容量2^30，在put的时候才会去初始化桶</li><li>每次扩容是以前的2倍，通过new一个新的数组，然后拷贝值</li><li>通过<strong>扰动函数</strong>来减少哈希碰撞（1.8 2次扰动，1.7 9次扰动）</li></ol></blockquote><p>下面就是HashMap的数据结构</p><p><a href="https://img-blog.csdnimg.cn/20190506232217775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener"><img src="https://img-blog.csdnimg.cn/20190506232217775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2OTU5ODg2,size_16,color_FFFFFF,t_70" alt="HashMap"></a>HashMap</p><p>接着从源码角度来看看HashMap吧</p><p>首先看看HashMap继承结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap是继承自AbstractMap的，AbstractMap是实现了Map的（具体可以看看<a href="http://blog.penghesheng.cn/2019/05/06/Java集合框架整理(二)——HashMap源码分析/" target="_blank" rel="noopener">Java集合框架整理(一)</a>），同时自己也实现了Map、Cloneable（可复制）、Serializable（可序列化）等接口</p><p>接着看看一些内部属性吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认桶初始化容量 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//最大桶容量 2^31-1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认加载因子 0.75</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//当链表节点数大于8转为红黑树的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//当红黑树节点数小于6转为链表的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//最小树化容量阈值，即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）；否则，若桶内元素太多时，则直接扩容，而不是树形化。 </span></span><br><span class="line"><span class="comment">//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//桶</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//用来遍历的 keySet values</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">//存储元素个数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//记录修改次数的</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//实际哈希表内元素数量的扩容阈值，当哈希表内元素数量超过阈值时，会发生扩容resize()</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//实际加载因子，用于计算哈希表元素数量的阈值。  threshold = 哈希桶.length * loadFactor</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体属性的解释都备注好了，也没啥难懂的</p><p>然后我们看看具体存储的节点Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">           V oldValue = value;</span><br><span class="line">           value = newValue;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Node中记录了key、value、hash值以及下一个节点</p><p>然后主要注意一些东西，key和hash值都是final的，也就是初始化后不能轻易改变的，而value却不是，这就是为啥通常只能根据key来改变value，而没有根据value改变key；Node的hashCode是通过key和value相与得到的；equals不仅比较Node，也可以是key和value相同</p><p>接着看看构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>构造函数就只有4个，通常我们通过<code>new HashMap&lt;&gt;()</code>，这个时候就是无参构造，只会默认指定一个默认的加载因子，其他的都是再put时使用默认值</p><p>指定桶的初始容量，也会使用默认的加载因子，最后重载到根据容量、加载因子两个参数的构造器；在这个构造器中，会先后检验初始化的容量是否不合理（&lt;0 或者超出最大值），同样会检验加载因子。然后将加载因子赋值给变量loadFactor，通过<code>tableSizeFor(initialCapacity)</code>方法来计算threshold阈值（这还不是确定的，只是尽进行了一个初始化）</p><p>先看看是怎么计算的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算大于cap值的最小2的幂</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将传入的容量大小转化为：大于传入容量大小的最小的2的幂</p><p>好了，这里转换就是通过与运算和位运算来的，回到之前的构造方法，我们还有一个构造方法没看</p><p>还有一个构造方法是根据一个Map来初始化的，同样使用了默认的加载因子，然后通过<code>putMapEntries(m, false)</code>方法将Map中的元素添加到HashMap中，看看这个方法是什么吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> s = m.size();</span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">               <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">               <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                   <span class="comment">//这里计算出来就是有用的了</span></span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">               resize();</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">               K key = e.getKey();</span><br><span class="line">               V value = e.getValue();</span><br><span class="line">               <span class="comment">//添加到哈希表中</span></span><br><span class="line">               putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>putMapEntries方法也很简单，如果table还没有初始化的话（为null），就先计算阈值；接着如果map的size大于了阈值，那么就要进行扩容了；如果都没问题的话，通过遍历Map，将key、value存入HashMap中</p><p>好了，构造方法和初始化就先看到这里吧，具体怎么扩容、怎么添加后面会讲到</p><p>到这里，我们发现，实例化的时候，我们都没有真正上的进行初始化桶（table数组），都只是进行一些值得确定（如加载因子、容量等）</p><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>通常，我们都是通过put添加到HashMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>put方法中，根据key值计算了hash值（就是我们存储的位置hash值），然后通过putVal方法添加到HashMap中</p><p>先看看这个计算key得hash吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从这个计算来看，可以知道一下几点</p><blockquote><ol><li>当key为null时，hash值为0，说明key是可以为null的（对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null）</li><li>当key不为null时，先计算出key的哈希码h，然后进行扰动处理（按位异或哈希码自身右移16位），所以是两次扰动（一次异或，一次右移16位）</li></ol></blockquote><h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h3><p>通过key得到hash后，传入putVal方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//table为null或者length为0，通过resize()扩容进行初始化，所以第一次初始化是在第一次put时候（以Map实例化除外，但它也会在resize中进行初始化）</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//记录table的length</span></span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//通过(length - 1) &amp; hash计算下标，没有哈希冲突则直接添加进去</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//产生哈希冲突</span></span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//key值存在（处于桶内的头节点），更新value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               <span class="comment">//如果是红黑树节点，则以红黑树的方式添加</span></span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//否则是链表，遍历链表到链尾，插入</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//如果到达了树化（链表转红黑树）的阈值（8），则进行树化</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//红黑树或链表中的存在key，更新value就可以了</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//操作修改+1</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">//是否需要扩容</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       <span class="comment">//LinkedHashMap用的api</span></span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总的分为如下几个部分</p><ol><li>table是否为null或者length为0：是通过<code>resize()</code>进行初始化</li><li>通过桶的length，(length - 1) &amp; hash计算在桶中的下标，为null则没有产生冲突，插入，否则进入下一步</li><li>存在哈希冲突，首先判断是不是和桶内的头结点拥有同一个key，是则更新value，不是则进行桶内链表或者红黑树的比较</li><li>如果是红黑树，则通过红黑树的插入方式进行插入</li><li>不是红黑树，是链表，则遍历链表，如果链表中有相同的key，跳出遍历循环，更新value；如果没有，遍历到链尾，进行插入，插入成功后判断是否到达树化的阈值（8），如果到达，将链表进行树化（转为红黑树）</li><li>记录操作数，size+1，判断是否到达阈值，是否需要进行扩容</li></ol><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>我们看看<code>resize()</code>方法，如何进行扩容和初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//检查是否到达最大值，已经到达最大值，不再进行扩容</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               <span class="comment">//新桶的容量newCap是旧桶容量的2倍，并且保证小于最大容量，旧容量大于默认容量16</span></span><br><span class="line">               <span class="comment">//新的加载因子是旧的2倍 一般是0.75变为1.5</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           <span class="comment">//初始化为默认的容量 一般table==null且阈值为0或者不存在的情况下</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           <span class="comment">//计算新的阈值</span></span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="comment">//真正初始化桶的位置</span></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">//扩容完成后，进行值的复制</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">//只有头结点的情况</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       <span class="comment">//是红黑树，则需要进行拆分，重新计算下标</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       <span class="comment">//链表基本上不会有什么位置的变化，因为2的幂的缘故，计算出新的下标还是以前的下标，桶的容量始终保持2的幂也是为了方便链表的复制更高效一点</span></span><br><span class="line">                       <span class="comment">//低位头结点</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="comment">//高位头结点</span></span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="comment">//遍历链表，尾插法</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//将低位的链表放置到原index处</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//将高位链表放在新的index处</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先看一下是真正确定容量和阈值的</p><p>如果oldCap的容量是大于0的，则会检验旧容量是否达到了最大容量（达到最大容量不再进行扩容），没有到达最大容量，则进行2倍扩容（扩容后也要保证小于等于最大容量），同时阈值也扩大2倍；</p><p>如果当前table是空的，但是已经有了阈值，那么新容量就等于旧容量；</p><p>如果table是空的，且没有设置阈值，那么旧才用默认的值，默认容量16，默认阈值12（默认加载因子 * 默认容量）</p><p>接着更新阈值，然后构建新的哈希桶（如果之前没有初始化桶，那么这次就会初始化了）</p><p>接着又是判断旧桶存不存在，旧桶不为null，那么就需要将旧桶的数据复制到新桶中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 遍历旧桶</span><br><span class="line"> <span class="number">2</span>. 如果旧桶中有元素，则复制给e，将原哈希桶置空（以便GC）</span><br><span class="line"> <span class="number">3</span>. 如果旧桶中的链表就一个头结点（只有e），则没有哈希冲突，直接通过hash &amp; (newCap - <span class="number">1</span>)（与运算）计算新的位置，然后存入</span><br><span class="line"> <span class="number">4</span>. 如果旧桶里放的是红黑树，则通过红黑树的方式，进行拆分，重新计算（一般红黑树都会重新转为链表）</span><br><span class="line"> <span class="number">5</span>. 如果旧桶里的链表不只一个结点，则通过遍历链表，从新计算节点的index下标，低位的仍然还在低位（以前的index下标），高位则放在高位（通过高低位头结点来记录）</span><br></pre></td></tr></table></figure><p>好了，hash扰动和扩容基本就看得差不多了，接着看看其他几个添加api吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个方法前面我们也看过了</span></span><br><span class="line">       putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//若key对应的value之前存在，不会覆盖 1.8新增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总之，不管怎样，put最后都会通过<code>putVal()</code>方法来添加</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>接着看看从HashMap中获取元素吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先根据key计算hash值，通过getNode来获取对应key的节点，为null则返回null，否则返回节点的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//检查头结点</span></span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//红黑树的查找</span></span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="comment">//链表内的查找</span></span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先是对table桶的判断和元素的判断，有才会进行查找</p><p>如果刚好是头节点，返回</p><p>如果不是头节点，判断是不是红黑树节点，是通过红黑树查找；否则是链表，遍历链表查找</p><p>几个类似方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有默认值的get方法 1.8新增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e; V v;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">           e.value = newValue;</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           V oldValue = e.value;</span><br><span class="line">           e.value = value;</span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>replace方法都是通过getNode来获取到对应的节点，然后替换旧值</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>通过remove删除一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">          <span class="keyword">null</span> : e.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>跟get方法类似，根据key获取hash值，然后通过removeNode方法进行具体的删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">           <span class="comment">//头节点的检查</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="comment">//待删除节点赋值给node</span></span><br><span class="line">               node = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//红黑树的获取节点</span></span><br><span class="line">               <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//链表获取key的节点</span></span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                           ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                           node = e;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       p = e;</span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">               <span class="comment">//删除红黑树的key的节点</span></span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                   <span class="comment">//如果是头结点直接通过next覆盖</span></span><br><span class="line">                   tab[index] = node.next;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="comment">//链表中间，通过链表直接覆盖</span></span><br><span class="line">                   p.next = node.next;</span><br><span class="line">               <span class="comment">//记录操作次数</span></span><br><span class="line">               ++modCount;</span><br><span class="line">               <span class="comment">//size-1</span></span><br><span class="line">               --size;</span><br><span class="line">               <span class="comment">//LinkedHashMap使用的api</span></span><br><span class="line">               afterNodeRemoval(node);</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>整个删除逻辑也不复杂，根据key计算hash值，得到对应的下标，然后依次判断是头结点、红黑树中的节点、链表中的节点，然后进行删除就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>key、value为条件删除，最终也是嗲用removeNode方法</p><h2 id="其他api"><a href="#其他api" class="headerlink" title="其他api"></a>其他api</h2><h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空操作，置为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           size = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">               tab[i] = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">       Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">       <span class="comment">//entrySet是缓存</span></span><br><span class="line">       <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看看EntrySet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//通过getNode方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">           Object key = e.getKey();</span><br><span class="line">           Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">           <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//通过removeNode方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">               Object key = e.getKey();</span><br><span class="line">               Object value = e.getValue();</span><br><span class="line">               <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取迭代器</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//forEach遍历</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">           Node&lt;K,V&gt;[] tab;</span><br><span class="line">           <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">           <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> mc = modCount;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                       action.accept(e);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>HashMap是一个键值对的Map集合，是无序的且遍历无序</li><li>是线程非安全的，key和value都可以为null</li><li>开放地址法，俗称拉链法来解决哈希冲突；其底层采用数组作为哈希桶table，桶内存放链表（1.8 链表大于8转为红黑树，节点数小于6转为链表）</li><li>默认容量是16（保证2的幂），默认加载因子0.75，根据<code>默认容量 * 默认加载因子</code>计算阈值，当容量达到阈值会进行扩容操作；table桶的初始化是在第一次put（通过putVal方法）存入的时候才进行（构造器中的初始化只是一些值的初始化如容量、加载因子、阈值等）</li><li>扩容当table桶没有初始化或者达到容量时，会进行扩容；扩容前，会再次确定容量、阈值，然后创建一个新的table桶，如果存在旧桶，则会将旧桶的值复制到新桶中；复制过程，会根据新桶的容量计算新的下标，然后会根据头结点、红黑树节点（红黑树会将以前的红黑树进行拆分，重新计算哈希冲突，最后可能是红黑树，也可能是链表）、链表来进行不同的复制（链表复制过程中，会有低位链表——下标是没有变的，高位链表——新的下标；这是由于桶的容量始终是2的幂产生的一种高效率的方式）</li><li>插入操作前，会检查是否扩容；然后计算根据<code>(length - 1) &amp; hash(key)</code>（通过位与运算来代替求余运算）来计算桶中的下标，然后依次检查头节点、红黑树节点、链表；头结点如果没有值或者有key，则插入或更新；红黑树节点，则通过红黑树添加；链表则是通过遍历链表，有相同的key则替换value，没有则在链尾插入新的节点，如果节点数大于8则进行树化；插入完成会去检验是否需要扩容</li><li>get、remove、replace等方法，都十分简单，通过key获取hash值进而得到下标，然后还是头节点、红黑树、链表几种不同的获取或删除节点</li></ol></blockquote><h3 id="1-7和1-8的区别"><a href="#1-7和1-8的区别" class="headerlink" title="1.7和1.8的区别"></a>1.7和1.8的区别</h3><ol><li>1.7的一些运算赋值在1.8中变为了位运算，一些判断也从Math变为了if else</li><li>JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算。1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</li><li>1.7扩容函数是在确定要扩容进行，1.8的扩容函数可能是初始化；1.7更新阈值在扩容后，1.8在扩容前，很多判断、阈值更新都是在扩容前</li><li>1.8扩容后进行复制时，会先进行链表的一个判断（当前链表只有一个元素时），1.7没有；1.8有链表高低位的处理，是将整个旧链表复制到新的中，低位链表的索引跟原来的一样，高位的则放在新的索引处（尾插法），1.7则是遍历旧链表，头插法插入新链表（可能导致逆序）</li><li>1.8中加入了红黑树，当链表长度到8时链表转化为红黑树，扩容时，重新计算存储位置，红黑树内数量&lt;6又会转化为链表</li><li>key和value都允许为null（key只能有一个为null，而value则可以有多个为null）</li></ol><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p><a href="https://blog.csdn.net/zxt0601/article/details/77413921" target="_blank" rel="noopener">面试必备：HashMap源码解析（JDK8）</a></p><p><a href="https://blog.csdn.net/carson_ho/article/details/79373134" target="_blank" rel="noopener">Java源码分析：关于 HashMap 1.8 的重大更新</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android View系列(四)——FrameLayout源码分析</title>
      <link href="/2019/05/04/Android%20View%E7%B3%BB%E5%88%97(%E5%9B%9B)%E2%80%94%E2%80%94FrameLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/04/Android%20View%E7%B3%BB%E5%88%97(%E5%9B%9B)%E2%80%94%E2%80%94FrameLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="FrameLayout源码分析"><a href="#FrameLayout源码分析" class="headerlink" title="FrameLayout源码分析"></a>FrameLayout源码分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FrameLayout是层级布局，即所有的子View都是从底层向上层开始，默认不指定margin或者layout_gravity的话，每个子view的坐标其实坐标都是Framelayout的其实坐标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameLayout就是直接继承自ViewGroup的</p><p>接着看看measure过程吧</p><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"><span class="comment">//判断FrameLayout 宽 高 是否同时设置了Match_parent或者 设置了指定大小的宽高</span></span><br><span class="line">   <span class="comment">// measureMatchParentChildren 为 true，则表示没有设置了Match_parent或者 设置了指定大小的宽高</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">               MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">               MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">       mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历所有子View计算出所有的子View中的最大宽度 maxWidth 和最大高度 maxHeigh</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">           <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">               <span class="comment">//计算子View的宽高，包含了子View的左右上下Margin，直接调用ViewGroup中的方法</span></span><br><span class="line">               measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               maxWidth = Math.max(maxWidth,</span><br><span class="line">                       child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">               maxHeight = Math.max(maxHeight,</span><br><span class="line">                       child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">               childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">               <span class="comment">// FrameLayout没有设置固定大小的宽高或Match_parent高宽，则收集所有设置了Match_parent的子View </span></span><br><span class="line">               <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                           lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                       mMatchParentChildren.add(child);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 加上padding</span></span><br><span class="line">       maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">       maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">       maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Drawable drawable = getForeground();</span><br><span class="line">       <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">           maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">           maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//设置自身的宽高</span></span><br><span class="line">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">               resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                       childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先看前部分，根据FrameLayout 宽 高 是否同时设置了Match_parent或者 设置了指定大小来设置一个Boolean值，然后遍历所有的子View，计算出最大宽度和最大高度，同时调用ViewGroup中的方法进行子View的测量；如果FrameLayout没有设置为match_parent或者固定的值，则会存储是match_parent的所有子View</p><p>接着就是加上padding值，然后设置自己的宽高</p><p>接着看后面部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">// 如果FrameLayout没有同时设置固定大小或者Match_parent宽高，且有子View设置了Match_parent宽高，则重新测量 设置了Match_Parent宽高的子View</span></span><br><span class="line">       count = mMatchParentChildren.size();</span><br><span class="line">       <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">               <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">               <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                           - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                           - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                   childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                           width, MeasureSpec.EXACTLY);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                           getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                           lp.leftMargin + lp.rightMargin,</span><br><span class="line">                           lp.width);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">               <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                           - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                           - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                   childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                           height, MeasureSpec.EXACTLY);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                           getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                           lp.topMargin + lp.bottomMargin,</span><br><span class="line">                           lp.height);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面部分就是判断是否需要重新测量，如果FrameLayout没有同时设置固定大小或者Match_parent宽高，且有子View设置了Match_parent宽高，则重新测量 设置了Match_Parent宽高的子View</p><p>onMeasure过程就这么多，毕竟FrameLayout不算难</p><h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">       layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"><span class="comment">//遍历子View</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">           <span class="comment">//同样，View的可见性不为GONE才会计算在内</span></span><br><span class="line">           <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">               <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line">               <span class="keyword">int</span> childLeft;</span><br><span class="line">               <span class="keyword">int</span> childTop;</span><br><span class="line">               <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">               <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                   gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"><span class="comment">// 根据水平方向Gravity，计算View的左右，坐标</span></span><br><span class="line">               <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                       childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                       <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                           childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment">// 根据垂直方向Gravity，计算View的上下，坐标</span></span><br><span class="line">               <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                       childTop = parentTop + lp.topMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                       childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> + lp.topMargin - lp.bottomMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                       childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childTop = parentTop + lp.topMargin;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>onLayout方法主要就是对子View进行layout</p><p>在对子View进行layout的过程中，主要就是通过遍历所有的子View，然后根据水平和垂直两个方向计算view具体的坐标，最后通过子View本身的layout方法进行放置。因为每个view在不同的层级，所以只需要计算每个View的Layout_gravity，默认的<code>Layout_gravity 为Gravity_left | GravityTop</code>, 在根据Gravity计算时，分别通过水平方向的Gravity计算出 左右 坐标，然后根据垂直方向的Gravity计算出上下坐标。</p><h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>FrameLayout没有自己实现onDraw方法</p><h2 id="FrameLayout、LinearLayout和RelativeLayout的性能对比"><a href="#FrameLayout、LinearLayout和RelativeLayout的性能对比" class="headerlink" title="FrameLayout、LinearLayout和RelativeLayout的性能对比"></a>FrameLayout、LinearLayout和RelativeLayout的性能对比</h2><p>当RelativeLayout和LinearLayout作为ViewGroup表达相同的布局的时候，谁的绘制更快一些，性能相对更好一些？</p><p>通过网上的很多实验结果我们得之，两者绘制同样的界面时layout和draw的过程时间消耗相差无几，关键在于measure过程RelativeLayout比LinearLayout慢了一些。我们知道ViewGroup是没有onMeasure方法的，这个方法是交给子类自己实现的。因为不同的ViewGroup子类布局都不一样，那么onMeasure索性就全部交给他们自己实现好了</p><p>LinearLayout：在没有权重的情况下，就只会单纯的遍历一个方向，遍历一次所有的View；如果View设置了权重 ，那么在第一次遍历的时候这个View是不会进行测量的，在第二次测量（专门用于测量权weight重的）；所以无权重一次遍历，有权重两次遍历</p><p>RelativeLayout：因为依赖关系，所以在进行排序后，分别会对水平、垂直方向进行遍历，所以两次遍历</p><p>FrameLayout：某种情况上来说，FrameLayout也可能导致二次测量，不过FrameLayout的二次测量就只针对View为match_parent的了</p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p><a href="https://blog.csdn.net/m0_37778101/article/details/85061171" target="_blank" rel="noopener">FrameLayout 源码分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android View系列(二)——RelativeLayout源码分析</title>
      <link href="/2019/05/01/Android%20View%E7%B3%BB%E5%88%97(%E4%BA%8C)%E2%80%94%E2%80%94RelativeLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/01/Android%20View%E7%B3%BB%E5%88%97(%E4%BA%8C)%E2%80%94%E2%80%94RelativeLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="RelativeLayout源码"><a href="#RelativeLayout源码" class="headerlink" title="RelativeLayout源码"></a>RelativeLayout源码</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RelativeLayout是我们日常布局中除了LinearLayout外，基本使用的就是它了；RelativeLayout就是相对布局，可以根据某一个view的位置，将新的View放置到某View的周围</p><p>RelativeLayout和LinearLayout一样，都是直接继承自ViewGroup，下面依旧从measure、layout、draw进行一个源码的查看</p><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>RelativeLayout的onMeasure方法代码也是很多，我们一点一点看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mDirtyHierarchy) &#123;</span><br><span class="line">           mDirtyHierarchy = <span class="keyword">false</span>;</span><br><span class="line">           sortChildren();</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先有一个脏布局的判断，如果是脏布局的话，需要先对子View进行一个排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.requestLayout();</span><br><span class="line">    mDirtyHierarchy = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据mDirtyHierarchy的赋值，可以看到，只有在requestLayout的时候，才会被判定为脏布局，进行重新测量重新布局</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>那先看看排序吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">if</span> (mSortedVerticalChildren == <span class="keyword">null</span> || mSortedVerticalChildren.length != count) &#123;</span><br><span class="line">           mSortedVerticalChildren = <span class="keyword">new</span> View[count];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mSortedHorizontalChildren == <span class="keyword">null</span> || mSortedHorizontalChildren.length != count) &#123;</span><br><span class="line">           mSortedHorizontalChildren = <span class="keyword">new</span> View[count];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> DependencyGraph graph = mGraph;</span><br><span class="line">       <span class="comment">//清空</span></span><br><span class="line">       graph.clear();</span><br><span class="line"><span class="comment">//添加到graph中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           graph.add(getChildAt(i));</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//根据水平和垂直两个方向进行排序，然后放入前面初始化的两个容器</span></span><br><span class="line">       graph.getSortedViews(mSortedVerticalChildren, RULES_VERTICAL);</span><br><span class="line">       graph.getSortedViews(mSortedHorizontalChildren, RULES_HORIZONTAL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法中获取了子View的个数，然后初始化了两个容器用来存放水平和垂直方向排好序的子View，将子View的关系依赖graph进行初始化、清空，然后将所有的子View添加到关系依赖中</p><p>先看看这个DependencyGraph吧，后面的排序也是通过它来进行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyGraph</span> </span>&#123;</span><br><span class="line">       <span class="comment">//存放所有的一级子View</span></span><br><span class="line">       <span class="keyword">private</span> ArrayList&lt;Node&gt; mNodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line"><span class="comment">//存放有id的view</span></span><br><span class="line">       <span class="keyword">private</span> SparseArray&lt;Node&gt; mKeyNodes = <span class="keyword">new</span> SparseArray&lt;Node&gt;();</span><br><span class="line"><span class="comment">//临时数据结构，用于有序的放置目标的View数组</span></span><br><span class="line">       <span class="keyword">private</span> ArrayDeque&lt;Node&gt; mRoots = <span class="keyword">new</span> ArrayDeque&lt;Node&gt;();</span><br><span class="line">...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在DependencyGraph中有三个容器，mNodes用来存放所有的一级子View；mKeyNodes用来存放所有有id的子View，并且在后面的<code>addView()</code>方法中可以知道，viewId是作为key，view作为value；mRoots算是一个临时的容器，用来存放排好序的view</p><p>接着先看看这个Node吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">          View view;</span><br><span class="line">          <span class="keyword">final</span> ArrayMap&lt;Node, DependencyGraph&gt; dependents =</span><br><span class="line">                  <span class="keyword">new</span> ArrayMap&lt;Node, DependencyGraph&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> SparseArray&lt;Node&gt; dependencies = <span class="keyword">new</span> SparseArray&lt;Node&gt;();</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_LIMIT = <span class="number">100</span>;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SynchronizedPool&lt;Node&gt; sPool =</span><br><span class="line">                  <span class="keyword">new</span> SynchronizedPool&lt;Node&gt;(POOL_LIMIT);</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">static</span> Node <span class="title">acquire</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">              Node node = sPool.acquire();</span><br><span class="line">              <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  node = <span class="keyword">new</span> Node();</span><br><span class="line">              &#125;</span><br><span class="line">              node.view = view;</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              view = <span class="keyword">null</span>;</span><br><span class="line">              dependents.clear();</span><br><span class="line">              dependencies.clear();</span><br><span class="line"></span><br><span class="line">              sPool.release(<span class="keyword">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>Node是用来方便我们处理RelativeLayout中的依赖关系的结点，一个Node就是一个View；在Node中会记录该View对应的依赖关系，以及它的依赖从属关系；如果一个Node没有依赖关系，那么它就是一个root，根结点</p><p>view就不用说了，就是我们的子View；dependents就是记录该View的从属关系的；dependencies记录依赖关系；sPool是SynchronizedPool（继承自SimplePool，在Pools中），就是用来存放Node来实现共享的，同时这个pool也是线程安全的</p><p>Node中通过acquire来初始化一个Node，通过release来释放，这些都很明显了</p><p>接着看看DependencyGraph的几个方法，先看一下<code>clear()</code>和<code>add()</code>方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyGraph</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//清空操作，清空容器，释放对象</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> ArrayList&lt;Node&gt; nodes = mNodes;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> count = nodes.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               nodes.get(i).release();</span><br><span class="line">           &#125;</span><br><span class="line">           nodes.clear();</span><br><span class="line">           mKeyNodes.clear();</span><br><span class="line">           mRoots.clear();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> id = view.getId();</span><br><span class="line">           <span class="comment">//将view包装成Node</span></span><br><span class="line">           <span class="keyword">final</span> Node node = Node.acquire(view);</span><br><span class="line"><span class="comment">//mKeyNodes只存放有id的View</span></span><br><span class="line">           <span class="keyword">if</span> (id != View.NO_ID) &#123;</span><br><span class="line">               mKeyNodes.put(id, node);</span><br><span class="line">           &#125;</span><br><span class="line">           mNodes.add(node);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>cleae()</code>方法很简单，就是释放Node对象，清空之前说的几个容器</p><p><code>add()</code>方法也不难，获取到子View的id，把View生成Node，然后放入对应的容器</p><p>接着看看最重要的方法，排序把<code>getSortedViews()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyGraph</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">getSortedViews</span><span class="params">(View[] sorted, <span class="keyword">int</span>... rules)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> ArrayDeque&lt;Node&gt; roots = findRoots(rules);</span><br><span class="line">           <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">           Node node;</span><br><span class="line">           <span class="keyword">while</span> ((node = roots.pollLast()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> View view = node.view;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> key = view.getId();</span><br><span class="line">               <span class="comment">//将符合规则的View加到 sorted中</span></span><br><span class="line">               sorted[index++] = view;</span><br><span class="line">               <span class="keyword">final</span> ArrayMap&lt;Node, DependencyGraph&gt; dependents = node.dependents;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> count = dependents.size();</span><br><span class="line">               <span class="comment">//遍历所有依赖自己的node</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                   <span class="keyword">final</span> Node dependent = dependents.keyAt(i);</span><br><span class="line">                   <span class="keyword">final</span> SparseArray&lt;Node&gt; dependencies = dependent.dependencies;</span><br><span class="line"></span><br><span class="line">                   dependencies.remove(key);</span><br><span class="line">                   <span class="comment">//如果解除依赖后没有其它依赖 则将该node也视为rootNode</span></span><br><span class="line">                   <span class="keyword">if</span> (dependencies.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                       roots.add(dependent);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (index &lt; sorted.length) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Circular dependencies cannot exist"</span></span><br><span class="line">                       + <span class="string">" in RelativeLayout"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//找到root，就是不依赖于任何一个View和是任何一个View是从属关系的</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> ArrayDeque&lt;Node&gt; <span class="title">findRoots</span><span class="params">(<span class="keyword">int</span>[] rulesFilter)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> SparseArray&lt;Node&gt; keyNodes = mKeyNodes;</span><br><span class="line">           <span class="keyword">final</span> ArrayList&lt;Node&gt; nodes = mNodes;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> count = nodes.size();</span><br><span class="line"><span class="comment">//清除所有的关系</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node node = nodes.get(i);</span><br><span class="line">               node.dependents.clear();</span><br><span class="line">               node.dependencies.clear();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 建立关系 遍历所有node  存入当前view和他所依赖的关系</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node node = nodes.get(i);</span><br><span class="line">               <span class="keyword">final</span> LayoutParams layoutParams = (LayoutParams) node.view.getLayoutParams();</span><br><span class="line">               <span class="comment">//根据LayoutParams获取其关系</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span>[] rules = layoutParams.mRules;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> rulesCount = rulesFilter.length;</span><br><span class="line">               <span class="comment">//遍历所有的关系</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rulesCount; j++) &#123;</span><br><span class="line">                   <span class="comment">//根据依赖关系找到对应的ViewId</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> rule = rules[rulesFilter[j]];</span><br><span class="line">                   <span class="keyword">if</span> (rule &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">// 找到有依赖关系的view</span></span><br><span class="line">                       <span class="keyword">final</span> Node dependency = keyNodes.get(rule);</span><br><span class="line">                       <span class="comment">// 跳过自己和空View</span></span><br><span class="line">                       <span class="keyword">if</span> (dependency == <span class="keyword">null</span> || dependency == node) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 添加依赖</span></span><br><span class="line">                       dependency.dependents.put(node, <span class="keyword">this</span>);</span><br><span class="line">                       <span class="comment">// 设置依赖关系（从属关系）</span></span><br><span class="line">                       node.dependencies.put(rule, dependency);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//从这里就可以知道mRoots就是一个临时的存储</span></span><br><span class="line">           <span class="keyword">final</span> ArrayDeque&lt;Node&gt; roots = mRoots;</span><br><span class="line">           roots.clear();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将没有依赖关系的node添加到roots中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node node = nodes.get(i);</span><br><span class="line">               <span class="keyword">if</span> (node.dependencies.size() == <span class="number">0</span>) roots.addLast(node);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> roots;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过<code>getSortedViews()</code>的注释，大概了解到排序的方式，根据依赖关系进行一个排序；例如View C依赖于View A，View A又依赖于View B，那么最后的排序结果就是B-&gt;A-&gt;C（我们这里的依赖就是RelativeLayout中的依赖）</p><p>根据rules（从传入的参数知道就是方向——水平、垂直）找到roots（没有任何依赖关系和从属关系的Node）</p><p>首先通过<code>findRoots()</code>获取所有得roots，在<code>findRoots()</code>中，通过LayoutParams来获取view对应的依赖关系，然后给对应Node设置对应的依赖关系，而找到对应的有依赖关系的View则是通过ViewId来的；举个例子，View A（id:viewA）依赖于View B(id:viewB），在布局文件xml中我们假设是这样写的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/viewA"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"A"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/viewB"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"B"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toEndOf</span>=<span class="string">"@+id/viewA"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/viewA"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们写了两个Button来解释，这个布局的结果就是viewB依赖于viewA，在viewA的右边；那么在findRoots的过程中，View A就是一个root，那么View B就不是，在遍历到View B时，就会根据依赖关系<code>layout_toEndOf</code>、<code>layout_toRightOf</code>来获取到View A的id<code>viewA</code>，这样就可以在mKeyNodes中获取到View A，然后将这个从属关系添加到View A的Node中（B是依赖于A的），而在View B这个Node中，它的dependency是依赖于View A的；最后遍历完所有的结点，所有root都会添加到mRoots中并返回，所有非root的Node都会与其他Node建立相应的关系</p><p>通过<code>findRoots()</code>不仅找到了root，同时将所有的node都建立了对应得关系</p><p>在<code>getSortedViews()</code>后面的遍历过程中，就主要是个排序的过程了，就是将View放置到sorted这个<code>View[]</code>中，这是前面传进来用于存放排好序的View的</p><h3 id="排序后初始化"><a href="#排序后初始化" class="headerlink" title="排序后初始化"></a>排序后初始化</h3><p>接着回到我们的onMeasure方法，先看看这个方法里的一些变量吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> myWidth = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> myHeight = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取宽度、高度的测量模式以及size</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">       <span class="comment">//如果不是UNSPECIFIED模式，那就把widthSize的值赋给myWidth </span></span><br><span class="line">       <span class="keyword">if</span> (widthMode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">           myWidth = widthSize;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//如果不是UNSPECIFIED模式 则将heightSize赋值于myHeight</span></span><br><span class="line">       <span class="keyword">if</span> (heightMode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">           myHeight = heightSize;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//如果是EXACTLY模式 则将myWidth和myHeight记录</span></span><br><span class="line">       <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">           width = myWidth;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//与宽度一样</span></span><br><span class="line">       <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">           height = myHeight;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       View ignore = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//判断是否为Start 和  top 确定左上角坐标</span></span><br><span class="line">       <span class="keyword">int</span> gravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> horizontalGravity = gravity != Gravity.START &amp;&amp; gravity != <span class="number">0</span>;</span><br><span class="line">       gravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> verticalGravity = gravity != Gravity.TOP &amp;&amp; gravity != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> left = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">int</span> top = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">int</span> right = Integer.MIN_VALUE;</span><br><span class="line">       <span class="keyword">int</span> bottom = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> offsetHorizontalAxis = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">boolean</span> offsetVerticalAxis = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//记录ignore的view</span></span><br><span class="line">       <span class="keyword">if</span> ((horizontalGravity || verticalGravity) &amp;&amp; mIgnoreGravity != View.NO_ID) &#123;</span><br><span class="line">           ignore = findViewById(mIgnoreGravity);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//宽度和高度是否是wrap模式</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentWidth = widthMode != MeasureSpec.EXACTLY;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> isWrapContentHeight = heightMode != MeasureSpec.EXACTLY;</span><br><span class="line">       <span class="comment">//在计算和分配的子View的坐标的时候 需要用到父VIew的尺寸 但是暂时无法拿到准确值(待完成下面操作)，先使用默认值代替 在计算后 用偏移量更新真是坐标</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">       <span class="keyword">if</span> (isLayoutRtl() &amp;&amp; myWidth == -<span class="number">1</span>) &#123;</span><br><span class="line">           myWidth = DEFAULT_WIDTH;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一些记录变量的初始化、获取测量模式和size以及一些相应的调整（如果不是UNSPECIFIED模式，那就把widthSize的值赋给myWidth等）</p><p>接着看后面的吧</p><h3 id="水平方向"><a href="#水平方向" class="headerlink" title="水平方向"></a>水平方向</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">View[] views = mSortedHorizontalChildren;</span><br><span class="line">       <span class="keyword">int</span> count = views.length;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           View child = views[i];</span><br><span class="line">           <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">               LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               <span class="comment">//根据方向获得子view中设置的规则</span></span><br><span class="line">               <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line"><span class="comment">//将左右方向规则转换为左右的坐标</span></span><br><span class="line">               applyHorizontalSizeRules(params, myWidth, rules);</span><br><span class="line">               <span class="comment">//测算水平方向的子View的尺寸</span></span><br><span class="line">               measureChildHorizontal(child, params, myWidth, myHeight);</span><br><span class="line"><span class="comment">//确定水平方向子View的位置</span></span><br><span class="line">               <span class="keyword">if</span> (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123;</span><br><span class="line">                   offsetHorizontalAxis = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这段代码处理的是水平方向上的关系，通过遍历水平方向关系的view，同样不处理是View.Gone的View</p><p>根据layoutDirection从LayoutParams中获取规则关系，通过<code>applyHorizontalSizeRules()</code>将规则转换为坐标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyHorizontalSizeRules</span><span class="params">(LayoutParams childParams, <span class="keyword">int</span> myWidth, <span class="keyword">int</span>[] rules)</span> </span>&#123;</span><br><span class="line">       RelativeLayout.LayoutParams anchorParams;</span><br><span class="line">       childParams.mLeft = VALUE_NOT_SET;</span><br><span class="line">       childParams.mRight = VALUE_NOT_SET;</span><br><span class="line">       <span class="comment">//得到当前子View的layout_toLeftOf属性对应的View</span></span><br><span class="line">       anchorParams = getRelatedViewParams(rules, LEFT_OF);</span><br><span class="line">       <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果这个属性存在 则当前子View的右坐标是layout_toLeftOf对应的view的左坐标减去对应view的marginLeft的值和自身marginRight的值</span></span><br><span class="line">           childParams.mRight = anchorParams.mLeft - (anchorParams.leftMargin +</span><br><span class="line">                   childParams.rightMargin);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[LEFT_OF] != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//如果alignWithParent为true alignWithParent取alignWithParentIfMissing</span></span><br><span class="line">       <span class="comment">//如果layout_toLeftOf的view为空 或者gone 则将RelativeLayout当做被依赖的对象</span></span><br><span class="line">           <span class="keyword">if</span> (myWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//如果父容器RelativeLayout的宽度大于0</span></span><br><span class="line">           <span class="comment">//则子View的右坐标为 父RelativeLayout的宽度减去 mPaddingRight 和自身的marginRight</span></span><br><span class="line">               childParams.mRight = myWidth - mPaddingRight - childParams.rightMargin;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//同样的方式，得到当前子View的layout_toRightOf属性对应的View</span></span><br><span class="line">       anchorParams = getRelatedViewParams(rules, RIGHT_OF);</span><br><span class="line">       <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">           childParams.mLeft = anchorParams.mRight + (anchorParams.rightMargin +</span><br><span class="line">                   childParams.leftMargin);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[RIGHT_OF] != <span class="number">0</span>) &#123;</span><br><span class="line">           childParams.mLeft = mPaddingLeft + childParams.leftMargin;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//同样的方式，得到当前子View的layout_toAlignLeftOf属性对应的View</span></span><br><span class="line">       anchorParams = getRelatedViewParams(rules, ALIGN_LEFT);</span><br><span class="line">       <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">           childParams.mLeft = anchorParams.mLeft + childParams.leftMargin;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[ALIGN_LEFT] != <span class="number">0</span>) &#123;</span><br><span class="line">           childParams.mLeft = mPaddingLeft + childParams.leftMargin;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//同样的方式，得到当前子View的layout_toAlignRightOf属性对应的View</span></span><br><span class="line">       anchorParams = getRelatedViewParams(rules, ALIGN_RIGHT);</span><br><span class="line">       <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">           childParams.mRight = anchorParams.mRight - childParams.rightMargin;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[ALIGN_RIGHT] != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (myWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               childParams.mRight = myWidth - mPaddingRight - childParams.rightMargin;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> != rules[ALIGN_PARENT_LEFT]) &#123;</span><br><span class="line">           childParams.mLeft = mPaddingLeft + childParams.leftMargin;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> != rules[ALIGN_PARENT_RIGHT]) &#123;</span><br><span class="line">           <span class="keyword">if</span> (myWidth &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               childParams.mRight = myWidth - mPaddingRight - childParams.rightMargin;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法就是将水平方向的关系（比如toLeftOf、toRightOf）转化为对应的坐标，就没啥看的了，很简单</p><p>回到之前的循环，<code>applyHorizontalSizeRules()</code>结束后，<code>measureChildHorizontal()</code>测量水平方向的View</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measureChildHorizontal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           View child, LayoutParams params, <span class="keyword">int</span> myWidth, <span class="keyword">int</span> myHeight)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获得child的宽度MeasureSpec</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(params.mLeft, params.mRight,</span><br><span class="line">               params.width, params.leftMargin, params.rightMargin, mPaddingLeft, mPaddingRight,</span><br><span class="line">               myWidth);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">       <span class="comment">//在低于4.2的时候 mAllowBrokenMeasureSpecs为true</span></span><br><span class="line">   <span class="comment">//当myHeight &lt; 0 时 则根据父RelativeLayout设置其MeasureSpec模式</span></span><br><span class="line">       <span class="keyword">if</span> (myHeight &lt; <span class="number">0</span> &amp;&amp; !mAllowBrokenMeasureSpecs) &#123;</span><br><span class="line">           <span class="comment">//如果父RelativeLayout的height大于0  则设置子view的MeasureSpec模式为EXACTLY</span></span><br><span class="line">       <span class="keyword">if</span> (params.height &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                       params.height, MeasureSpec.EXACTLY);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果其小于0  则设置子View的MeasureSpec为UNSPECIFIED</span></span><br><span class="line">               childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">0</span>, MeasureSpec.UNSPECIFIED);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//当当前myHeight &gt;= 0</span></span><br><span class="line">     <span class="comment">//判断当前高度是否与父RelativeLayout高度相同 设置heightMode</span></span><br><span class="line">     <span class="comment">//根据maxHeight 和heightMode设置子View的MeasureSpec模式</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> maxHeight;</span><br><span class="line">           <span class="keyword">if</span> (mMeasureVerticalWithPaddingMargin) &#123;</span><br><span class="line">               maxHeight = Math.max(<span class="number">0</span>, myHeight - mPaddingTop - mPaddingBottom</span><br><span class="line">                       - params.topMargin - params.bottomMargin);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               maxHeight = Math.max(<span class="number">0</span>, myHeight);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> heightMode;</span><br><span class="line">           <span class="keyword">if</span> (params.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               heightMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               heightMode = MeasureSpec.AT_MOST;</span><br><span class="line">           &#125;</span><br><span class="line">           childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, heightMode);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//测量子View自身</span></span><br><span class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后看看是如何获取子View的宽度测量模式的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">getChildMeasureSpec(<span class="keyword">int</span> childStart, <span class="keyword">int</span> childEnd,</span><br><span class="line">           <span class="keyword">int</span> childSize, <span class="keyword">int</span> startMargin, <span class="keyword">int</span> endMargin, <span class="keyword">int</span> startPadding,</span><br><span class="line">           <span class="keyword">int</span> endPadding, <span class="keyword">int</span> mySize) &#123;</span><br><span class="line">       <span class="keyword">int</span> childSpecMode = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> childSpecSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> isUnspecified = mySize &lt; <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (isUnspecified &amp;&amp; !mAllowBrokenMeasureSpecs) &#123;</span><br><span class="line">           <span class="keyword">if</span> (childStart != VALUE_NOT_SET &amp;&amp; childEnd != VALUE_NOT_SET) &#123;</span><br><span class="line">               <span class="comment">//如果子View的左边距和右边距都不为VALUE_NOT_SET</span></span><br><span class="line">           <span class="comment">//且右边距坐标大于左边距坐标 则将其差当做宽度赋予View 设置模式为EXACTLY</span></span><br><span class="line">               childSpecSize = Math.max(<span class="number">0</span>, childEnd - childStart);</span><br><span class="line">               childSpecMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childSize &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//如果childSpecSize &gt;= 0 则赋值于childSpecSize，同样设置模式为EXACTLY</span></span><br><span class="line">               childSpecSize = childSize;</span><br><span class="line">               childSpecMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 都不满足则设置模式为UNSPECIFIED</span></span><br><span class="line">               childSpecSize = <span class="number">0</span>;</span><br><span class="line">               childSpecMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> tempStart = childStart;</span><br><span class="line">       <span class="keyword">int</span> tempEnd = childEnd;</span><br><span class="line">       <span class="comment">//如果没有指定start值 则默认赋予 padding和merage的值</span></span><br><span class="line">       <span class="keyword">if</span> (tempStart == VALUE_NOT_SET) &#123;</span><br><span class="line">           tempStart = startPadding + startMargin;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (tempEnd == VALUE_NOT_SET) &#123;</span><br><span class="line">           tempEnd = mySize - endPadding - endMargin;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//指定最大可提供的大小</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> maxAvailable = tempEnd - tempStart;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (childStart != VALUE_NOT_SET &amp;&amp; childEnd != VALUE_NOT_SET) &#123;</span><br><span class="line">           <span class="comment">//如果Start和End都是有效值 根据isUnspecified设置specMode为UNSPECIFIED或EXACTLY，并将设置对应的size</span></span><br><span class="line">           childSpecMode = isUnspecified ? MeasureSpec.UNSPECIFIED : MeasureSpec.EXACTLY;</span><br><span class="line">           childSpecSize = Math.max(<span class="number">0</span>, maxAvailable);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (childSize &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//设置模式为EXACTLY，判断maxAvailable和childSize情况 取较大值设置为childSpecSize</span></span><br><span class="line">               childSpecMode = MeasureSpec.EXACTLY;</span><br><span class="line">               <span class="keyword">if</span> (maxAvailable &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// We have a maximum size in this dimension.</span></span><br><span class="line">                   childSpecSize = Math.min(maxAvailable, childSize);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// We can grow in this dimension.</span></span><br><span class="line">                   childSpecSize = childSize;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childSize == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               <span class="comment">//如果子View是match模式 参照isUnspecified设置相关</span></span><br><span class="line">               childSpecMode = isUnspecified ? MeasureSpec.UNSPECIFIED : MeasureSpec.EXACTLY;</span><br><span class="line">               childSpecSize = Math.max(<span class="number">0</span>, maxAvailable);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childSize == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to wrap content. Use AT_MOST to communicate</span></span><br><span class="line">               <span class="comment">// available space if we know our max size.</span></span><br><span class="line">               <span class="keyword">if</span> (maxAvailable &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// We have a maximum size in this dimension.</span></span><br><span class="line">                   childSpecMode = MeasureSpec.AT_MOST;</span><br><span class="line">                   childSpecSize = maxAvailable;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// We can grow in this dimension. Child can be as big as it</span></span><br><span class="line">                   <span class="comment">// wants.</span></span><br><span class="line">                   childSpecMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">                   childSpecSize = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>至此就水平方向的View就第一次测量完了，接着就是计算位置了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">positionChildHorizontal</span><span class="params">(View child, LayoutParams params, <span class="keyword">int</span> myWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> wrapContent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取RelativeLayout的布局方向</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">       <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (params.mLeft == VALUE_NOT_SET &amp;&amp; params.mRight != VALUE_NOT_SET) &#123;</span><br><span class="line">           <span class="comment">// 如果右边界有效 左边界无效 根据右边界计算出左边界</span></span><br><span class="line">           params.mLeft = params.mRight - child.getMeasuredWidth();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.mLeft != VALUE_NOT_SET &amp;&amp; params.mRight == VALUE_NOT_SET) &#123;</span><br><span class="line">           <span class="comment">// 与上面相反</span></span><br><span class="line">           params.mRight = params.mLeft + child.getMeasuredWidth();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.mLeft == VALUE_NOT_SET &amp;&amp; params.mRight == VALUE_NOT_SET) &#123;</span><br><span class="line">          <span class="comment">//都无效的时候</span></span><br><span class="line">           <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_HORIZONTAL] != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!wrapContent) &#123;</span><br><span class="line">                   <span class="comment">//非wrap情况下，把子View水平中心固定在RelativeLayout的中心</span></span><br><span class="line">                   centerHorizontal(child, params, myWidth);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//wrap情况下，左边距为padding+margin，右边距为左边距加上测量宽度</span></span><br><span class="line">                   positionAtEdge(child, params, myWidth);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// This is the default case. For RTL we start from the right and for LTR we start</span></span><br><span class="line">               <span class="comment">// from the left. This will give LEFT/TOP for LTR and RIGHT/TOP for RTL.</span></span><br><span class="line">               positionAtEdge(child, params, myWidth);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> rules[ALIGN_PARENT_END] != <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>到此，一个子View的位置就算确定了</p><h3 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h3><p>接着看垂直方向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">views = mSortedVerticalChildren;</span><br><span class="line">       count = views.length;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = views[i];</span><br><span class="line">           <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">               <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line"><span class="comment">//和水平方向是同样的方法</span></span><br><span class="line">               applyVerticalSizeRules(params, myHeight, child.getBaseline());</span><br><span class="line">               measureChild(child, params, myWidth, myHeight);</span><br><span class="line">               <span class="keyword">if</span> (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123;</span><br><span class="line">                   offsetVerticalAxis = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                           width = Math.max(width, myWidth - params.mLeft);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           width = Math.max(width, myWidth - params.mLeft + params.leftMargin);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                           width = Math.max(width, params.mRight);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           width = Math.max(width, params.mRight + params.rightMargin);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">                       height = Math.max(height, params.mBottom);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       height = Math.max(height, params.mBottom + params.bottomMargin);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (child != ignore || verticalGravity) &#123;</span><br><span class="line">                   left = Math.min(left, params.mLeft - params.leftMargin);</span><br><span class="line">                   top = Math.min(top, params.mTop - params.topMargin);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (child != ignore || horizontalGravity) &#123;</span><br><span class="line">                   right = Math.max(right, params.mRight + params.rightMargin);</span><br><span class="line">                   bottom = Math.max(bottom, params.mBottom + params.bottomMargin);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>整体的逻辑基本和水平方向的一致，所以就不细细再分析了</p><h3 id="Baseline的计算"><a href="#Baseline的计算" class="headerlink" title="Baseline的计算"></a>Baseline的计算</h3><p>接着看后面的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">View baselineView = <span class="keyword">null</span>;</span><br><span class="line">       LayoutParams baselineParams = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = views[i];</span><br><span class="line">           <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">               <span class="keyword">final</span> LayoutParams childParams = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               <span class="keyword">if</span> (baselineView == <span class="keyword">null</span> || baselineParams == <span class="keyword">null</span></span><br><span class="line">                       || compareLayoutPosition(childParams, baselineParams) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   baselineView = child;</span><br><span class="line">                   baselineParams = childParams;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       mBaselineView = baselineView;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是重新计算了Baseline</p><h3 id="一些修正"><a href="#一些修正" class="headerlink" title="一些修正"></a>一些修正</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">       <span class="comment">//宽度是wrap_content</span></span><br><span class="line"><span class="keyword">if</span> (isWrapContentWidth) &#123;</span><br><span class="line">           width += mPaddingRight;</span><br><span class="line">           <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.width &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               width = Math.max(width, mLayoutParams.width);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           width = Math.max(width, getSuggestedMinimumWidth());</span><br><span class="line">           width = resolveSize(width, widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (offsetHorizontalAxis) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                   <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                   <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                       <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                       <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_HORIZONTAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                           centerHorizontal(child, params, width);</span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_RIGHT] != <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">                           params.mLeft = width - mPaddingRight - childWidth;</span><br><span class="line">                           params.mRight = params.mLeft + childWidth;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//高度是wrap_content</span></span><br><span class="line">       <span class="keyword">if</span> (isWrapContentHeight) &#123;</span><br><span class="line">           height += mPaddingBottom;</span><br><span class="line">           <span class="keyword">if</span> (mLayoutParams != <span class="keyword">null</span> &amp;&amp; mLayoutParams.height &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               height = Math.max(height, mLayoutParams.height);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           height = Math.max(height, getSuggestedMinimumHeight());</span><br><span class="line">           height = resolveSize(height, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (offsetVerticalAxis) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                   <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                   <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                       <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">int</span>[] rules = params.getRules(layoutDirection);</span><br><span class="line">                       <span class="keyword">if</span> (rules[CENTER_IN_PARENT] != <span class="number">0</span> || rules[CENTER_VERTICAL] != <span class="number">0</span>) &#123;</span><br><span class="line">                           centerVertical(child, params, height);</span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rules[ALIGN_PARENT_BOTTOM] != <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                           params.mTop = height - mPaddingBottom - childHeight;</span><br><span class="line">                           params.mBottom = params.mTop + childHeight;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//根据gravity再次修正</span></span><br><span class="line">       <span class="keyword">if</span> (horizontalGravity || verticalGravity) &#123;</span><br><span class="line">           <span class="keyword">final</span> Rect selfBounds = mSelfBounds;</span><br><span class="line">           selfBounds.set(mPaddingLeft, mPaddingTop, width - mPaddingRight,</span><br><span class="line">                   height - mPaddingBottom);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> Rect contentBounds = mContentBounds;</span><br><span class="line">           Gravity.apply(mGravity, right - left, bottom - top, selfBounds, contentBounds,</span><br><span class="line">                   layoutDirection);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> horizontalOffset = contentBounds.left - left;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> verticalOffset = contentBounds.top - top;</span><br><span class="line">           <span class="keyword">if</span> (horizontalOffset != <span class="number">0</span> || verticalOffset != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                   <span class="keyword">final</span> View child = views[i];</span><br><span class="line">                   <span class="keyword">if</span> (child.getVisibility() != GONE &amp;&amp; child != ignore) &#123;</span><br><span class="line">                       <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                       <span class="keyword">if</span> (horizontalGravity) &#123;</span><br><span class="line">                           params.mLeft += horizontalOffset;</span><br><span class="line">                           params.mRight += horizontalOffset;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (verticalGravity) &#123;</span><br><span class="line">                           params.mTop += verticalOffset;</span><br><span class="line">                           params.mBottom += verticalOffset;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> <span class="comment">//如果是RTL(右到左显示)则再次修改</span></span><br><span class="line">       <span class="keyword">if</span> (isLayoutRtl()) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> offsetWidth = myWidth - width;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               <span class="keyword">final</span> View child = views[i];</span><br><span class="line">               <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                   <span class="keyword">final</span> LayoutParams params = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                   params.mLeft -= offsetWidth;</span><br><span class="line">                   params.mRight -= offsetWidth;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//设置测量后的Dimension</span></span><br><span class="line">       setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些修正也十分简单，在满足条件下，进行params上的一些重新计算和修正</p><p>最后设置测量后的Dimension，至此，onMeasure结束</p><h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//  The layout has actually already been performed and the positions</span></span><br><span class="line">       <span class="comment">//  cached.  Apply the cached values to the children.</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           View child = getChildAt(i);</span><br><span class="line">           <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">               RelativeLayout.LayoutParams st =</span><br><span class="line">                       (RelativeLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">               child.layout(st.mLeft, st.mTop, st.mRight, st.mBottom);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>onLayout过程基本没啥逻辑了，就是根据left、top、right、bottom来放置子View</p><h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>RelativeLayout没有重写onDraw方法，就是ViewGroup的默认实现</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要就是onMeasure过程</p><ol><li>先把内部子view根据纵向关系和横向关系排序（排序的过程，会遍历所有的view，并记录他们的依赖关系）</li><li>初始化一些变量值</li><li>遍历水平关系的view</li><li>遍历竖直关系的view</li><li>baseline计算</li><li>宽度和高度修正</li></ol><h2 id="FrameLayout、LinearLayout和RelativeLayout的性能对比"><a href="#FrameLayout、LinearLayout和RelativeLayout的性能对比" class="headerlink" title="FrameLayout、LinearLayout和RelativeLayout的性能对比"></a>FrameLayout、LinearLayout和RelativeLayout的性能对比</h2><p>当RelativeLayout和LinearLayout作为ViewGroup表达相同的布局的时候，谁的绘制更快一些，性能相对更好一些？</p><p>通过网上的很多实验结果我们得之，两者绘制同样的界面时layout和draw的过程时间消耗相差无几，关键在于measure过程RelativeLayout比LinearLayout慢了一些。我们知道ViewGroup是没有onMeasure方法的，这个方法是交给子类自己实现的。因为不同的ViewGroup子类布局都不一样，那么onMeasure索性就全部交给他们自己实现好了</p><p>LinearLayout：在没有权重的情况下，就只会单纯的遍历一个方向，遍历一次所有的View；如果View设置了权重 ，那么在第一次遍历的时候这个View是不会进行测量的，在第二次测量（专门用于测量权weight重的）；所以无权重一次遍历，有权重两次遍历</p><p>RelativeLayout：因为依赖关系，所以在进行排序后，分别会对水平、垂直方向进行遍历，所以两次遍历</p><p>FrameLayout：某种情况上来说，FrameLayout也可能导致二次测量，不过FrameLayout的二次测量就只针对View为match_parent的了</p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p><a href="https://www.jianshu.com/p/540342ea3f75" target="_blank" rel="noopener">Android View 相关源码分析之五 RelativeLayout 源码分析</a></p><p><a href="https://blog.csdn.net/wz249863091/article/details/51757069" target="_blank" rel="noopener">RelativeLayout源码解析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android——EventBus源码分析</title>
      <link href="/2019/04/30/Android%20EventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/30/Android%20EventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="EventBus3-0-简单分析"><a href="#EventBus3-0-简单分析" class="headerlink" title="EventBus3.0 简单分析"></a>EventBus3.0 简单分析</h1><h2 id="获取单例"><a href="#获取单例" class="headerlink" title="获取单例"></a>获取单例</h2><p>首先我们看一下使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>我们通过这样来注册一个订阅者</p><p><code>getDefualt()</code>就是获取一个EventBus的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">               <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> defaultInstance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>很明显，就是通过DCL的形式来获取一个单例</p><p>然后接着看看EventBus实例化中做了什么事吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">       <span class="comment">//EventBus特用的log</span></span><br><span class="line">       logger = builder.getLogger();</span><br><span class="line">       subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">       mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">       mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line">       backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">       asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">       indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">       subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">               builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">       logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">       logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">       sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">       sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">       throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">       eventInheritance = builder.eventInheritance;</span><br><span class="line">       executorService = builder.executorService;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过默认的EventBusBuilder来进行初始化，就是一个Builder模式，DEFAULT_BUILDER的实例化就是一个空实现</p><p>然后我们看到在具体初始化中，初始化了很多参数，这些参数需要好好看一下</p><ul><li>logger：就是EventBus用的log</li><li>subscriptionsByEventType：一个Map集合，具体类型是<code>Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt;</code>，也就是这个Map中存放的是以Class为key，List为value，这里的key其实就是事件类型，后面会分析到，CopyOnWriteArrayList其实就是一个Subscription的list，而这个Subscription是一个包含订阅者和其对应的方法的一个类</li><li>typesBySubscriber：也是一个Map集合，具体类型是<code>Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt;</code>，以订阅者为key，订阅者订阅的所有事件为value，这个后面也会讲到</li><li>stickyEvents：一个线程安全的Map集合，具体是<code>Map&lt;Class&lt;?&gt;, Object&gt;</code>，粘性事件的缓存</li><li>mainThreadSupport：MainThreadSupport，根据主线程Looper创建的一个类，还包含了EventBus发射器Poster</li><li>mainThreadPoster：处于主线程的发射器，通过MainThreadSupport直接创建的</li><li>backgroundPoster：同步发射器</li><li>asyncPoster：异步发射器</li><li>subscriberMethodFinder：订阅者方法查找类，根据订阅者的类信息来查找里面订阅方法，注册的时候会讲到</li><li>executorService：线程池</li></ul><p>好，这里就大概知道这么多，后面注册的时候再仔细了解</p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>接下来看看register方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">       Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">               subscribe(subscriber, subscriberMethod);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用的时候，这个subscriber是我们传递的Activity，然后通过<code>getClass()</code>来获取Class，接着subscriberMethodFinder来查找当前subscriber的所有订阅方法，先看看这个查找吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">       <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">           subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                   + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">           <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>METHOD_CACHE</code>是<code>Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = new ConcurrentHashMap&lt;&gt;();</code>这样定义的，说明它是一个线程安全的集合，同时我们可以看到，这是SubscriberMethodFinder类内部维持的一个集合，就是一个subscriber和subscriberMethods的关系集合，说得明白点就是订阅者和其订阅方法的Map</p><p>在上面这个方法中，先是从缓存中看能不能获取到这个订阅者相应的订阅方法，有的话直接返回；没有的话，就接着看后面的代码</p><p>先是一个<code>ignoreGeneratedIndex</code>（是否忽略生成index）的一个判断，这个属性是前面实例化<code>SubscriberMethodFinder</code>时传入的，也是EventBus初始化时传入的，由于我们默认的EventBusBuilder是一个空实现，所以这里就是默认值false；这里就是来决定获取订阅者的方法是怎样来获取的，我们两个都看看吧；在获取到订阅方法后，会放入<code>METHOD_CACHE</code>中</p><h3 id="findUsingReflection（自定义注解器，索引）"><a href="#findUsingReflection（自定义注解器，索引）" class="headerlink" title="findUsingReflection（自定义注解器，索引）"></a>findUsingReflection（自定义注解器，索引）</h3><p>当ignoreGeneratedIndex为true时，执行的是<code>findUsingReflection(subscriberClass)</code>，通过反射来获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//初始化FindState对象</span></span><br><span class="line">       FindState findState = prepareFindState();</span><br><span class="line">       <span class="comment">//关联订阅者</span></span><br><span class="line">       findState.initForSubscriber(subscriberClass);</span><br><span class="line">       <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//在单个类中查找方法并放在findState中</span></span><br><span class="line">           findUsingReflectionInSingleClass(findState);</span><br><span class="line">           <span class="comment">//查找父类</span></span><br><span class="line">           findState.moveToSuperclass();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回订阅者及其父类的方法</span></span><br><span class="line">       <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先会初始化一个FindState对象（通过<code>prepareFindState()</code>会先在缓存中查找，没有的话会直接new一个），这个类是SubscriberMethodFinder的一个内部类，就是用来辅助我们查找订阅方法的，先简单看看它的属性吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FindState</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">final</span> Map&lt;Class, Object&gt; anyMethodByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">final</span> Map&lt;String, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">final</span> StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">       Class&lt;?&gt; subscriberClass;</span><br><span class="line">       Class&lt;?&gt; clazz;</span><br><span class="line">       <span class="keyword">boolean</span> skipSuperClasses;</span><br><span class="line">       SubscriberInfo subscriberInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，这个类里面的属性有很多，包含了订阅方法、根据事件类型来存储的方法等</p><p>回到之前，初始化FindState对象后，然后通过<code>findState.initForSubscriber(subscriberClass)</code>关联上订阅者SubscriberClass，接着通过判定<code>findState.clazz</code>是否为空来结束查找（有点链表的思想在里面），接着通过<code>findUsingReflectionInSingleClass(findState)</code>来进行具体的查找，查找结果就会存储在FindState中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">       Method[] methods;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//通过getDeclaredMethods获取方法，这会比getMethods快很多，特别是订阅者是Activity的时候</span></span><br><span class="line">           methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">           <span class="comment">//当通过getDeclaredMethods找不到的时候再通过getMethods来获取</span></span><br><span class="line">           methods = findState.clazz.getMethods();</span><br><span class="line">           findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//遍历所有的方法</span></span><br><span class="line">       <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">           <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">           <span class="comment">//忽略掉非public和static方法</span></span><br><span class="line">           <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//获取参数</span></span><br><span class="line">               Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">               <span class="comment">//订阅者的方法参数只能是一个，就是传递的事件</span></span><br><span class="line">               <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="comment">//获取注解</span></span><br><span class="line">                   Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                   <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">// 检查eventType决定是否订阅，通常订阅者不能有多个eventType相同的订阅方法</span></span><br><span class="line">                       <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                           <span class="comment">//线程模式</span></span><br><span class="line">                           ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                           <span class="comment">//添加到findState对象中的list中</span></span><br><span class="line">                           findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                   subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                   String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                           <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">               String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                       <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>直接通过Class来获取所有的方法，然后对订阅者的所有方法进行一个过滤，将订阅方法筛选出来，保存到FindState对象中，具体的过滤就是根据订阅方法的一些特性：比如说只能是public修饰、只能有一个参数（事件）、注解等</p><p>接着回到<code>findUsingReflection()</code>方法，通过<code>findUsingReflectionInSingleClass(findState)</code>将SubscriberClass中所有的对象保存到FindState中后，通过<code>findState.moveToSuperclass()</code>查找订阅者的父类，以同样的方式去查找是否有订阅方法，最后通过<code>getMethodsAndRelease(findState)</code>返回所有的订阅方法，并添加到缓存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">       findState.recycle();</span><br><span class="line">       <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   FIND_STATE_POOL[i] = findState;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="findUsingInfo（没有自定义注解器，无索引）"><a href="#findUsingInfo（没有自定义注解器，无索引）" class="headerlink" title="findUsingInfo（没有自定义注解器，无索引）"></a>findUsingInfo（没有自定义注解器，无索引）</h3><p>接着分析当ignoreGeneratedIndex为false，执行的是<code>findUsingInfo(subscriberClass)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//同样会准备一个FindState对象，辅助查找</span></span><br><span class="line">       FindState findState = prepareFindState();</span><br><span class="line">       findState.initForSubscriber(subscriberClass);</span><br><span class="line">       <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//获取对应的SubscriberInfo</span></span><br><span class="line">           findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">           <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//通过SubscriberInfo获取订阅方法</span></span><br><span class="line">               SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">               <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                       findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//通过反射获取</span></span><br><span class="line">               findUsingReflectionInSingleClass(findState);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//查找父类</span></span><br><span class="line">           findState.moveToSuperclass();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这个获取订阅方法的方式是前面通过反射获取是类似的，都是借助了FindState这个对象；在具体查找的时候，先是通过SubscriberInfo是否为null来决定具体的查找方式，如果为null最后还是调用的反射去获取订阅方法，如果不为null，则是通过SubscriberInfo直接获取订阅方法</p><p>我们先看看SubscriberInfo是怎么来的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">           <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">               <span class="keyword">return</span> superclassInfo;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">               SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">               <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> info;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先通过FindState中拿到SubscriberInfo，但是如果之前缓存中没有FindState，FindState就是通过new的，那么FindState中的SubscriberInfo就为null</p><p>那么接着就判断subscriberInfoIndexes，这个是我们在创建SubscriberMethodFinder时传进来的，也就是在获取EventBus单例时初始化的，具体就是EventBusBuilder中设置的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Adds an index generated by EventBus' annotation preprocessor. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventBusBuilder <span class="title">addIndex</span><span class="params">(SubscriberInfoIndex index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (subscriberInfoIndexes == <span class="keyword">null</span>) &#123;</span><br><span class="line">           subscriberInfoIndexes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       subscriberInfoIndexes.add(index);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这就是一个list，而且是通过EventBus的注解器生成的，具体自己就去了解一下吧，官方推荐使用这种方式哦</p><p>总之在<code>findUsingInfo()</code>中，如果有注解器生成的SubscriberInfoIndex，那么就可以直接通过SubscriberInfo获取到所有的订阅方法，默认是没有的，那么就会通过反射的方式去获取所有的订阅方法</p><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>回到最开始，register方法，获取到所有的订阅方法后，就会进行订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">       Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="comment">//通过遍历所有订阅方法进行订阅</span></span><br><span class="line">           <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">               subscribe(subscriber, subscriberMethod);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过遍历订阅方法，然后进行订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//事件类型 </span></span><br><span class="line">       Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">       Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">       CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">       <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">           subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">           subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                       + eventType);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">               subscriptions.add(i, newSubscription);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">       <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">           subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">       &#125;</span><br><span class="line">       subscribedEvents.add(eventType);</span><br><span class="line"><span class="comment">//粘性事件的处理</span></span><br><span class="line">       <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">           <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">               Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">               <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                   Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                   <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                       Object stickyEvent = entry.getValue();</span><br><span class="line">                       checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">               checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先获取到事件类型eventType，接着将subscriber和subscriberMethod组装成Subscription；接着从<code>subscriptionsByEventType</code>中根据事件类型获取到所有的Subscription，这个<code>subscriptionsByEventType</code>就是我们前面EventBus初始化讲到的根据事件类型为key和subscriptions为value的HashMap，这就是维护的一个总线缓存；先是根据事件类型获取对应的Subscription列表，没有就会new一个，然后将新的subscription存进去，如果<code>subscriptionsByEventType</code>中已经有了相同的Subscription，那么就会抛出异常（当你重复注册一个订阅者的时候就会抛出，反正我是遇到了）</p><p>如果相同的EventTyoe对应的Subscriptions没有包含这个新的Subscription，那么就会遍历该EventType下的所有Subscription，根据订阅方法的优先级插入到这个subscriptions中</p><p>接着<code>typesBySubscriber.get(subscriber)</code>根据订阅者获取了所有的订阅事件，前面我们EventBus初始化的时候，typesBySubscriber就是一个HashMap，从这里就可以知道它真的是以订阅者为key，订阅者订阅的所有事件为value；这里根据订阅者subscriber取出了所有的订阅事件，同样，如果这个list不存在就会new一个，并将这个新的事件类型放进去</p><p>到这里，一般的事件，就完成了订阅</p><p>后面就是粘性事件的处理了，eventInheritance就是是否继承的事件，也是在EventBus实例化的时候传进的，最后通过<code>checkPostStickyEventToSubscription()</code>来发送粘性事件，这里就暂且不分析了，我们回到主要的一般事件就ok了</p><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><p>一般事件的发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> ObjectEvent);</span><br></pre></td></tr></table></figure><p>还是先获取到EventBus的单例，这里开头分析过了，所以发送的时候就是直接获取到之前的单例了</p><p>直接看post方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前线程的posting状态</span></span><br><span class="line">       PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">       <span class="comment">//获取事件队列</span></span><br><span class="line">       List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">       eventQueue.add(event);</span><br><span class="line">       <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">           postingState.isMainThread = isMainThread();</span><br><span class="line">           postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                   postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">               postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先是根据ThreadLocal获取到了当前线程的posting状态，接着获取当前线程的队列，将事件添加到队列中，当前线程没有正在发送事件时，设置发送状态，然后通过遍历队列，通过<code>postSingleEvent(eventQueue.remove(0), postingState);</code>来发送事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">       Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">       <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">           List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">           <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">               Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">               subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果没有找到对应的Subscription，那么就是没有订阅者的事件，就会发送NoSubscriberEvent</span></span><br><span class="line">       <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">           <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">               logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                   eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">               <span class="comment">//发送规定的NoSubscriberEvent，后面的过程跟现在的差不多</span></span><br><span class="line">               post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先看是否开启了事件继承，如果是（<code>eventInheritance == true</code>），则会找出发布事件的所有父类<code>lookupAllEventTypes(eventClass)</code>，然后遍历每个事件类型类型发布</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">           List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">           <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">               eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">               <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   eventTypes.add(clazz);</span><br><span class="line">                   addInterfaces(eventTypes, clazz.getInterfaces());</span><br><span class="line">                   clazz = clazz.getSuperclass();</span><br><span class="line">               &#125;</span><br><span class="line">               eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> eventTypes;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>查找父类所有的使劲按类型，并且放入缓存eventTypesCache中</p><p>如果不是（<code>eventInheritance == false</code>），则直接通过<code>postSingleEventForEventType()</code>发送事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">      CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="comment">//取出Subscriptions</span></span><br><span class="line">          subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">              postingState.event = event;</span><br><span class="line">              postingState.subscription = subscription;</span><br><span class="line">              <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                  aborted = postingState.canceled;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                  postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                  postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据事件类型取出Subscriptions，遍历所有的Subscription，将之添加到PostingThreadState中，通过<code>postToSubscription(subscription, event, postingState.isMainThread);</code>发送出去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">          <span class="keyword">case</span> POSTING:</span><br><span class="line">              invokeSubscriber(subscription, event);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> MAIN:</span><br><span class="line">              <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                  invokeSubscriber(subscription, event);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">              <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                  invokeSubscriber(subscription, event);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">              <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                  backgroundPoster.enqueue(subscription, event);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  invokeSubscriber(subscription, event);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> ASYNC:</span><br><span class="line">              asyncPoster.enqueue(subscription, event);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据不同的线程模式，进行对应的转发</p><ul><li>POSTING：事件在哪种线程发送，就在哪种线程订阅</li><li>MAIN：无论事件在什么线程发送，都在主线程接收</li><li>BACKGROUND：如果发送的线程不是主线程，则在该线程订阅，如果是主线程发送，则使用一个单独的后台线程订阅</li><li>ASYNC：在非主线程和发布线程种订阅</li></ul><p>不管是哪种线程模式，都会调用<code>invokeSubscriber(subscription, event);</code>发送到对应的订阅者那里</p><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>接着就看看接收吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">           handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在这里，在Subscription种取出订阅方法SubscriberMethod，然后进行订阅（通过Java API直接调用），事件就发送到我们的订阅方法中了</p><h2 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h2><p>通常我们通过如下来取消注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>直接看unregister方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">       <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">               unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">           &#125;</span><br><span class="line">           typesBySubscriber.remove(subscriber);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过订阅者（待取消订阅的订阅者）从缓存中获取所有的订阅的事件类型，遍历事件类型，进行取消订阅，并从缓存中移除该订阅者的相关订阅事件类型</p><p>接着看看<code>unsubscribeByEventType(subscriber, eventType);</code>取消订阅吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">       List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">       <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">               Subscription subscription = subscriptions.get(i);</span><br><span class="line">               <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                   subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                   subscriptions.remove(i);</span><br><span class="line">                   i--;</span><br><span class="line">                   size--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>根据事件类型，从subscriptionsByEventType缓存中获取所有的Subscription，然后遍历移除，自此就取消订阅了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>获取EventBus单例，进行EventBus的初始化，初始化几个缓存subscriptionsByEventType、typesBySubscriber、stickyEvents和相应的线程池、注解器等参数</li><li>subscriptionsByEventType对应着事件类型和其对应的Subscription的list，Subscription是订阅者和订阅方法组装的一个类，可根据事件类型获取所有的Subscription；typesBySubscriber对应着订阅者和事件类型list，可根据订阅者获取它订阅的所有事件；stickyEvents就是粘性事件的缓存</li><li>注册时，根据订阅者获取到它所有的订阅方法（SubscriberMethodFinder和FindState）；有注解器就通过注解器获取，没有最后都会通过反射和注解以及一些订阅方法的条件进行过滤出所有的订阅方法（有可能要查找父类中的订阅方法）</li><li>获取到所有的订阅方法后，对每个方法进行订阅；将订阅者和订阅方法组装成一个Subscription根据优先级放入EventBus初始化时的一个HashMap缓存，防止重复订阅；通过订阅方法获取订阅事件类型，通过Subscriber订阅者获取缓存中它所有相关的订阅事件，把这个新的添加进去</li><li>发送：获取当前线程的状态，获取当前的事件发送队列，死循环队列，然后进行发送；发送前会根据事件类型查找所有对应的Subscription（如果是由继承的事件，则要查找父类），然后遍历所有的Subscription，通过线程池根据对应的线程模式，进行对应的发送</li><li>接收：最后通过Subscription获取到对应的订阅方法SubscriberMethod直接调用对应的方法进行事件的接收</li><li>最后取消注册，从EventBus的两个缓存中移除相关的信息</li></ul><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p><a href="https://juejin.im/post/5a3e19c26fb9a0452207b6b5" target="_blank" rel="noopener">Android开源库——EventBus源码解析</a></p><p><a href="https://segmentfault.com/a/1190000014758421#articleHeader6" target="_blank" rel="noopener">EventBus源码分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android第三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android View系列(三)——LinearLayout源码分析</title>
      <link href="/2019/04/29/Android%20View%E7%B3%BB%E5%88%97(%E4%B8%89)%E2%80%94%E2%80%94LinearLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/29/Android%20View%E7%B3%BB%E5%88%97(%E4%B8%89)%E2%80%94%E2%80%94LinearLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="LinearLayout-源码分析"><a href="#LinearLayout-源码分析" class="headerlink" title="LinearLayout 源码分析"></a>LinearLayout 源码分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LinearLayout是我们开发中最常用的布局之一了，就是我们所说的线程布局，其分水平（HORIZONTAL）和垂直（VERTICAL）两个方向进行布局，接下来我们就慢慢看看这个LinearLayout</p><p>首先看看类的继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，直接继承自ViewGroup，当然，其他常用的布局RealativeLayout、FrameLayout等都是直接继承ViewGroup的</p><p>接着简单看看LinearLayout中的一些属性吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平方向和垂直方向</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HORIZONTAL = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERTICAL = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//几种分割线的状态</span></span><br><span class="line">   <span class="comment">//不展示dividers</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHOW_DIVIDER_NONE = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//展示dividers在group的前面</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHOW_DIVIDER_BEGINNING = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//给viewgroup的每一个item之间都展示divider</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHOW_DIVIDER_MIDDLE = <span class="number">2</span>;</span><br><span class="line">   <span class="comment">//展示在ViewGroup的后面</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHOW_DIVIDER_END = <span class="number">4</span>;</span><br><span class="line">...</span><br><span class="line">   <span class="comment">//基线对齐变量</span></span><br><span class="line">   <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> mBaselineAligned = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//基线对齐对象index</span></span><br><span class="line">   <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mBaselineAlignedChildIndex = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//基线的额外偏移量</span></span><br><span class="line">   <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"measurement"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mBaselineChildTop = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//方向</span></span><br><span class="line">   <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"measurement"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mOrientation;</span><br><span class="line">...</span><br><span class="line">   <span class="comment">//对齐方式</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mGravity = Gravity.START | Gravity.TOP;</span><br><span class="line"><span class="comment">//整个LinearLayout子View的高度和（Vertical）或者宽度和（Historical）</span></span><br><span class="line">   <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"measurement"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mTotalLength;</span><br><span class="line"><span class="comment">//权重和</span></span><br><span class="line">   <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> mWeightSum;</span><br><span class="line"><span class="comment">//权重最小尺寸对象</span></span><br><span class="line">   <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> mUseLargestChild;</span><br><span class="line"><span class="comment">//基线对齐相关</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span>[] mMaxAscent;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span>[] mMaxDescent;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERTICAL_GRAVITY_COUNT = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//几种index</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_CENTER_VERTICAL = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_TOP = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_BOTTOM = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_FILL = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//分割线相关</span></span><br><span class="line">   <span class="keyword">private</span> Drawable mDivider;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mDividerWidth;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mDividerHeight;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mShowDividers;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mDividerPadding;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mLayoutDirection = View.LAYOUT_DIRECTION_UNDEFINED;</span><br></pre></td></tr></table></figure><p>属性简单就看这么多吧，接着进入重点吧，看看LinearLayout是怎么测量、布局、绘制的</p><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">           measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在onMeasure方法中，对方向进行了判断，来决定是垂直测量还是横向测量，我们就看垂直方向的吧</p><p>由于方法有点长，分几个部分一点一点看吧，先看这个函数内的一些变量吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//每次测量都会将ziView的高度和进行初始化</span></span><br><span class="line">       mTotalLength = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//子View最大宽度，不包括含有layout_weight权重的子View</span></span><br><span class="line">       <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//测量状态</span></span><br><span class="line">       <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//子View中layout_weight &lt;= 0的最大高度</span></span><br><span class="line">       <span class="keyword">int</span> alternativeMaxWidth = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//子View中layout_weight &gt; 0的最大高度</span></span><br><span class="line">       <span class="keyword">int</span> weightedMaxWidth = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//是否全是match_parent</span></span><br><span class="line">       <span class="keyword">boolean</span> allFillParent = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//子View权重和</span></span><br><span class="line">       <span class="keyword">float</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//子View个数</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line"><span class="comment">//测量模式</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"><span class="comment">//为match_parent时未true</span></span><br><span class="line">       <span class="keyword">boolean</span> matchWidth = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">boolean</span> skippedMeasure = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//基线对齐的对象index</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> baselineChildIndex = mBaselineAlignedChildIndex;</span><br><span class="line">       <span class="comment">//权重最小尺寸对象</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> useLargestChild = mUseLargestChild;</span><br><span class="line">       <span class="comment">//子View中最高高度</span></span><br><span class="line">       <span class="keyword">int</span> largestChildHeight = Integer.MIN_VALUE;</span><br><span class="line">       <span class="keyword">int</span> consumedExcessSpace = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//能够显示的View个数</span></span><br><span class="line">       <span class="keyword">int</span> nonSkippedChildCount = <span class="number">0</span>;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这些变量大致的意思都写在代码注释里了，简单过一下就ok了</p><p>接着看看方法内的后面一部分，测量所有的子View</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// See how tall everyone is. Also remember max width.</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">           <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//为null，+0</span></span><br><span class="line">               mTotalLength += measureNullChild(i);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//View.GONE的子View也不会计算在里面</span></span><br><span class="line">           <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">              i += getChildrenSkipCount(child, i);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           nonSkippedChildCount++;</span><br><span class="line">           <span class="comment">//如果有分割线，则要加上分割线的高度</span></span><br><span class="line">           <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">               mTotalLength += mDividerHeight;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//获取子View的LayoutParams并且强转为父布局的LayoutParams</span></span><br><span class="line">           <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"><span class="comment">//累加权重</span></span><br><span class="line">           totalWeight += lp.weight;</span><br><span class="line"><span class="comment">//是否使用多余的空间，如果设置了权重，并且height==0，表示希望使用剩下的空间，则跳过此次测量，稍后进行测量</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> useExcessSpace = lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//有权重的情况下且LinearLayout高度确定</span></span><br><span class="line">           <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">               mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">               skippedMeasure = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                   <span class="comment">//有权重且LinearLayout高度不确定的情况，则重置子View高度为wrap_content</span></span><br><span class="line">                   lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//正常测量过程</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> usedHeight = totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//进行子View的测量</span></span><br><span class="line">               measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                       heightMeasureSpec, usedHeight);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">               <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                   <span class="comment">//重置子View高度</span></span><br><span class="line">                   lp.height = <span class="number">0</span>;</span><br><span class="line">                   consumedExcessSpace += childHeight;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">               <span class="comment">//计算较大的totalLength</span></span><br><span class="line">               mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                      lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"><span class="comment">//设置最高子View大小</span></span><br><span class="line">               <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">                   largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//mBaselineChildTop 表示指定的 baseline 的子视图的顶部高度</span></span><br><span class="line">           <span class="keyword">if</span> ((baselineChildIndex &gt;= <span class="number">0</span>) &amp;&amp; (baselineChildIndex == i + <span class="number">1</span>)) &#123;</span><br><span class="line">              mBaselineChildTop = mTotalLength;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//为baseline的子View不允许有weight属性</span></span><br><span class="line">           <span class="keyword">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"A child of LinearLayout with index "</span></span><br><span class="line">                       + <span class="string">"less than mBaselineAlignedChildIndex has weight &gt; 0, which "</span></span><br><span class="line">                       + <span class="string">"won't work.  Either remove the weight, or don't set "</span></span><br><span class="line">                       + <span class="string">"mBaselineAlignedChildIndex."</span>);</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//当LinearLayout非EXACTLY模式 并且自View为MATCH_PARENT时</span></span><br><span class="line">     <span class="comment">//设置matchWidth和matchWidthLocally为true</span></span><br><span class="line">     <span class="comment">//该子View占据LinearLayout水平方向上所有空间</span></span><br><span class="line">           <span class="keyword">boolean</span> matchWidthLocally = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               matchWidth = <span class="keyword">true</span>;</span><br><span class="line">               matchWidthLocally = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//进行变量的赋值</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> margin = lp.leftMargin + lp.rightMargin;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">           maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">           childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">           allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">           <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                       matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                       matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">           &#125;</span><br><span class="line">           i += getChildrenSkipCount(child, i);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>遍历所有子View，根据index获取一个子View，在这里我们看到为null的时候mTotalLength加的是0，当子View是View.GONE时，也是加0，所以从这里可以看出，当子View为View.GONE是不计算在内的；这里简单提一下，内部获取子View的LayoutParams是要强转为父View的LayoutParams的，所以通常在代码来控制子View的位置是要获取父View的LayoutParams</p><p>接着判断当LinearLayout为EXACTLY时且子View设置了权重，表示这个子View要使用剩下的空间，那么就会先跳过这次正常的测量，会在后面有权重的时候进行单独的测量</p><p>接着正常子View的测量，mTotalLength累加子View的高度，测量完成重置子View的高度等；然后接着测量View宽度</p><p>接着看后面的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">       <span class="comment">//有divider时加上divider的高度</span></span><br><span class="line"><span class="keyword">if</span> (nonSkippedChildCount &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">           mTotalLength += mDividerHeight;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果高度测量模式为AT_MOST或者UNSPECIFIED 则进行二次测量 useLargestChild</span></span><br><span class="line"><span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">               (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">           mTotalLength = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">               <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">               <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mTotalLength += measureNullChild(i);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                   i += getChildrenSkipCount(child, i);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                       child.getLayoutParams();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">               mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                       lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//加上paddingTo、paddingBottom</span></span><br><span class="line">       mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">       <span class="keyword">int</span> heightSize = mTotalLength;</span><br><span class="line">       <span class="comment">// Check against our minimum height</span></span><br><span class="line">       heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line">       <span class="comment">// Reconcile our calculated size with the heightMeasureSpec</span></span><br><span class="line">       <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">       heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次就是判断是否需要第二次测量，如果高度测量模式为AT_MOST或者UNSPECIFIED 则进行二次测量 且设置了useLargestChild，而useLargestChild是mUseLargestChild，而mUseLargestChild是在LinearLayout初始化时，在布局中设置，<code>mUseLargestChild = a.getBoolean(R.styleable.LinearLayout_measureWithLargestChild, false);</code>也就是说只有设置了measureWithLargestChild为true（默认false）时才可能进行二次测量</p><p>然后后面就是mTotalLength加上padding，重新计算heightSize</p><p>接着看后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">       <span class="comment">//额外空间的计算</span></span><br><span class="line"><span class="keyword">int</span> remainingExcess = heightSize - mTotalLength</span><br><span class="line">               + (mAllowInconsistentMeasurement ? <span class="number">0</span> : consumedExcessSpace);</span><br><span class="line">       <span class="keyword">if</span> (skippedMeasure || remainingExcess != <span class="number">0</span> &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">           <span class="comment">//如果有总的权重和，就使用设置的，否则使用子View计算来的</span></span><br><span class="line">           <span class="keyword">float</span> remainingWeightSum = mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line">           mTotalLength = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//有权重，需要进行二次测量有权重的子View</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">               <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">               <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">float</span> childWeight = lp.weight;</span><br><span class="line">               <span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> share = (<span class="keyword">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">                   remainingExcess -= share;</span><br><span class="line">                   remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childHeight;</span><br><span class="line">                   <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                       childHeight = largestChildHeight;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                           || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                       childHeight = share;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">//定义权重子控件重新测量，这时候childWidth是子控件本身的高度加上通过权重计算的额外高度</span></span><br><span class="line">                   childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                           Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                           mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                           lp.width);</span><br><span class="line">                   child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                   childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                           &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> margin =  lp.leftMargin + lp.rightMargin;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> measuredWidth = child.getMeasuredWidth() + margin;</span><br><span class="line">               maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                       lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">               alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                       matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">               allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">               mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                       lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Add in our padding</span></span><br><span class="line">           mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">           <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                          weightedMaxWidth);</span><br><span class="line">          <span class="comment">//当设置了权重最小尺寸</span></span><br><span class="line">           <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                   <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">                   <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                           (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">float</span> childExtra = lp.weight;</span><br><span class="line">                   <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       child.measure(</span><br><span class="line">                               MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                       MeasureSpec.EXACTLY),</span><br><span class="line">                               MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                       MeasureSpec.EXACTLY));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">           maxWidth = alternativeMaxWidth;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line">       <span class="comment">// Check against our minimum width</span></span><br><span class="line">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">               heightSizeAndState);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">           forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个垂直方向的Measure流程大致就这样了，水平方向是类似的</p><h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><p>layout过程其实逻辑基本和Measure是类似的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">           layoutVertical(l, t, r, b);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           layoutHorizontal(l, t, r, b);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>同样，不同的方向进行不同的layout，这里还是以Vertical方向为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> childTop;</span><br><span class="line">       <span class="keyword">int</span> childLeft;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 子View默认右侧位置</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;</span><br><span class="line">       <span class="keyword">int</span> childRight = width - mPaddingRight;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 子View可用空间大小</span></span><br><span class="line">       <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line"><span class="comment">//根据LinearLayout设置的对其方式 设置第一个子View的Top值</span></span><br><span class="line">       <span class="keyword">switch</span> (majorGravity) &#123;</span><br><span class="line">          <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">              <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">              childTop = mPaddingTop + bottom - top - mTotalLength;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">          <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">              childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              childTop = mPaddingTop;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//遍历子View</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">           <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">               childTop += measureNullChild(i);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">               <span class="comment">//LinearLayout中子View的宽和高有measure过程决定</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                       (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">               <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   gravity = minorGravity;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">               <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                       childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</span><br><span class="line">                               + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                       childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                   childTop += mDividerHeight;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               childTop += lp.topMargin;</span><br><span class="line">               <span class="comment">//用setChildFrame()方法设置子控件控件的在父控件上的坐标轴</span></span><br><span class="line">               setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class="line">                       childWidth, childHeight);</span><br><span class="line">               childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">               i += getChildrenSkipCount(child, i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>layout也十分简单，就这么多东西</p><h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>draw也是一样的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mDivider == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">           drawDividersVertical(canvas);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           drawDividersHorizontal(canvas);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>直接看drawDividersVertical吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawDividersVertical</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">           <span class="keyword">if</span> (child != <span class="keyword">null</span> &amp;&amp; child.getVisibility() != GONE) &#123;</span><br><span class="line">               <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                   <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> top = child.getTop() - lp.topMargin - mDividerHeight;</span><br><span class="line">                   drawHorizontalDivider(canvas, top);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getLastNonGoneChild();</span><br><span class="line">           <span class="keyword">int</span> bottom = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">               bottom = getHeight() - getPaddingBottom() - mDividerHeight;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               bottom = child.getBottom() + lp.bottomMargin;</span><br><span class="line">           &#125;</span><br><span class="line">           drawHorizontalDivider(canvas, bottom);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>绘制里面就主要是分割线的绘制，明显易懂，就不再多说了</p><h2 id="FrameLayout、LinearLayout和RelativeLayout的性能对比"><a href="#FrameLayout、LinearLayout和RelativeLayout的性能对比" class="headerlink" title="FrameLayout、LinearLayout和RelativeLayout的性能对比"></a>FrameLayout、LinearLayout和RelativeLayout的性能对比</h2><p>当RelativeLayout和LinearLayout作为ViewGroup表达相同的布局的时候，谁的绘制更快一些，性能相对更好一些？</p><p>通过网上的很多实验结果我们得之，两者绘制同样的界面时layout和draw的过程时间消耗相差无几，关键在于measure过程RelativeLayout比LinearLayout慢了一些。我们知道ViewGroup是没有onMeasure方法的，这个方法是交给子类自己实现的。因为不同的ViewGroup子类布局都不一样，那么onMeasure索性就全部交给他们自己实现好了</p><p>LinearLayout：在没有权重的情况下，就只会单纯的遍历一个方向，遍历一次所有的View；如果View设置了权重 ，那么在第一次遍历的时候这个View是不会进行测量的，在第二次测量（专门用于测量权weight重的）；所以无权重一次遍历，有权重两次遍历</p><p>RelativeLayout：因为依赖关系，所以在进行排序后，分别会对水平、垂直方向进行遍历，所以两次遍历</p><p>FrameLayout：某种情况上来说，FrameLayout也可能导致二次测量，不过FrameLayout的二次测量就只针对View为match_parent的了</p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p><a href="https://www.jianshu.com/p/3b52e6856b72" target="_blank" rel="noopener">Android View 相关源码分析之四 LinearLayout源码分析</a></p><p><a href="https://www.jianshu.com/p/43d49b7d2ad2" target="_blank" rel="noopener">你对LinearLayout到底有多少了解？（二）-源码篇</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第六章 应用层</title>
      <link href="/2018/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2018/06/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="计算机网络——第六章-应用层"><a href="#计算机网络——第六章-应用层" class="headerlink" title="计算机网络——第六章 应用层"></a>计算机网络——第六章 应用层</h1><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><p>UDP<br><img src="https://upload-images.jianshu.io/upload_images/4061843-d3a8f9684bba3bee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-d90dd883202b227f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-feefc6a887445c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/4061843-4332d9ab207727f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>四种域名服务器：</strong></p><ul><li><p>根域名服务器<br>1、所有的根域名服务器都知道所有的顶级域名服务器的域名和IP<br>2、只要本地域名服务器无法自己解析，就求助根域名服务器，根域名服务器使用迭代查询后，把要找的顶级域名服务器的IP告诉本地服务器自己查询<br>3、13个不同IP的根域名服务器，a~m</p></li><li><p>顶级域名服务器<br>1、负责管理在该顶级域名服务器注册的所有二级域名<br>2、当收到DNS查询请求时，就给出回答：可能是最后的结果，也可能是下一步要找的域名服务器的IP</p></li><li><p>权限域名服务器<br>1、负责一个区的域名服务器<br>2、当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</p></li><li><p>本地域名服务器<br>1、当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器,也称为默认域名服务器<br>2、每一个因特网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器。</p></li></ul><p><strong>域名解析基本原理：</strong><br>1、将域名转换为对应的IP地址的过程称为域名解析<br>2、完成该功能的软件叫域名解析器;<br>3、每个本地域名服务器配置一个域名解析器软件<br>4、由于每个服务器都知道根服务器的地址，因此无论经过几步查询，在域名树中最终总会找出正确的解析结果</p><p><strong>解析步骤：</strong><br>1、请求本地域名服务器（本地查询采用递归）<br>2、本地域名服务器请求根域名服务器<br>3、根域名服务器返回要查找的顶级域名服务器和其IP（根域名服务器采用迭代）<br>4、本地域名服务器根据返回的顶级域名服务器IP，请求对应的顶级域名服务器<br>5、顶级域名服务器若不直接返回IP，便返回下一个查找的域名服务器和其IP<br>6、本地域名服务器根据返回的IP查找下一个域名服务器，重复，最后返回IP</p><hr><h3 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h3><p>TCP<br>（1）主进程打开熟知端口（21），使客户进程能连接<br>（2）等待客户进程发出连接请求<br>（3）启动从属进程处理请求<br>（4）回到等待状态<br><img src="https://upload-images.jianshu.io/upload_images/4061843-98fdce7e2af3c058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>TFTP：</strong>简单文件传送协议<br>UDP<br><strong>特点：</strong><br>（1）每次传送的数据报文中有512字节的数据，最后一次可以不足512<br>（2）数据报文按序编号，从1开始<br>（3）支持ASCII码或二进制传送<br>（4）可对文件进行读或写<br>（5）使用简单的首部</p><hr><h3 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h3><p>类似于远程终端控制，又称终端仿真协议<br>TCP连接</p><hr><h3 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h3><p>分布式超媒体(hypermedia)系统，它是超文本(hypertext)系统的扩充</p><ul><li><p><strong>工作方式：</strong><br>1、万维网以客户服务器方式工作。<br>2、浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。<br>3、客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。<br>4、在一个客户程序主窗口上显示出的万维网文档称为页面(page)<br><img src="https://upload-images.jianshu.io/upload_images/4061843-6dc6c6c768aa57b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p><strong>必须解决的问题：</strong><br>1、怎样标志分布在整个因特网上的万维网文档？<br>（1）使用统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档。<br>（2）使每一个文档在整个因特网的范围内具有唯一的标识符 URL。<br>（3）也被称为网页地址(web地址),万维网联盟编制为因特网标准RFC1738。</p></li></ul><p>2、用何协议实现万维网上各种超链的链接？<br>（1）在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。<br>（2）HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送</p><p>3、怎样使各种万维网文档都能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？<br>（1）超文本标记语言 HTML (HyperText Markup Language)使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到因特网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。<br>4、怎样使用户能够很方便地找到所需的信息？<br>（1）为了在万维网上方便地查找信息，用户可使用各种的搜索工具（即搜索引擎）</p><ul><li><strong>URL</strong><br>统一资源定位符</li></ul><p><em>组成：</em><br>1、第一部分是协议（或称为服务方式）</p><blockquote><p>（1）file 资源是本地计算机上的文件。格式file://<br>（2）ftp 通过 FTP访问资源。格式 FTP:// gopher 通过 Gopher 协议访问该资源。<br>（3）http 通过 HTTP 访问该资源。 格式 HTTP://<br>https 通过安全的 HTTPS 访问该资源。 格式 HTTPS://<br>（4）mailto 资源为电子邮件地址，通过 SMTP 访问。 格式 mailto:<br>MMS 通过 支持MMS（流媒体）协议的播放该资源。（代表软件：Windows Media Player）格式 MMS://<br>ed2k 通过 支持ed2k（专用下载链接）协议的P2P软件访问该资源。（代表软件：电驴） 格式 ed2k://<br>（5）Flashget通过 支持Flashget:（专用下载链接）协议的P2P软件访问该资源。（代表软件：快车） 格式 Flashget://<br>（6）thunder 通过 支持thunder（专用下载链接）协议的P2P软件访问该资源。（代表软件：迅雷） 格式 thunder://<br>（7）news 通过 NNTP 访问该资源。 tencent(通过支持tencent(专用聊天连接) 协议和用户对话。(代表软件：QQ、TM)格式 tencent://message/?uin=号码&amp;Site=&amp;Menu=yes<br>msnim 通过支持msnim(专用聊天连接) 协议和用户对话。(代表软件：MSN、WLM) 格式 （8）msnim:chat?contact=邮箱地址</p></blockquote><p>2、第二部分是存有该资源的主机域名或IP地址（有时也包括端口号，没有端口号时其端口号为第一部分的协议所分的端口号，即默认端口号）<br>3、第三部分是主机资源的具体地址。如目录和文件名等。<br>4、第一部分和第二部分之间用“：//”符号隔开，第二部分和第三部分用“/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。</p><ul><li><strong>HTTP：</strong><br>超文本传输协议，面向事务的应用层协议<br>TCP<br><img src="https://upload-images.jianshu.io/upload_images/4061843-d7902f55efac6d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><p><strong>持续连接的两种方式：</strong><br>1、非流水线方式：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 RTT 的开销节省了建立 TCP 连接所需的一个 RTT 时间。但服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源<br>2、流水线方式：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT时间，使 TCP 连接中的空闲时间减少，提高了下载文档效率<br><img src="https://upload-images.jianshu.io/upload_images/4061843-f08e0dcfe9ee1eb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><hr><h3 id="电子邮件协议SMTP"><a href="#电子邮件协议SMTP" class="headerlink" title="电子邮件协议SMTP"></a>电子邮件协议SMTP</h3><p>TCP</p><p>邮件发送协议SMTP，读取协议邮局协议POP3或网际报文存取协议IMAP</p><hr><h3 id="各种地址标识"><a href="#各种地址标识" class="headerlink" title="各种地址标识"></a>各种地址标识</h3><p>（1）web地址：标识因特网上不同的网页；<br>（2）域名：用名字标识因特网上不同的服务器或主机等，方便记忆；<br>（3）端口号：区分不同的应用进程。<br>（4）IP地址：用数字串标识因特网上不同的主机或路由器端口等，路由器寻址必须使用。<br>（5）插口地址：IP地址加端口号，通过（源IP地址+源端口号,目的IP地址+目的端口号）可以在整个因特网上唯一的区分每一对应用进程之间的通信关系<br>（6）MAC地址：物理地址，交换机或网桥会根据目的MAC地址转发数据，接收方根据目的MAC地址判断是否接收，是自己的才会收下来处理并上交给网络层</p><ul><li><strong>关系：</strong><br>（1）根据Web地址，可以得到服务器的域名或IP地址和目的端口号<br>（2）由域名，通过DNS系统查询，可以得到服务器的IP地址（目的IP地址）<br>（3）由目的IP地址，可以判断是否与源主机是同一网络：<br>a）如果是，由ARP缓存和ARP协议可以得出目的主机的MAC地址（即目的MAC地址），可直接交付；<br>b）如果不是，则由ARP缓存和ARP协议可以得到默认网关的MAC地址，再由默认网关间接交付。<br>（4）由（ IP地址+端口号）可以得到插口地址，进而可以唯一确定在整个因特网上每一对应用进程之间的通信关系（源IP地址+源端口号,目的IP地址+目的端口号）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习(八)——线程操作</title>
      <link href="/2018/06/25/Linux%E5%AD%A6%E4%B9%A0(%E5%85%AB)%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/25/Linux%E5%AD%A6%E4%B9%A0(%E5%85%AB)%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Linux学习-八-——线程操作"><a href="#Linux学习-八-——线程操作" class="headerlink" title="Linux学习(八)——线程操作"></a>Linux学习(八)——线程操作</h1><h3 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h3><p>（1）线程是进程内独立的一条运行路线，处理器调度的最小单元，也称为迷你进程（轻量级进程）<br>（2）一个进程可以有多个线程，一个进程至少需要一个线程作为它的指令执行体<br>（3）多核心甚至多CPU的调度</p><p><strong>程序：</strong>存放在磁盘文件中的可执行文件，使用6个exec函数中的一个由内核将程序读入存储器，并使其执行</p><p><strong>进程：</strong>是资源管理的最小单位，是程序的执行实例，是动态过程</p><p><strong>线程：</strong>是程序执行的最小单元，比进程更小的、能独立运行和调度的基本单元，以此来提高程序并行执行的程度，是CPU上被调度执行的实体</p><p>进程的所有信息对该进程中的所有线程共享<img src="https://upload-images.jianshu.io/upload_images/4061843-2feea0ba434c8aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180625083227.png">进程来自不同用户，彼此存在竞争关系，一个进程中的线程通常是彼此合作</p><p><strong>线程的状态：</strong>运行、阻塞、就绪、终止，同进程状态一样</p><hr><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><strong>线程实现：</strong><br>（1）用户态线程：把整个线程包放在用户空间中，内核对线程包一无所知，线程表在用户（会导致阻塞）<br>（2）内核态线程：线程由内核管理，在每一个时间片内，内核负责调度进程内的线程，线程表在内核（并发）</li></ul><p><em>线程标识：</em>线程ID，只有在它所属的进程中唯一<br><code>typdef unsigned long int pthread_t</code></p><ul><li><strong>操作函数：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* thread：创建的线程标识符</span><br><span class="line">* attr：新线程的属性，默认NULL</span><br><span class="line">* *(*start_routine) 线程执行函数</span><br><span class="line">* arg：线程执行函数的输入参数，只有一个返回值</span><br><span class="line">*/</span><br><span class="line">int pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine) void *), void *arg);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 获取线程ID</span><br><span class="line">*/</span><br><span class="line">pthread_t pthread_self();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 结束线程</span><br><span class="line">*/</span><br><span class="line">void pthread_exit(void *retval);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 线程挂起</span><br><span class="line">* th：线程标识符</span><br><span class="line">* thread_return：存放其他线程的返回值</span><br><span class="line">*/</span><br><span class="line">int pthread_join(pthread_t th, void **thread_return);</span><br><span class="line"></span><br><span class="line">//取消</span><br><span class="line">/**</span><br><span class="line">* 请求终止线程</span><br><span class="line">* 只提出请求，线程继续运行，直到达到某个取消点</span><br><span class="line">*/</span><br><span class="line">int pthread_cancel(pthread_t thread);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 设置取消状态：state</span><br><span class="line">* （1）PTHREAD_CANCEL_ENABLE(默认),收到信号后设为CANCLED态</span><br><span class="line">* （2）PTHREAD_CANCEL_DISABLE，忽略CANCEL信号继续运行</span><br><span class="line">*/</span><br><span class="line">int pthread_setcancelstate(in state, int *oldstate);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 设置取消执行动机</span><br><span class="line">* 仅当PTHREAD_CANCEL_ENABLE时有效</span><br><span class="line">* 立即取消(PTHREAD_CANCEL_ASYNCHRONOUS)和</span><br><span class="line">延迟取消至取消点(PTHREAD_CANCEL_DEFERRED，默认)</span><br><span class="line">*/</span><br><span class="line">int pthread_setcaceltype(int type, int *oldtype);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 设置取消点</span><br><span class="line">*/</span><br><span class="line">void pthread_testcacle();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 清理，入栈</span><br><span class="line">* routine：子程序</span><br><span class="line">* arg：子程序参数</span><br><span class="line">*/</span><br><span class="line">void pthread_cleanup_push(void (*routine)(void *), void *arg);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 出栈</span><br><span class="line">* execute：或非0，0表示正常退出时不执行该弹出的程序，异常退出时(响应cancel等， 执行到pthread_cleanup_pop代码之前的退出)执行弹出程序</span><br><span class="line">*/</span><br><span class="line">void pthread_cleanup_pop(int execute);</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-30b758415b460a70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180630194401.png"><img src="https://upload-images.jianshu.io/upload_images/4061843-6ed5e09b4c2b34ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180630194456.png"></p><ul><li><strong>线程同步：</strong></li></ul><ol><li>互斥锁：<br>锁定对共享资源的访问</li></ol><p><em>特点：</em><br>（1）原子性：如果一个线程锁定量一个互斥锁，没有其他线程在同一时间可以成功锁定该互斥锁<br>（2）唯一性：如果一个线程锁定了一个互斥锁，在它解锁之前，没有其他线程可以锁定这个互斥锁<br>（3）非繁忙等待：如果一个线程锁定了一个互斥锁，第二个线程试图锁定这个互斥锁时，则第二个线程会被挂起，直到第一个线程解除这个互斥锁的锁定，第二个线程会被唤醒执行，同时锁定这个互斥锁</p><p><em>互斥锁函数：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">//静态方式创建</span><br><span class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INTIALIZER;</span><br><span class="line">pthread_mutex_t mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;</span><br><span class="line">pthread_mutex_t mutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 动态方式</span><br><span class="line">* mutex：创建的互斥锁</span><br><span class="line">* attr：互斥锁的属性，默认NULL</span><br><span class="line">*/</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutex_attr *attr);</span><br><span class="line"></span><br><span class="line">//互斥锁的锁定</span><br><span class="line">int ptfhread_mutex_lock(pthread_mutex_t *mutex);</span><br><span class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex);</span><br><span class="line"></span><br><span class="line">//解锁，必须处于加锁状态，且调用的线程必须是上锁的同一线程，多个线程同时解锁时由有核心调度程序决定</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br><span class="line"></span><br><span class="line">//清除互斥锁</span><br><span class="line">int pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4061843-5a855112174d5f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180630205443.png"></p><ol start="2"><li>条件变量</li></ol><p><em>特点：</em><br>（1）对互斥锁的补充，允许线程阻塞并等待另一个线程发送的信号<br>（2）与互斥锁一起使用时，允许线程以无竞争的方式等待特定的条件发生<br>（3）条件本身是由互斥锁保护的，线程改变条件状态之前必须首先锁住互斥锁。其他线程在获得互斥锁之前不会察觉这种改变，必须锁定后才能计算条件</p><p><em>函数：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 初始化条件变量</span><br><span class="line">* cond：条件变量的标识</span><br><span class="line">* attr：条件变量的属性，默认NULL</span><br><span class="line">*/</span><br><span class="line">int pthread_cond_init(pthread_cond_t *cond, const pthread_cond_attr *attr);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 条件变量的清除</span><br><span class="line">* 清除任何条件变量的状态，但内存空间不释放</span><br><span class="line">*/</span><br><span class="line">int pthread_cond_destory(pthread_cond_t *cond);</span><br><span class="line"></span><br><span class="line">//对互斥锁与线程的操作</span><br><span class="line">/**</span><br><span class="line">* 释放由参数mutex指向的互斥锁，并且使调用线程关于参数cond指向的条件变量阻塞。</span><br><span class="line">* 被阻塞的线程可以被pthread_cond_signal/pthread_cond_broadcast唤醒</span><br><span class="line">*/</span><br><span class="line">int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* cond：标识</span><br><span class="line">* mutex：互斥锁标识</span><br><span class="line">* abstime：延迟时间</span><br><span class="line">* pthread_cond_timedwait()函数在定时时刻*abstime之前未被条件变量唤醒，则可自动唤醒，获取互斥锁。如果超过*abstime指定的时间，则返回ETIMEOUT</span><br><span class="line">*/</span><br><span class="line">int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime); </span><br><span class="line"></span><br><span class="line">//唤醒</span><br><span class="line">int pthread_cond_signal(pthread_cond_t *cond);  //至少唤醒一个</span><br><span class="line">int pthread_cond_broadcast(pthread_cond_t *cond);  //可以唤醒所有的等待该条件的线程</span><br><span class="line"></span><br><span class="line">//获取系统时间函数，tv秒数(1970-01-01 零时开始至当前的时间)，tz返回时区参数</span><br><span class="line">gettimeofday(struct timeval *tv, struct timezone *tz);</span><br><span class="line"></span><br><span class="line">//秒数转化为可理解的时间</span><br><span class="line">struct tm *localtime(time_t *timep);</span><br><span class="line">struct tm&#123;</span><br><span class="line">    int tm_sec;  //目前秒数, 正常范围0-59, 但允许至61 </span><br><span class="line">    int tm_min;  //分数, 范围0-59</span><br><span class="line">    int tm_hour;  //时数, 范围为0-23</span><br><span class="line">    int tm_mday;  //目前月份的日数, 范围01-31</span><br><span class="line">    int tm_mon;  //代表目前月份, 范围从0-11</span><br><span class="line">    int tm_year;  //从1900 年算起至今的年数</span><br><span class="line">    int tm_wday;  //一星期的日数, 从星期一算起, 范围0-6</span><br><span class="line">    int tm_yday;  //从今年1 月1 日算起的天数, 范围0-365</span><br><span class="line">    int tm_isdst;  //日光节约时间的旗标</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>信号量<br>与进程通信使用的一样，特殊的变量，原子操作。通过一个计数器控制对共享资源的访问，信号量的值是一个非负整数，所有通过它的线程都会将值-1。如果计数器大于0，则允许访问，计数器-1，如果计数器为0，则禁止访问，所有通过它的线程处于等待状态</li></ol><p><em>分类：</em><br>（1）二进制信号量：只允许信号量取0或1，同时只能被一个线程获取<br>（2）整型信号量：取值是整数，可以被多个线程同时获取，直到信号量的值为0</p><p><em>操作函数：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 创建</span><br><span class="line">* sem：信号量标识，长整型</span><br><span class="line">* pshared：控制信号量的类型，如果该值设为0，就表示这个信号量是当前进程的局部信号量，只能为当前进程的所有线程共享。不为0表示信号量可以在多个进程之间共享。</span><br><span class="line">* value：初始值</span><br><span class="line">*/</span><br><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 清除</span><br><span class="line">*/</span><br><span class="line">int sem_destory(sem_t *sem);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 控制</span><br><span class="line">* em的值大于0，则sem_wait()函数是以原子操作的方式将信号量sem的值减1。如果sem的值为0，则线程阻塞，直到获取到sem值大于1时才开始执行(P操作)</span><br><span class="line">* sem_post()将信号量sem的值加1，如果此时有正在等待的线程，则唤醒该线程。（V操作）</span><br><span class="line">*/</span><br><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line">int sem_post(sem_t *sem);</span><br></pre></td></tr></table></figure><hr><h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><p><em>特定数据的创建和取消：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 创建一个对进程中所有线程都可见的关键字</span><br><span class="line">* 函数可以与析构函数dest_routine关联。当线程退出时，那么析构函数会被调用。</span><br><span class="line">* 线程通常使用malloc为线程特定数据分配内存，析构函数通常需要释放已分配的内存。第二个参数析构函数可用NULL，即采用系统默认的销毁函数</span><br><span class="line">*/</span><br><span class="line">int pthread_key_create(pthread_key_t *key, void(*dest_routine(void *)));</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 清除指定关键字</span><br><span class="line">*/</span><br><span class="line">int pthread_key_delete(pthread_key_t key);</span><br></pre></td></tr></table></figure><p><em>特定数据的读取和设置：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 指定由参数pointer指定的指针指向由参数key指定的关键字</span><br><span class="line">*/</span><br><span class="line">int pthread_setspecific(pthread_key_t key, const void *pointer);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 获取由pthread_setspecific()设置的关键字指针</span><br><span class="line">*/</span><br><span class="line">void * pthread_getspecific(pthread_key_t key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *pthread_one_t one_control= PTHERAD_ONCE_INIT;</span><br><span class="line">/**</span><br><span class="line">* 保证某些初始化代码至多只能执行一次</span><br><span class="line">* once_control指向静态的或外部的变量</span><br><span class="line">*/</span><br><span class="line">int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));</span><br></pre></td></tr></table></figure><p><em>线程属性：</em><br>（1）每个POSIX线程有一个相连的属性对象表示其特性<br>（2）线程属性对象可以与多个线程相连，可根据属性对线程分组。属性对象特性改变时，组中所有线程实体具有新特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//创建和销毁</span><br><span class="line">int pthread_attr_init(pthread_attr_t *attr);</span><br><span class="line">int pthread_attr_destory(pthread_attr_t *attr);</span><br><span class="line"></span><br><span class="line">//拆卸状态</span><br><span class="line">int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</span><br><span class="line">int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</span><br><span class="line"></span><br><span class="line">//作用域函数</span><br><span class="line">int pthread_attr_setscope(pthread_attr_t *attr, int scope);</span><br><span class="line">int pthread_attr_getscope(phtread_attr_t *attr, int *scope);</span><br><span class="line"></span><br><span class="line">//堆栈相关函数</span><br><span class="line">int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddt, size_t *stacksize);</span><br><span class="line">int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t *stacksize);</span><br><span class="line">int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);</span><br><span class="line">int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);</span><br><span class="line">int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stack_addr);</span><br><span class="line">int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr);</span><br><span class="line"></span><br><span class="line">//调度相关函数</span><br><span class="line">/*继承调读*/</span><br><span class="line">int pthread_attr_setinheristched(pthread_attr_t *attr, int inherit);</span><br><span class="line">int pthread_attr_getinheritsc(const pthread_attr_t *attr, int *inherit);</span><br><span class="line">/*调度策略*/</span><br><span class="line">int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);</span><br><span class="line">int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);</span><br><span class="line">/*调度参数*/</span><br><span class="line">int phtread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);</span><br><span class="line">int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第五章 运输层</title>
      <link href="/2018/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2018/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="计算机网络——第五章-运输层"><a href="#计算机网络——第五章-运输层" class="headerlink" title="计算机网络——第五章 运输层"></a>计算机网络——第五章 运输层</h1><h4 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h4><ul><li>TPDU：运输协议数据单元，对等传输实体在通信的时传送的数据单元</li><li>端口：16位，只具有本地意义</li></ul><ol><li>服务端使用的端口号<blockquote><p>（1）熟知端口号或系统端口号，数值为0～1023<br>FTP：21<br>TELNET：23<br>SMTP：25<br>DNS：53<br>TFTP：69<br>HTTP：80<br>SNMP：161<br>SNMP（trap）：162<br>HTTPS：443<br>（2）登记端口号：数值为1024～49151</p></blockquote></li><li>客户端使用的端口号：数值为49152～65535，仅在客户进程运行时才动态选择，又叫短暂端口号</li></ol><ul><li>一个进程的全网唯一标识：协议+本地地址+本地端口号</li><li>一个完整的进程通信标识：协议+本地地址+本地端口+远程地址+远地端口号</li></ul><hr><h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><p><em>传输单元：</em>UDP用户数据报</p><ul><li><p><strong>特点：</strong><br>（1）UDP是无连接的，不需要建立连接<br>（2）UDP使用尽最大努力交付，即不可保证可靠交付，不需要维持连接状态表<br>（3）UDP是面向报文的，发送时直接添加首部后向下交付IP层，对报文既不合并也不拆分，而是保留这些报文的边界（不处理报文，应用层交给UDP多长报文，就多长照常交给IP，一次一个报文），接收时也什么不用处理，去掉UDP首部后直接交付给应用层<br>（4）UDP没有拥塞控制，网络拥塞时不会使源主机发送效率降低，没有重传，实时性要求高，准确性要求不高<br>（5）UDP支持一对一、一对多、多对一和多对多的交互通信<br>（6）UDP的首部开销小，只有8个字节</p></li><li><p><strong>首部格式：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-d1e803b1730da460.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li></ul><p>（1）源端口：2字节<br>（2）目的端口：2字节<br>（3）长度：2字节，UDP用户数据报的长度，最小为8<br>（4）检验和：2字节，检测UDP用户数据报在传输中是否有错</p><p><em>计算检验和：</em>计算时，在UDP用户数据报之前增加12字节的伪首部（检验和时才会添加），得到一个临时的UDP用户数据报，IP数据报检验只检验IP首部，UDP的检验和是把首部和数据部分一起都检验<br><img src="https://upload-images.jianshu.io/upload_images/4061843-8df9e51565bb1f29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><hr><hr><h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><p><em>传输单元：</em>TCP报文段</p><ul><li><p><strong>首部格式：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-bc9ecd82e375f89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>20字节固定，后面4n可变长度，最小长度20字节<br>（1）源端口和目的端口：各占2字节<br>（2）序号：4字节，0~2^32-1，使用mod2^32运算<br>（3）确认号：4字节，期望收到下一个报文段的第一个数据字节的序号<br>（4）数据偏移：4位，指出数据起始处距离报文段的起始处有多远<br>（5）保留：6位<br>（6）紧急URG（URGent）：为1时表示紧急指针有效，改变传输的优先级，带有紧急的优先传送<br>（7）确认ACK：=1时有效<br>（8）推送PSH：当通信时，有时在一端的应用程序希望在键入一个命令后立即受到对方的响应<br>（9）复位RST：=1，表示TCP连接中出现严重差错<br>（10）同步SYN：在连接建立时来同步序号，=1且ACK=0表示连接请求报文，=1且ACK=1表示同意建立连接<br>（11）终止FIN：释放连接，=1表示发送方的数据已发送完毕，并要求释放连接<br>（12）窗口：2字节，指的是发送本报文段的一方的接受窗口（不是自己的发送窗口），作为接收方让发送方设置其发送窗口的依据（允许发送方发送的数据量）<br>（13）检验和：2字节，检验的范围包括首部和数据<br>（14）紧急指针：2字节，URG=1有效<br>（15）选项：最大报文段长度MSS，是每一个TCP报文段中的数据字段的最大长度</p></li><li><p><strong>特点：</strong><br>（1）TCP是面向连接的运输层协议，必须建立TCP连接<br>（2）每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的<br>（3）TCP提供可靠交付的服务<br>（4）TCP提供全双工通信，TCP允许通信双方的应用进程在任何时候都能发送数据，两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据<br>（5）面向字节流，传送的时候是字节流</p></li></ul><hr><ul><li><strong>TCP的连接：</strong><br>连接的端点是套接字或插口：IP地址+端口号<br>三次握手：<img src="https://upload-images.jianshu.io/upload_images/4061843-dd7a5b3049e79b51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">此处当B确认并同步报文可以分成两个，就会变成4次握手<br>（1）A请求报文<br>（2）B确认，并同步，SYN=1<br>（3）A再一次确认，建立连接（防止A的第一次已失效的请求报文传送到了B）</li></ul><p>四次挥手：<img src="https://upload-images.jianshu.io/upload_images/4061843-34846c8f9e910601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">（1）先A请求关闭，关闭A的发送，A不在发送数据但是要接收<br>（2）B确认，但B会继续发送数据，A会继续接收<br>（3）B关闭发送，B不在发送数据<br>（4）A确认，B先关闭<br>（5）一段时间后，A自动关闭，断开连接</p><p><strong>有限状态机：</strong><img src="https://upload-images.jianshu.io/upload_images/4061843-a0b9c4269f3d4a47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><hr><ul><li><strong>停止等待协议：</strong>等待确认再发送下一个分组</li></ul><p><strong>无差错情况：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-97e52424b5d1e59a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双方都等待确认后才会发送下一个分组"></p><p><strong>出现差错：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-a45f357de556eb80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="如果出现差错，就丢弃分组且不会发出确认，A一定时间后没有收到确认就重传"></p><p><strong>确认丢失和确认迟到：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-5415370f6d5adc19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>信道利用率：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-9eb652b0a947a516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><img src="https://upload-images.jianshu.io/upload_images/4061843-19478707ccdf0191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><strong>连续ARQ协议</strong><br>滑动窗口，发送一个窗口的分组，这个窗口中的分组不用等待确认，连续发送，然后确认后在移动窗口</li></ul><hr><ul><li><strong>可靠传输的实现：</strong></li></ul><p><em>字节为单位的滑动窗口，发送窗口在连接建立时由双方商定</em><br><img src="https://upload-images.jianshu.io/upload_images/4061843-62d9e1d3c62cbe4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">发送窗口表示：在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去，凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。发送窗口里面的序号表示允许发送的序号，A的发送窗口一定不能超过B的接收窗口的数值。发送窗口后沿的变化有不动（没有收到新的确认）和前移（收到了新的确认）两种，发送窗口的前沿也可能向后收缩。<img src="https://upload-images.jianshu.io/upload_images/4061843-0d1c4b58e46e8998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">发送窗口需要三个指针P1、P2、P3来判定状态。<img src="https://upload-images.jianshu.io/upload_images/4061843-35fa04c029079037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-5cb4b8ac34f2df81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="窗口和缓存">发送缓存：<br>（1）存放发送应用程序传送给发送方TCP准备发送的数据<br>（2）存放TCP已发送出但尚未收到确认的数据<br>接收缓存：<br>（1）存放按序到达的、但尚未被接收应用程序读取的数据<br>（2）未按序到达的数据<br>如果接收应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到0，反之，接收窗口就增大，但最大不能超过接收缓存的大小</p><hr><ul><li><strong>超时重传时间的选择：</strong><br>RTT：报文段的往返时间<br>RTTs：平滑的往返时间，RTT的加权平均返回时间<br>公式：RTTs = （1-@）* 旧RTT+@ * 新RTT<br><em>其中@一般为0.125</em><br>RTO：超时重传时间<br>RTTd：RTT的偏差的加权平均值<br>公式：新的RTTd=（1-b）* 旧的RTTd+b  * |RTTs - 新RTT|         </li></ul><p><em>b一般为0.25</em><br>公式：RTO = RTTs + 4*RTTd</p><hr><ul><li><strong>TCP的流量控制：</strong><br>让发送方的发送速率不要太快，要让接收发来的及接收<br><img src="https://upload-images.jianshu.io/upload_images/4061843-12f34d10e184e919.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><hr><ul><li><strong>TCP的拥塞控制：</strong><br>防止过多的数据注入到网络，使路由器或链路不至于过栽<br><img src="https://upload-images.jianshu.io/upload_images/4061843-b40752b75b15832c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>（1）慢开始和拥塞避免<br>慢开始：当主机开始发送数据时，先探测一下，由小到大逐渐增大发送窗口，每收到一个确认后拥塞窗口就增加最多一个SMSS的数值<img src="https://upload-images.jianshu.io/upload_images/4061843-64a80ce287c40e3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>拥塞避免：让拥塞窗口cwnd缓慢的增大，每经过一个RTT就把发送方的拥塞窗口+1<img src="https://upload-images.jianshu.io/upload_images/4061843-f31e1aef8330e400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></li></ul><p>（2）快重传和快回复<br>快重传：让发送方尽早知道发生了个别报文段的丢失，当发送方一连收到3个重复确认，就立即重传<br><img src="https://upload-images.jianshu.io/upload_images/4061843-c0ad9c26830ce5b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>主动管理队列AQM：</strong>当在队列长度达到某个值得警惕的数值时，就主动丢弃到达的分组，以此提醒发送方放慢发送速率</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习(七)——进程间通信</title>
      <link href="/2018/06/11/Linux%E5%AD%A6%E4%B9%A0(%E4%B8%83)%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/06/11/Linux%E5%AD%A6%E4%B9%A0(%E4%B8%83)%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Linux学习-七-——进程间通信"><a href="#Linux学习-七-——进程间通信" class="headerlink" title="Linux学习(七)——进程间通信"></a>Linux学习(七)——进程间通信</h1><h3 id="进程间通信的目的"><a href="#进程间通信的目的" class="headerlink" title="进程间通信的目的"></a>进程间通信的目的</h3><p>1、数据传输：一个进程需要将它的数据发送给另一个进程<br>2、共享数据：多个进程想要操作共享数据，一个进程对共享数据进行修改，别的进程应该立即看到<br>3、通知事件：一个进程需要向另一个或一组进程发送消息，通知=它们发生了某种事件（如进程终止时要通知父进程）<br>4、资源共享：多个进程间共享同样的资源，需要内核提供锁和同步机制<br>5、进程控制：有些进程希望完全控制另一个进程的执行（如debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，能够及时知道它的状态改变</p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-89b00a5c9c5aa834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180613141119.png"></p><hr><h3 id="进程间的通信机制"><a href="#进程间的通信机制" class="headerlink" title="进程间的通信机制"></a>进程间的通信机制</h3><h5 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）"></a>信号（signal）</h5><p>信号是对在软件层次上对中断机制的一种模拟，是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号的与处理器收到一个中断请求效果上可以说是一样的</p><ol><li>用来向进程通知异步事件的发生，最初用来处理错误，最基本的IPC机制</li><li>linux中大部分信号都有预先定义好的意义，但至少有两个信号SIGUSER1和SIGUSER2可以由应用程序定义</li><li>每个信号都有默认的动作，典型的是终止进程，进程可以通过提供信号处理函数来代替默认动作</li><li>信号的产生：<br>a）某些终端键产生，如ctrl+c中断信号<br>b）硬件产生异常信号，如除数为0、无效的存储访问<br>c）kill()函数将信号发送给另一个进程或进程组<blockquote><p>常见的信号：<br>1、SIGHUP：挂断终端信号，终端被切断时产生<br>2、SIGINT：来自键盘的中断信号ctrl+c<br>3、SIGQUIT：来自键盘的退出信号ctrl+<br>4、SIGFPE：浮点异常信号（浮点运算溢出）<br>5、SIGKILL：该信号结束接收信号的进程<br>6、SIGALRM：进程的定时器到期时发送<br>7、SIGTERM：kill命令发出的信号<br>8、SIGCHLD：标识子进程停止或结束的信号<br>9、SIGSTOP：ctrl+z或调试程序的停止执行信号<br>10、SIGUSER1：用户自定义信号1<br>11、SIGUSER2：用户自定义信号2</p></blockquote></li></ol><ul><li><strong>进程对信号的处理方式：</strong></li></ul><ol><li>忽略此信号<br>（1）大多数信号都可以这样处理<br>（2）SIGKILL和SIGSTOP不能被忽略</li><li>缺省处理方式：<br>执行系统默认动作，默认终止该进程</li><li>暂时搁置信号</li><li>捕捉信号<br>（1）通知内核在某种信号发生时，调用一个用户函数<br>（2）在用户函数中，可执行用户希望对这种事件进行的处理<br>（3）如果捕捉到SIGCHLD，表示子进程已经终止，所以此信号可以调用waitpid以取得该子进程的进程ID以及终止状态</li></ol><p><em>注册信号处理函数：</em><br>（1）signal()，只有两个参数，不支持信号传递信息，主要用于前32种非实时信号注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void (*signal(int signumber, void(*func))(int)))(int);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">signumber：所注册函数针对的信号</span><br><span class="line">func：调用函数的函数指针，信号处理函数，func有一个整数参数，返回值void，可以是自定义也可以是SIG_IGN（忽略对信号signumber的处理）或SIG_DFL（对信号默认处理）</span><br><span class="line">不能对SIGKILL和SIGSTOP设置信号处理函数</span><br><span class="line">signal失败返回1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>（2）sigaction()，三个参数，支持信号传递信息，同样支持signal的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1、第一个参数signum为信号的值，可以是出SIGKILL和SIGSTOP外的任何一个特定有效的信号</span><br><span class="line">2、act是指定流对特定信号的处理，可以为空（以缺省方式处理），指向的sigaction包含流对指定信号的处理、信号所传递的信息、处理过程屏蔽的信号</span><br><span class="line">3、oldact用来保存返回的原来对相应信号的处理，可以为NULL</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//sigaction结构</span><br><span class="line">struct sigaction &#123;</span><br><span class="line">     void(*sa_handler)(int);</span><br><span class="line">    void(*sa_sigaction)(int, struct siginfo_t*, void *);</span><br><span class="line">    sigset_t sa_mask;</span><br><span class="line">    int sa_flags;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* sa_handler：信号处理函数地址</span><br><span class="line">* sa_sigacation：指向信号处理函数的指针</span><br><span class="line">* sa_handler和sa_sigaction某些体系结构上被定义为共用体</span><br><span class="line">* sa_mask：指定哪些信号应当被阻塞</span><br><span class="line">* sa_flags：标志位</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><blockquote><p>sa_flags中的标志位。各位可通过“或”运算串接<br>1、0表示默认选项；<br>2、SA_NOCLDSTOP: 如果参数signum为SIGCHLD,当子进程被中断时，并不通知父进程。<br>3、SA_NOCLDWAIT:当信号为SIGCHLD,时可避免子进程僵死。<br>4、SA_NODEFER= SA_NOMASK :当信号处理函数正在进行时，不堵塞对于信号处理函数自身信号功能。<br>5、SA_ONESHOT= SA_RESETHAND:  用户注册的信号处理函数只执行一次，随后该信号的处理函数被设为系统默认的处理函数。<br>6、SA_RESTART:是本来不能重新运行的系统调用自动重新运行。<br>7、SA_SIGINFO:如果设置了该标志，则信号处理函数由三参数的sa_sigaction指定而不是sa_handler指定。</p></blockquote><p><em>信号集及操作函数：</em>被定义为一种数据类型，表示多个信号，描述信号的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">//操作相关</span><br><span class="line">int sigemptyset(sigset_t *set);  //清空set指定的信号集</span><br><span class="line">int sigfillset(sigset_t *set);  //set指向的信号集包含所有信号</span><br><span class="line">int sigaddset(sigset_t *set, int signum);  </span><br><span class="line">int sigdelset(sigset_t *set, int signum);</span><br><span class="line">int ismenmber(const sigset_t *set, int signum);</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">      unsigned long_sig[_NSIG_WORDS];</span><br><span class="line">&#125; sigset_t</span><br><span class="line"></span><br><span class="line">//阻塞相关</span><br><span class="line">/**</span><br><span class="line">* oset非空，oset返回进程当前的信号掩码</span><br><span class="line">* set非空，how指定当前的信号掩码如何改变</span><br><span class="line">* SIG_BLOCK：set所指向的信号集包含的要增加的被阻塞的信号</span><br><span class="line">* SIG_UNBLOCK：set所指向的信号包含了要增加的不被阻塞的信号</span><br><span class="line">* SIG_SETMASK：进程的新信号掩码为set所指的信号集</span><br><span class="line">*/</span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oset);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 获取当前已递送到进程却被阻塞的所有信号</span><br><span class="line">*/</span><br><span class="line">int sigpending(sigset_t *set);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 用于在接收到某个信号执勤，临时用mask替换进程的信号掩码，暂停进程执行，直到收到信号</span><br><span class="line">* 返回之前的信号掩码，系统调用始终返回-1</span><br><span class="line">* 返回条件：信号发生且信号不是屏蔽，信号必须处理，返回在处理函数后</span><br><span class="line">*/</span><br><span class="line">int sigsuspend(const sigset_t *mask);</span><br></pre></td></tr></table></figure><p><em>信号发送函数：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys.types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 向进程或进程组发送信号</span><br><span class="line">* pid&gt;0，pid的进程</span><br><span class="line">* pid=0，同一个进程组的进程</span><br><span class="line">* pid&lt;-1，进程组ID为pid绝对值的所有进程</span><br><span class="line">* pid=-1，将信号广播传送给系统内所有有权限发的进程</span><br><span class="line">*/</span><br><span class="line">int kill(pid_t pid, int signo);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 用于向进程自身发送信号，失败-1，成功0</span><br><span class="line">*/</span><br><span class="line">int raised(int signo);</span><br></pre></td></tr></table></figure><ul><li><strong>信号优缺点：</strong><blockquote><p>1、信号数量有限，传递的信息比较粗糙，只是一个整数<br>2、系统开销大，要管理堆栈<br>3、由于传递的信息量少，便于管理和使用<br>4、经常用于系统管理相关</p></blockquote></li></ul><hr><h5 id="管道（pipe）-有名管道（named-pipe，FIFO）"><a href="#管道（pipe）-有名管道（named-pipe，FIFO）" class="headerlink" title="管道（pipe）/有名管道（named pipe，FIFO）"></a>管道（pipe）/有名管道（named pipe，FIFO）</h5><p>管道可用于具有亲缘关系进程间的通信<br>有名管道除了具有管道的的功能还允许无亲缘关系进程间通信</p><p>将一个进程的标准输出和另一个进程的标准输入连到一起，以供两个进程互相通信</p><blockquote><p>1、管道是单向的、先入先出的、无结构的、固定大小的数据流，<br>2、从管道读出后，数据移走，其他进程无法再读取<br>3、进程试图读空管道时，在有数据写入管道前，进程将一直阻塞，同样管道已满时，写进程也阻塞<br>4、pipe函数生成管道，每个管道可以有多个读进程和写进程<br>5、两个进程都终结时，管道自动消失<br>6、将一个程序的输出作为另一个的输入，管道符 | </p></blockquote><p><em>局限性</em></p><blockquote><p>1、不能用来对多个接受者广播数据<br>2、无法识别信息的边界<br>3、一个管道有多个读进程，那么写进程不能发送数据到指定的读进程<br>4、一个管道有多个写进程，那么无法判断那个写进程发送了数据</p></blockquote><ul><li><p><strong>命名管道（FIFOs，named PIPE）</strong></p><blockquote><p>1、由于fork机制，管道只能用于父子进程之间，或者拥有相同祖先的两个子进程之间<br>2、FIFOs(First in, First out)为一种特殊的文件类型，有对应的路径<br>3、当一个进程读打开，另一个写打开，内核就建立管道<br>4、FIFOs是已经存在的对象，非命名管道是一个临时文件<br>5、多个写进程时，通pipe一样，可能发生写交错现象<br>6、删除FIFO文件，管道消失<br>7、可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* pathname：FIFO路径名+文件名</span><br><span class="line">* mode：权限描述符，与open中的相同</span><br><span class="line">*/</span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">int mknod(char *pathname, mode_t mode, dev_t dev);</span><br></pre></td></tr></table></figure></li><li><p><strong>匿名管道（单向管道）</strong></p><blockquote><p>1、半双工，数据在同一时刻只能在一个方向上流动<br>2、数据只能从管道的一端写入，从另一端写出<br>3、写入管道的数据遵循先入先出<br>4、传送的数据是无格式的，所以输入输出端必须先定义好数据的格式<br>5、管道不是普通的文件，不属于某个文件系统，只存在内存中<br>6、读数据是一次性操作，读取后，从管道抛弃<br>7、没有名字，只能在具有公共祖先的进程之间使用</p></blockquote></li></ul><p><em>pipe创建管道：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">/**</span><br><span class="line">* 1、创建的管道包含两个文件描述符fdes[0]和fdes[1]</span><br><span class="line">* 2、管道两端的任务固定，fdes[0]只能用于读，fdes[1]只能用于写</span><br><span class="line">* 3、使用这个文件描述符必须使用read和write（系统I/O）</span><br><span class="line">* 4、如果对管道两端进行相反的工作会导致错误发生</span><br><span class="line">* 5、管道不允许文件定位</span><br><span class="line">*/</span><br><span class="line">int pipe(int fdes[2]);</span><br></pre></td></tr></table></figure><p><em>管道读取数据：</em></p><blockquote><p>如果管道的写端不存在<br>1、则任务数据读到末尾，读出字节数返回为0<br>如果管道的写端存在<br>1、如果请求的字节数目大于PIPE_BUF（一般为4096），则返回管道中现有的数据字节数<br>2、如果请求的字节数不大于，则返回管道中现有的字节数（小于请求字节数）或者返回请求的字节数（大于请求字节数）</p></blockquote><p><em>管道写入数据：</em></p><blockquote><p>1、linux不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据<br>2、当向读描述符关闭的管道中写数据时，会产生SIGPIPE信号，write返回-1<br>3、缓冲区已满，写操作一直阻塞<br>4、编程时可通过fcntl函数设置文件的阻塞特性（阻塞：fcntl(fd, F_SETFL, 0);  非阻塞：fcntl(fd, F_SETFL, O_NONBLOCK);）</p></blockquote><p><em>创建管道的简单方法：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* popen内部调用fork和exec执行命令行，返回FILE结构指针</span><br><span class="line">* type参数只能定义成只读或只写，不同同时，第一个为准</span><br><span class="line">* r开头则标准输出，w开头则标准输入</span><br><span class="line">*/</span><br><span class="line">FILE *popen(const char *cmdstring, const char *tyoe);</span><br><span class="line">int pclose(FILE *fp);</span><br></pre></td></tr></table></figure><hr><h5 id="System-V-IPC机制"><a href="#System-V-IPC机制" class="headerlink" title="System V IPC机制"></a>System V IPC机制</h5><blockquote><p>1、使用相同的认证方法<br>2、进程通过系统调用向内核传递一个唯一的引用标识符才能访问资源<br>3、进程访问这些IPC资源先要经过权限检查<br>4、IPC对象包含一个ipc_perm结构</p></blockquote><p><em>基本概念：</em>每一个IPC有两个唯一的标志相连</p><ol><li>标识符<br>（1）一个非负整数，进程通过标识符访问IPC对象，IPC对象的内部名<br>（2）局限在IPC对象的类别里，不同类别的IPC可能有相同的标识符</li><li>关键字key<br>（1）IPC对象的外部名，key由内核变换成标识符<br>（2）创建一个IPC对象时，必须指定一个key<br>（3）key可以是IPC_PRIVATE（0），表示总是创建一个新的IPC资源，创建进程私有，子进程共享<br>（4）key也可以是其他整数，最好用ftok函数得到<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* path：文件路径名</span><br><span class="line">* id：只有低8位有效，0-255，同样的id返回同样的key</span><br><span class="line">* 成功返回key，失败-1。返回值根据文件inod确定</span><br><span class="line">* ey_t值算法：将文件的索引节点号取出，前面加上id号得到key_t的返回值。</span><br><span class="line">* 如指定文件的索引节点号为65538，换算成16进制为 0x010002，而你指定的ID值为38，换算成16进制为0x26，则最后的key_t返回值为0x26010002。</span><br><span class="line">*/</span><br><span class="line">key_t ftok(const char *path, int id);</span><br></pre></td></tr></table></figure></li></ol><p>ipc_perm结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line"></span><br><span class="line">struct ipc_perm</span><br><span class="line">&#123;</span><br><span class="line">  key_t key;   //关键字</span><br><span class="line">  uid_t uid;  //所有者的有效用户ID</span><br><span class="line">  gid_t gid;  //所有者所属组的有效组ID</span><br><span class="line">  uid_t cuid;  //创建者的有效用户ID</span><br><span class="line">  gid_t cgid;  //创建者所属组的有效组ID</span><br><span class="line">  mode_t mode;  //访问权限</span><br><span class="line">  unsigned short seq;  //应用序列号，不确定的值，每次被使用值增加，到最大值后从0开始</span><br></pre></td></tr></table></figure><ul><li><strong>消息队列</strong><blockquote><p>1、消息的链表，信息是一个数据结构，包括1个32位类型值，其余为数据区<br>2、克服流前两种的信息量有限的缺点，具有写权限的进程可以按照一定的顺序向消息队列中添加新消息，读权限的进程可以读取消息<br>3、每个消息可以带有一个整数识别符（message_type），对消息分类、查询<br>4、允许多个进程放入消息，也允许多个进程取出消息<br>5、可以按照先进先出取出，也可以只取某个识别符的消息<br>6、操作包含创建、打开队列、添加消息、读取消息、控制消息队列</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">strcut msqid_ds</span><br><span class="line">&#123;</span><br><span class="line">  struct ipc_perm msg_perm;   //ipc_perm</span><br><span class="line">  struct msg *msg_first;  //队列中第一个消息指针unused</span><br><span class="line">  struct msg *msg_last;  //队列中最后一个消息指针unused</span><br><span class="line">  _keynel_time_t msg_stime;  //最后发送消息的时间</span><br><span class="line">  _keynel_time_t msg_rtime;  //最后接收消息的时间</span><br><span class="line">  _keynel_time_t msg_ctime;  //最后队列的改变时间</span><br><span class="line">  unsigned short msg_cbytes;  //当前队列中字节总数</span><br><span class="line">  unsigned short msg_qnum;   //当前队列中消息个数</span><br><span class="line">  unsigned short msg_qbytes;  //队列的最大字节数</span><br><span class="line">  _kernel_ipc_pid_t msg_lspid;  //最后发送消息的进程pid</span><br><span class="line">  _kernel_ipc_pid_t msg_lrpid;  //最后接收消息的进程pid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>操作函数：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 创建或打开一个消息队列</span><br><span class="line">* key：</span><br><span class="line">* （1）0(IPC_PRIVATE)：建立新的消息队列（用于父子进程通信）</span><br><span class="line">* （2）大于0的32位整数：视参数flag来确定操作。通常要求此值来源于ftok返回的IPC键值</span><br><span class="line">* flag：</span><br><span class="line">* （1）0：取消息队列标识符，若不存在则函数会报错</span><br><span class="line">IPC_CREAT(未设置IPC_EXCL)：如果内核中不存在键值与key相等的消息队列，则新建一个消息队列；如果存在这样的消息队列，返回此消息队列的标识符</span><br><span class="line">* （2）IPC_CREAT|IPC_EXCL：如内核中不存在键值与key相等的消息队列，则新建一个消息队列；如果存在这样的消息队列则报错</span><br><span class="line">* （3）使用时模式参数要与IPC对象存取权限（如0600）进行|运算来确定消息队列的存取权限，如flag=IPC_CREAT|0666</span><br><span class="line">*/</span><br><span class="line">int msgget(key_t key, int flag);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 发送消息</span><br><span class="line">* msqid：消息队列标识符</span><br><span class="line">* nbytes：消息大小，不含消息类型的占4字节</span><br><span class="line">* ptr：指向一个长正整数的指针，正整数后跟所传数据</span><br><span class="line">* flag：0消息队列满时，msgsnd阻塞，IPC_NOWAIT队满时msgsnd不等带立即返回</span><br><span class="line">* 成功返回0，失败-1</span><br><span class="line">*/</span><br><span class="line">int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 接收消息</span><br><span class="line">* msqid：msgsnd类似</span><br><span class="line">* type：指定要接收哪条消息，不按FIFO</span><br><span class="line">* （1）=0，返回第一条</span><br><span class="line">* （2）&gt;0，返回队列中类型域=该值的第一条信息</span><br><span class="line">* （3）&lt;0，返回队列中类型域&lt;=该值绝对值的消息中，类型域最小的第一个消息</span><br><span class="line">* flag：</span><br><span class="line">* （1）PC_NOWAIT被设置：在指定的type无效的情况下，msgrcv将不等待而直接带错返回。否则msgrcv将被阻塞，直到所希望的信息已放置在队列中。</span><br><span class="line">* （2）IPC_NOERROR：若发送的消息大于size字节，则msgrcv把该消息截断，截断部分将被丢弃，且不通知发送进程。</span><br><span class="line">*/</span><br><span class="line">int msgrcv(int msqid, void *ptr, size_t nbytes, int flag);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 控制消息队列</span><br><span class="line">* msqid：</span><br><span class="line">* cmd：</span><br><span class="line">* （1）IPC_STAT:获得msgid指定的消息队列的控制数据结构msqid_ds到buf中</span><br><span class="line">* （2）IPC_SET：设置消息队列的属性，要设置的属性需先存储在buf中，可设置的属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes</span><br><span class="line">* （3）IPC_RMID:删除msqid指定的消息队列及相连的数据结构</span><br><span class="line">* （4）IPC_STAT 选项需具有队列的读权限，IPC_SET和IPC_RMID选项需要队列的创建者，所有者或特权进程</span><br><span class="line">*/</span><br><span class="line">int msgctl(int msgif, int cmd, strcut msqid_ds *buf);</span><br></pre></td></tr></table></figure><ul><li><strong>信号量（semaphore）</strong><blockquote><p>1、主要作为进程间及同一进程的不同线程间的同步和互斥手段，为了控制进程对资源的使用<br>2、具有整数值的对象，可表示当前可用的某种资源数<br>3、支持两种原子操作（最小操作，不可分割）P和V，P操作减小信号量的值（请求资源），信号量&lt;0阻塞。V操作增加信号量的值（释放资源），&gt;0，唤醒一个等待进程，=0表示没有资源可以用<br>4、可实现临界区的概念，一个临界区是一段代码，任何时刻只能有一个进程执行它，访问临界资源的代码叫临界区，临界区本身也是临界资源<br>5、临界资源同一时刻只允许有限个（通常1个）进程可以访问或修改</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct semid_ds &#123;</span><br><span class="line">    struct ipc_perm sem_perm;</span><br><span class="line">    struct sem *sem_base;   //信号数组（sem结构）指针</span><br><span class="line">    ushort  sem_nsem;  //此集中信号个数</span><br><span class="line">    time_t sem_otime;  //最后一次semop时间</span><br><span class="line">    time_t sem_ctime;  //最后一次改变时间</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sem &#123;</span><br><span class="line">    ushort_t semval;   //信号量的值</span><br><span class="line">    short sempid;  //最后一个调用semop的进程ID</span><br><span class="line">    ushort semncnt;  //等待该信号量值大于当前值的进程数</span><br><span class="line">    ushort semzcnt;  //等待资源完全空闲的进程数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><em>信号量集操作函数：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/sem.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 创建或打开一个信号量集</span><br><span class="line">* 成功返回信号量的标识符，semop和semctl使用</span><br><span class="line">* 参数nsem指定集合中的信号量数，若用于访问一个已经存在的集合，指定为0</span><br><span class="line">* flag参数和消息队列类似</span><br><span class="line">* 当一个新的信号集被创建时，相连的semid_ds结构被初始化</span><br><span class="line">*/</span><br><span class="line">int semget(key_t key, in nsems, int flag); </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 信号量操作</span><br><span class="line">* 参数nops规定ops数组元素个数</span><br><span class="line">* ops是一个指针，指向一个信号量操作数组，信号量操作由sembuf结构表示</span><br><span class="line">*/</span><br><span class="line">int semop(int semid, struct sembuf *sops, size_t nops);</span><br><span class="line"></span><br><span class="line">struct sembuf &#123;</span><br><span class="line">    short sem_num;  //要处理的信号量在信号集中的序号</span><br><span class="line">    short sem_op;   //信号量在一次操作中要改变的数据，通常是-1（P 操作）或+1（V操作），为0表示进程等待信号量变为0</span><br><span class="line">    short sem_flag;  //通常为SEM_UNDO，使操作系统跟踪信号，并在进程没有释放该信号量而终止时，由操作系统释放信号量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 控制</span><br><span class="line">* 第四个参数可选，取决于cmd</span><br><span class="line">* semnum指定信号集中的哪个信号</span><br><span class="line">* cmd指定以下10中命令，在semid指定的信号量集合上执行</span><br><span class="line">* （1）PC_STAT   读取一个信号量集的数据结构semid_ds，并将其存储在semun中的buf参数中。</span><br><span class="line">* （2）IPC_SET     设置信号量集的数据结构semid_ds中的元素ipc_perm，其值取自semun中的buf参数。</span><br><span class="line">* （3）IPC_RMID  将信号量集从内存中删除。</span><br><span class="line">* （4）GETALL      用于读取信号量集中的所有信号量的值。</span><br><span class="line">* （5）GETNCNT  返回正在等待资源的进程数目。</span><br><span class="line">* （6）GETPID      返回最后执行semop操作的进程PID。</span><br><span class="line">* （7）GETVAL      返回信号量集中的一个单个信号量的值。</span><br><span class="line">* （8）GETZCNT   返回在等待完全空闲的资源的进程数目。</span><br><span class="line">* （9）SETALL       设置信号量集中的所有的信号量的值。</span><br><span class="line">* （10）SETVAL      设置信号量集中的一个单独的信号量的值。</span><br><span class="line">*/</span><br><span class="line">int semctl(int semid, int semnum, int cmd, [union semun arg]);</span><br></pre></td></tr></table></figure><ul><li><strong>共享内存</strong><blockquote><p>1、最有用的进程间通信方式<br>2、使多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存数据的更新<br>3、需要依靠同步机制（互斥锁、信号量）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct shmid_ds</span><br><span class="line">&#123;</span><br><span class="line">  struct ipc_perm shm_perm;  //操作权限</span><br><span class="line">  int shm_segsz;  //段的大小</span><br><span class="line">  time_t shm_atime;  //最后一个进程附加到该段的时间</span><br><span class="line">  time_t shm_dtime;  //最后一个进程离开该段的时间</span><br><span class="line">  time_t shm_ctime;  //最后一个进程修改该段的时间</span><br><span class="line">  unsigned short shm_cpid;  //创建该段进程的pid</span><br><span class="line">  unsigned short shm_lpid;  //该段上操作的最后一个进程pid</span><br><span class="line">  short shm_nattach;  //当前附加导该段的进程的个数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><em>操作函数：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 打开或创建</span><br><span class="line">* key_t key是共享内存的关键字</span><br><span class="line">* size：内存大小</span><br><span class="line">* flag：内存的模式|读写权限，至少需要IPC_CREAT</span><br><span class="line">* （1）IPC_CREAT 新建（若已创建则返回目前id）</span><br><span class="line">* （2）IPC_EXCL和IPC_CREAT结合使用，若已创建则返回错误</span><br><span class="line">* 创建内存时，shmid_ds结构初始化，ipc_perm中的各项被设置为相应值，shm_lpid/shm_nattach/shm_atime 和shm_dtime被置为0，shm_ctime被置为当前时间</span><br><span class="line">*/</span><br><span class="line">int shmget(key_t key, size_t size, int flag);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 内存附加，允许本进程访问一块内存</span><br><span class="line">* shmid：内存id</span><br><span class="line">* addr：内存起始地址，若为NULL，内核自动查找进程地址空间，将共享内存附着在第一块有效内存区，此时flag无效。不为NULL，附加到addr指定位置，flag可为SHM_RDONLY（只读），否则为可读写</span><br><span class="line">*/</span><br><span class="line">void *shmat(int shmid, char *addr, int flag);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 内存分离但不删除</span><br><span class="line">*/</span><br><span class="line">int shmdt(void *addr);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 控制</span><br><span class="line">* cmd：控制命令</span><br><span class="line">* （1）IPC_STAT：得到共享内存状态</span><br><span class="line">* （2）IPC_SET：改变共享内存状态</span><br><span class="line">* （3）IPC_RMID：删除共享内存，调用此操作，不会再接受新的连接</span><br><span class="line">* （4）SHM_LOCK：共享区上锁，需要超级用户</span><br><span class="line">* （5）SHM_UNLOCK：解锁，超级用户</span><br><span class="line">* buf：结构体指针</span><br><span class="line">* 成功0，失败-1</span><br><span class="line">*/</span><br><span class="line">int shmctl(int shmid, int cmd, shmid_ds *buf);</span><br></pre></td></tr></table></figure><hr><h5 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）"></a>套接字（socket）</h5><p>可用于网络中的不同机器之间的进程间通信</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第四章 网络层</title>
      <link href="/2018/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2018/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="计算机网络——第四章-网络层"><a href="#计算机网络——第四章-网络层" class="headerlink" title="计算机网络——第四章 网络层"></a>计算机网络——第四章 网络层</h1><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><p><img src="https://upload-images.jianshu.io/upload_images/4061843-7941af59033f70b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><hr><hr><h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><p><img src="https://upload-images.jianshu.io/upload_images/4061843-2e5169076ee137cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>ARP</strong>：地址解析协议<br><strong>RARP</strong>：逆地址解析协议，与ARP配合使用<br><strong>ICMP</strong>：网际控制报文协议<br><strong>IGMP</strong>：网际组管理协议</p><h4 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h4><p>唯一的标识，32位，点分十进制表示<br><img src="https://upload-images.jianshu.io/upload_images/4061843-40c8c11ff88955f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p><strong>A类地址：</strong><br>1、单播地址，前8位为网络id，第一位0固定，后24位为主机id，<br>2、可指派网络数为126（2^7-2）个，全0表示本网络，是保留地址，全1（127）是本地环回地址，作为本地软件环回测试，即127不是一个网络地址<br>3、主机号占3个字节（24位），最大主机数2^24-2，除去主机号为全0和全1的两个，全0的主机号表示本主机所连接的单个网络地址，全1表示该网络上的所有主机<br>4、地址空间有2^31个，占所有的50%</p></li><li><p><strong>B类地址：</strong><br>1、单播地址，前16位为网络id，前两位10固定，后16位为主机id<br>2、只剩14位，所以不会出现全1或全0的情况，<br>3、B类最小的地址是128.1.0.0，可指派网络数为2^14-1个，但是128.0.0.0不指派<br>4、主机号占2个字节（16位），最大主机数是2^16-2，除去主机号为全0和全1的两个<br>5、地址空间有2^30个，占所有的25%</p></li><li><p><strong>C类地址：</strong><br>1、单播地址，前24位为网络id，前三位110固定，后8位为主机id<br>2、可指派网络数为2^21-1，其中192.0.0.0不指派，最小网络地址为192.0.1.0<br>3、主机号占一个字节（8位），最大主机数是2^8-2，除去主机号为全0和全1的两个<br>4、地址空间2^29个，占所有的12.5%</p></li><li><p><strong>D类地址：</strong><br>多播地址，前四位1110固定</p></li><li><p><strong>E类地址：</strong><br>保留地址，前四位1111固定</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-b954702e94e55fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-20aa4aff1db9ced2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-2b20507e16cbb39a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>IP的特点<br>（1）IP地址由网络号和主机号两部分组成，路由器仅根据目的主机所连的网络号来转发分组<br>（2）IP地址是标志一台主机（或路由器）和一条链路的接口，当处于不同的网络时，应该有不同的网络号，一个主机可以同时具备多个网络号（多归属主机）<br>（3）一个网络是指具有相同的网络号net-id的主机的集合，因此用转发器或网桥连接起来的若干个局域网仍为一个网络，不同网络号的网络或局域网必须使用路由器连接，也就是说网络的划分根据网络号，而且必须是使用路由器进行连接</li></ul><h4 id="IP地址和硬件地址"><a href="#IP地址和硬件地址" class="headerlink" title="IP地址和硬件地址"></a>IP地址和硬件地址</h4><p>IP地址：网络层和以上各层使用的地址，是逻辑地址，放在IP数据报的首部<br>硬件地址：数据链路层和物理层使用的地址，放在MAC帧的首部</p><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，每一个映射地址有一定的生存时间，定期更新</p><p>ARP是解决同一个局域网上的主机或路由器的IP到硬件地址映射的问题，</p><p>（1）ARP进程在本局域网上广播一个ARP请求分组，请求分组中包含自己的硬件地址和IP地址<br>（2）本局域网上的所有主机运行的ARP进程都会收到<br>（3）如果某个主机的IP地址和ARP请求分组中要查询的IP一致，就会收下这个ARP，在自己的ARP高速缓存中写入源主机的IP到硬件地址的映射，并向源主机发送ARP响应分组（单播），同时在这个响应分组中写入自己的硬件地址<br>（4）源主机收到ARP响应分组后，在ARP高速缓存中写入该主机的IP到硬件地址的映射</p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-1a6d0b557b8789ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>ARP的四种典型情况</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-a7273b1467cf7f87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>（1）发送方是主机（H1），要把IP数据报发送到同一个网络上的另一个主机（H2）。这时H1发送ARP请求分组（在网1上广播），找到H2的硬件地址<br>（2）发送方是主机（H1），要把IP数据报发送到另一个网络的主机（H3或H4）。这时H1发送ARP请求分组（在网1上广播），找到网1上的路由器R1的硬件地址。剩下的工作交由R1完成（3）、（4）<br>（3）发送方是路由器（R1），要把IP数据报发送给同一网络（网2）上的主机（H3）。这时R1发送ARP请求分组（在网2上广播），找到H3的硬件地址<br>（4）发送方是路由器（R1），要把IP数据报转发到网3的一个主机（H4）。这时R1发送ARP请求分组（在网2上广播），找到R2的硬件地址，剩下的由R2完成</p><h4 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h4><p><img src="https://upload-images.jianshu.io/upload_images/4061843-ad708055fcdc594e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li>版本：占4位，IP协议的版本，通信双方版本必须一致，IPv4或IPv6</li><li>首部长度：4位，可表示的最大十进制数是15，首部长度所表示数的单位是32位字，IP首部的固定长度为20字节，所以首部长度字段的最小值为5（0101）。当首部长度为最大值15（1111）时，表明首部长度达到最大值15个32位字长，即60字节。当首部长度不是4字节的整数倍时开始，必须使用最后的字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍开始</li><li>区分服务：8位，用来获得更好的服务</li><li>总长度：16位，首部和数据之和的长度，单位为字节。因此数据报的最大长度为2^16-1=65535字节</li><li>标识：16位，计数器，用于分片后组装成原来的数据报</li><li>标致：3位，目前只有2位有意义<br>1、MF：最低位，为1时表示后面还有分片，为0时表示最后一个<br>2、DF：不能分片，DF=0时才允许分片</li><li>片偏移：13位，较长的分组在分片后，某片在原分组中的相对位置，以8个字节为偏移单位，也就是说每个分片的长度一定是8字节的整数倍</li><li>生存时间：8位，TTL，数据报在网络中的寿命</li><li>协议：8位，使用何种协议</li><li>首部检验和：16位，只检验数据报的首部，不检验数据部分</li><li>源地址：32位</li><li>目的地址：32位</li></ol><h4 id="分组转发"><a href="#分组转发" class="headerlink" title="分组转发"></a>分组转发</h4><p>算法：<br>（1）从数据报的首部提取目的主机的IP地址D，得到目的网络地址N<br>（2）若N是与此路由器直接相连的某个网络地址，则直接交付，不需要经过其他的路由器，直接给目的主机。否则间接交付，执行（3）<br>（3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中指明的下一跳路由器，否则执行（4）<br>（4）若路由表中有到达网络N的路由，则把数据报传送给路由表中指明的下一跳路由器，否则执行（5）<br>（5）若路由表中有一个默认路由，则把数据报传送给路由表中指明的默认路由，否则执行（6）<br>（6）报告转发分组出错</p><hr><h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><ul><li><p><strong>划分</strong><br>从网络的主机号借用若干位作为子网号（subnet-id），不改变原来的网络号，将两级IP地址在本单位内部变为三级IP地址：网络号、子网号、主机号<br><img src="https://upload-images.jianshu.io/upload_images/4061843-9a079a664b749fc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p><strong>子网掩码</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-f0b72db722344af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><p>把子网掩码和IP地址进行逐位的“与运算”就能得出网络地址<br><img src="https://upload-images.jianshu.io/upload_images/4061843-94a875a0edeb1a60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><em>默认子网掩码：</em><br>1、A类：255.0.0.0或0xFF000000<br>2、B类：255.255.0.0或0xFFFF0000<br>3、C类：255.255.255.0或0xFFFFFF00<br><em>常见划分（B类）</em><br><img src="https://upload-images.jianshu.io/upload_images/4061843-6610fa6f6232f1ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/4061843-e19d182fb33558a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><strong>使用子网时的分组转发</strong><br>（1）获取目的IP地址D<br>（2）判断是否为直接交付。对路由器直接相连的网络进行逐个检查：用个网络的子网掩码和D逐位相“与”，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付，否则间接交付，执行（3）<br>（3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表指明的下一跳路由器，否则执行（4）<br>（4）对路由表中的每一行（目的网络地址、子网掩码、下一跳地址），用其中的子网掩码和D逐位相“与”，其结果为N。若N与该行的目的网络地址匹配，则把数据报传送给指明的下一跳路由器，否则执行（5）<br>（5）若路由表中有一个默认路由，则把数据报传送给指明的默认路由器，否则执行（6）<br>（6）报告转发分组出错</li></ul><h4 id="无分类编址CIDR（构造超网）"><a href="#无分类编址CIDR（构造超网）" class="headerlink" title="无分类编址CIDR（构造超网）"></a>无分类编址CIDR（构造超网）</h4><p><em>特点：</em><br>（1）CIDR消除了传统的A类、B类、C类地址及划分子网的概念<br>IP地址={&lt;网络前缀&gt;，&lt;主机号&gt;}，还可以用斜线记法，“\”后面的数字就是地址掩码中1的个数<br>（2）CIDR把网络前缀都相同的连续IP地址组成一个CIDR地址块<br><img src="https://upload-images.jianshu.io/upload_images/4061843-665be83bb965e0d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-b5095ecb1c5ec9ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/4061843-8c656afe34a7645e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><em>最长前缀匹配：</em><br>匹配结果中选取网络前缀最长的路由</p><p><em>二叉线索查找路由表</em></p><hr><h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p><img src="https://upload-images.jianshu.io/upload_images/4061843-8b7ce032e26ddd01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-e59aac4bc6d804cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><strong>ICMP差错报告报文</strong><br>（1）终点不可达：当路由器或主机不能交付数据报时就像源点发送终点不可达报文<br>（2）时间超时：当路由器收到生存时间为0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片丢弃，并向源点发送时间超过报文<br>（3）参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文<br>（4）改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器</li></ul><p><em>不应发送ICMP差错报文的情况：</em><br>1、对ICMP差错报告报文，不再发送ICMP差错报告报文（不对自身发送）<br>2、对第一个分片的数据报片的所有后续数据报片，都不发送ICMP差错报告报文（对一个IP数据报只发一次ICMP差错报告报文）<br>3、对具有多播地址的数据报，都不发送<br>4、对具有特殊地址的数据报，不发送</p><ul><li><p><strong>ICMP询问报文</strong><br>（1）回送请求和回答：ICMP回送请求报文是主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。用来测试是否可达及了解其有关状态<br>（2）时间戳请求和回答：ICMP时间戳请求报文是请某台主机或路由器回答当前的日期和时间。可用于时钟同步和时间测量</p></li><li><p><strong>ICMP应用举例</strong><br>1、PING：从应用层直接到ICMP，没有通过TCP或UDP，使用了ICMP回送请求与回送回答报文<br>2、traceroute</p></li></ul><hr><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><h4 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h4><p>即在一个自治系统内部使用的路由选择协议</p><ul><li><strong>RIP</strong><br>分布式的基于距离向量的路由选择协议，距离也叫“跳数”，每经过一个路由器，跳数+1，距离+1，RIP允许一条路径最多经过15个路由器，距离=16为不可达</li></ul><p><strong>特点：</strong><br>1、仅和相邻路由器交换信息<br>2、交换的信息是当前路由器的路由表<br>3、固定时间间隔交换信息<br><strong>距离向量算法：</strong><br>（1）对地址为X的相邻路由发来的RIP报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为X，并把所有的“距离”的值都+1（解释1），每一个项目都有三个关键数据：到目的网络，距离是d，下一跳路由器是X<br>（2）对修改后的RIP报文中的每一个项目，进行以下步骤：<br>若原来的路由表中没有目的网络N，则把该项目添加到路由表中（解释2）；否则（没有N，查看下一跳的路由器）若下一跳路由器地址是Ｘ，则把收到的项目替换原路由表中的项目（解释3），否则（这个项目是到目的网络N，但下一跳不是X）若受到的项目中的距离d小于路由表中的距离，则进行更新（解释4），否则什么也不做<br>（3）若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器（距离设置为16）<br>（4）返回<br><img src="https://upload-images.jianshu.io/upload_images/4061843-4624cfd29cc15bb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>查看目的网络，比较下一跳，再决定是否更新距离<br><strong>报文格式：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-4b4caa4e91ac9453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li>首部：4个字节，1表示请求路由信息，2表示对请求路由信息的响应或未被请求而发出的路由更新报文，后面的必为0是为了4字节的对齐</li><li>路由部分由若干路由信息，每个路由信息需要用20个字节</li><li>路由信息：<br>1、地址标识符（地址类别）：使用的地址协议，2表示IP地址<br>2、路由标记：填入自治系统好ASN<br>3、网络地址：<br>4、子网掩码：<br>5、下一跳路由器地址：<br>7、到此网络的距离</li><li>一个RIP报文最多包括25个路由，最大长度4+20*5=504字节</li><li>RIP2具有简单的鉴别功能</li></ol><ul><li><strong>OSPF</strong><br>开放最短路径优先，分布式的链路状态协议</li></ul><p><strong>特点：</strong><br>（1）向本自治系统中所有路由器发送信息，洪泛法<br>（2）发送的信息就是与本路由器相邻的所有路由器的链路状态<br>（3）只有当链路状态发生变化时，才再次洪泛更新<br>（4）允许管理员给每条路由指派不同的代价<br>（5）如果同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路由（负载平衡）<br>（6）所有OSPF交换的分组都具有鉴别功能<br>（7）支持可变长度的子网划分和无类的编址CIDR<br>（8）OSPF让每一个链路状态带上一个32位序号，表示链路状态的新旧程度，序号越大越新<br><strong>OSPF分组：</strong><br><em>不用UDP而是直接用IP数据报发送（IP协议字段89）</em><br><img src="https://upload-images.jianshu.io/upload_images/4061843-90d980d429ab9af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>（1）版本：当前2<br>（2）类型：可以是5中类型分组中的一种<br>（3）分组长度：包含首部在内的分组长度，字节为单位<br>（4）路由标识符：标志发送该分组的路由器的接口的IP地址<br>（5）区域标识符：分组属于的区域的标识符<br>（6）检验和：检验分组的差错<br>（7）鉴别类型：0不用口令，1口令<br>（8）鉴别：<br><strong>五种分组类型：</strong><br>（1）类型1：问候分组（Hello），用来发现和维持邻站的可达性<br>（2）类型2：数据库描述分组（Database Description），向邻站给出自己的链路状态数据库中所有链路状态项目的摘要信息<br>（3）类型3：链路状态请求分组（Link State Request），向对方请求发送某些链路状态项目的详细信息<br>（4）类型4：链路状态更新分组（Link State Update），用洪泛法对全网更新链路状态<br>（5）类型5：链路状态确认分组（Link State Acknowledgement），对链路更新分组的确认<br><strong>支持的网络类型：</strong><br>（1）点对点，T1、SONET、DS-3<br>（2）Broadcast<br>（3）NBMA：ATM、X.25、FR<br>（4）虚链路</p><h4 id="外部网关协议EGP"><a href="#外部网关协议EGP" class="headerlink" title="外部网关协议EGP"></a>外部网关协议EGP</h4><p>源主机和目的主机处于不同的自治系统中，跨越自治系统</p><ul><li><strong>BGP</strong><br>边界网关协议，采用了路径向量路由选择协议，树形结构，TCP连接</li></ul><p><strong>特点：</strong><br>（1）BGP协议交换路由信息的结点数量级是自治系统数的量级<br>（2）每一个AS中BGP发言人很少<br>（3）支持CIDR<br>（4）刚运行，BGP的邻站是交换整个BGP路由表<br><strong>4种报文：</strong><br>（1）OPEN报文，用来与相邻的另一个BGP发言人建立关系，使通信初始化<br>（2）UPDATE报文，用来通告某一路由信息，以及列出要撤销的多条路由<br>（3）KEEPALIVE报文，用来周期性的证实邻站的连通性，19字节长<br>（4）NOTIFICATION报文，用来发送检测到的差错<br><strong>报文格式：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-bf28c98957b7c11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>通用首部：19字节<br>1、标记：16字节，用来鉴别收到的BGP，不使用鉴别时，全1<br>2、长度：包括首部在内的整个BGP报文以字节为单位的长度，最小值为19，最大值4096<br>3、类型字段：1~4</p><h4 id="路由器的构成"><a href="#路由器的构成" class="headerlink" title="路由器的构成"></a>路由器的构成</h4><p>转发分组，具有多个输入端口和多个输出端口的专用计算机<br><img src="https://upload-images.jianshu.io/upload_images/4061843-660005ebe27e9d0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li><p>路由选择：按照分布式算法，动态的改变所选择的路由</p></li><li><p>分组转发：根据转发表转发</p></li></ul><ol><li><p>交换结构：<img src="https://upload-images.jianshu.io/upload_images/4061843-181697580f5b33ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>输入端口：<img src="https://upload-images.jianshu.io/upload_images/4061843-64fe7dbd48aa6f68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>若助理分组的速率赶不上分组进入队列的速率，队列的存储空间会减小到0，当没有存储空间时，后面的分组就会被丢弃，同时告诉发送方减小发送速率</p></li><li><p>输出端口：<img src="https://upload-images.jianshu.io/upload_images/4061843-54b40b39a924a1ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第三章 数据链路层</title>
      <link href="/2018/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2018/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="计算机网络——第三章-数据链路层"><a href="#计算机网络——第三章-数据链路层" class="headerlink" title="计算机网络——第三章 数据链路层"></a>计算机网络——第三章 数据链路层</h1><h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><p><strong>链路</strong>：从一个结点到相邻结点的一段物理路线，路径组成的一部分<br><strong>数据链路</strong>：除了物理线路，还包括一些通信协议，如网络适配器</p><p><em>当数据通信中采用复用技术时，一条链路上可以有多条数据链路</em></p><ul><li><p>主要功能<br>1、链路管理：数据链路连接的建立、维持和释放的操作<br>2、寻址：必须保证每一帧都能送到正确的地址，接收方要能够知道谁是发送方（MAC地址及转发表）<br>3、流量控制：控制相邻两个节点之间数据链路上的流量（如停等协议、ARQ协议、滑动窗口协议等）<br>4、帧同步：准确地区分帧的起始与终止（帧标志）<br>5、透明传输：在数据链路层中，对所传输的数据无论它们是由什么样的比特组合起来的，在数据链路上都应该能够传输，如：零比特插入法（5个连1插1个0）<br>6、差错控制：如错误帧或帧丢失，常用的差错控制方法有检错重发（自动请求重发ARQ）、前向纠错FEC、反馈检验法</p></li><li><p>主要步骤<br>（1）将网络层的IP数据报添加首部和尾部封装成帧<br>（2）将封装好的帧发送给相邻的数据链路层<br>（3）接收导的帧无差错，提取IP数据报上交给网络层</p></li></ul><h4 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h4><ul><li><p>封装成帧：在一段数据的前后分别加上首部和尾部<br>最大传输单元MTU：帧的数据部分长度上限<br>控制字符SOH：帧的首部开始<br>控制字符EOT：帧的尾部结束</p></li><li><p>透明传输：数据链路层对数据是透明的<br>转义字符ESC：使控制字符SOH、EOT不被解释为控制字符，发送端插入改字符，接收端删除该字符，这就是字节填充、字符填充<img src="https://upload-images.jianshu.io/upload_images/4061843-4483f0c63728cdd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li></ul><ul><li>差错检测：<br>比特差错：0变1，1变0<br>误码率BER：同一时间内，传输错误的比特占传输比特总数的比率<br>循环冗余检验CRC技术<br>帧检验序列FCS<br><img src="https://upload-images.jianshu.io/upload_images/4061843-64f372af47810eba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-029ad30c9f6fd202.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名.jpg"></p><h4 id="常见数据链路层协议"><a href="#常见数据链路层协议" class="headerlink" title="常见数据链路层协议"></a>常见数据链路层协议</h4><p><img src="https://upload-images.jianshu.io/upload_images/4061843-51679fc1495d1fca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><hr><hr><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p>用户计算机和ISP进行通信时所使用的数据链路层协议</p><ul><li><p><strong>三个核心组成部分：</strong><br>1、上传用户数据（IP数据报等）封装方法<br>2、LCP链路控制协议<br>3、NCP网络控制协议</p></li><li><p>PPP的组成<br>（1）一个将IP数据报封装到串行链路的方法，IP数据报在PPP帧中就是信息部分，长度受到MTU限制<br>（2）一个用来建立、配置和测试数据链路连接的链路控制协议LCP<br>（3）一套网络控制协议NCP</p></li></ul><h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><ul><li>字段的意义<br><img src="https://upload-images.jianshu.io/upload_images/4061843-d2fcc0799f69d6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><img src="https://upload-images.jianshu.io/upload_images/4061843-818747c8379afd18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><p>F：标志字段，规定为0x7E，表示帧的开始和结束<br>A：地址字段，规定位0xFF<br>C：控制字段，规定为0x03<br>协议：2字节，字段为0x0021时，PPP帧的信息部分为IP数据报，若为0xC021，信息字段是LCP的数据，若为0x8021，信息字段是网络层的控制数据<br>FCS：使用CRC的帧检验序列</p><ul><li><p>字节填充<br>当信息字段中出现和标志字段一样的比特（0x7E）组合时，需要转义<br>异步传输时，定义转义字符位0x7D，使用字节填充<br>（1）把信息字段中出现的每一个0x7E字节转变成2字节序列(0x7D, 0x5E)<br>（2）若信息字段中出现一个0x7D的字节，则把0x7D转变成2字节序列(0x7D, 0x5D)<br>（3）若字段出现ASCII码的控制字符，则在字符前加入一个0x7D字节，同时将字符的编码改变<br>接收端进行相反的变换</p></li><li><p>零比特填充<br>在SONET/SDH链路时，同步传输</p></li></ul><h4 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h4><p><img src="https://upload-images.jianshu.io/upload_images/4061843-66eb896f6657eb9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名.jpg"></p><p>1、当拨号接入ISP后，对拨号确认，建立物理连接<br>2、用户个人电脑向ISP发送一些列的链路控制协议LCP分组（封装成多个PPP帧），这些分组及其响应选择了将要使用的一些PPP参数来配置数据链路<br>3、LCP配置完成后，进入认证阶段（也可以不认证）<br>4、网络层协商阶段，NCP给新接入的用户分配IP地址。<br>5、通信完毕后，NCP释放网络层连接，收回IP地址，LCP释放数据链路层连接，最后释放物理层连接。</p><p>LCP配置请求帧（Configure-Request）：<br>（1）配置确认帧（Configure-Ack）<br>（2）配置否认帧（Configure-Nak）<br>（3）配置拒绝帧（Configure-Reject）</p><p>鉴别：<br>（1）口令鉴别协议PAP：明文<br>（2）口令握手鉴别协议CHAP：密文</p><p>PPP链路上若运行IP协议，NCP就要使用IP控制协议IPCP（字段：0x8021）</p><p>网络配置完毕后，进入Link Open，两个PPP端点还可发送回送请求LCP分组（Echo-Request）和回送回答LCP分组（Echo-Reply）</p><p>数据传输结束后，链路一端发送终止请求LCP分组（Terminate-Request）请求终止，在收到对方发来的确认LCP分组（Terminate-Ack）后，链路终止</p><hr><hr><h2 id="PPPoE协议"><a href="#PPPoE协议" class="headerlink" title="PPPoE协议"></a>PPPoE协议</h2><ul><li><p>发现阶段：x8863<br>（1）PADI（广播）：用户计算机发起初始化广播报文<br>（2）PADO（单播）：访问集中器回应各用户主机发送的PADI报文<br>（3）PADR（单播）：用户向服务器发送单播的请求报文<br>（4）PADS（单播）：访问集中器为会话分配唯一的会话ID<br>（5）PADT：强制结束会话</p></li><li><p>点对点会话阶段：x8864，PPP协议完成<br>（1）LCP<br>（2）PAP<br>（3）NCP<br>（4）PADT：强制终止PPPoE会话</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-5d4f798b71cdd0a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><hr><hr><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><h4 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h4><p>主要特点：网络为一个单位所有，地理范围和站点数目有限<br>优点：<br>（1）广播功能，从一个站点方便全网，局域网上的主机可共享连接在网上的硬件和软件资源<br>（2）便于系统的扩展和逐渐演变，设备位置可灵活调整<br>（3）提高系统的可靠性、可用性、生存性</p><ul><li><p>网路拓扑分类：星型网、环形网、总线网</p></li><li><p>共享信道的方法<br>（1）静态划分信道：频分复用、时分复用、波分复用、码分复用<br>（2）动态媒体接入控制：多点接入，信道并非用户通信时固定分配给用户<br>随机接入：随机发送信息，会产生碰撞导致信息发送失败<br>受控接入：用户不能随机发送信息，必须服从一定的控制，如多点线路探询、论询</p></li><li><p>以太网的两个标准<br>（1）标准DIX Ethernet V2<br>（2）标准IEEE 802.3[W-IEEE802.3]</p><blockquote><p>IEEE 802<br>802.1——桥接/体系结构<br>802.3——以太网<br>802.11——无线局域网<br>802.15——无线个人区域网<br>802.16——宽带无线接入<br>802.19——无线共存<br>802.21——媒体无关切换<br>802.22——无线偏远地区网络</p></blockquote></li></ul><p>局域网的数据两路层分为逻辑链路控制LLC（Logical Link Control）子层和媒体接入控制MAC（Medium Access Control）子层</p><ul><li>适配器</li></ul><h4 id="CSMA-CD-协议（半双工通信）"><a href="#CSMA-CD-协议（半双工通信）" class="headerlink" title="CSMA/CD 协议（半双工通信）"></a>CSMA/CD 协议（半双工通信）</h4><p>载波监听多点接入/碰撞检测</p><ul><li>多点接入：总线型网络</li><li>载波监听：用电子技术检测总线上有没有其他计算机也在发送，检测信道</li><li>碰撞检测：边发送边监听<blockquote><p>电磁波在1km电缆的传播时延约为5us，争用期时间为单次传播的两倍（往返）为51.2us，512比特时间</p></blockquote></li></ul><h4 id="使用集线器的星型拓扑"><a href="#使用集线器的星型拓扑" class="headerlink" title="使用集线器的星型拓扑"></a>使用集线器的星型拓扑</h4><p>（1）仍然是一个总线网<br>（2）有许多接口，像一个多接口的转发器<br>（3）工作在物理层，仅仅简单转发比特<br>（4）专门的芯片，进行自适应串音回波抵消</p><h4 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h4><p>a=单程端到端时延/帧的发送时间<br>极限信道利用率=1 /（1-+a）</p><h4 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h4><ul><li><p>MAC层的硬件地址：MAC地址，物理地址，IEEE 802规定48位（6个字节）的地址（固化在适配器的ROM中的地址）<br>OUI：组织唯一标识符，前3个字节，又叫公司标识符<br>扩展标识符：后3个字节<br>IEEE规定地址字段的第一个字节最低位为I/G位，I/G为0时表示单个地址，为1时表示组地址（进行多播）</p></li><li><p>MAC帧的格式</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-c5cd5943b01acc74.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名.jpg"><br>类型：标志上一层使用了什么协议<br>数据：IP数据报<br>FCS：帧检验序列（CRC检验）<br>插入的8字节：<br>（1）前7个字节的前同步码，使接收端的适配器在接收MAC帧时调整时钟频率，使同步<br>（2）帧开始定界符，为10101011</p><p>数据长度小于46字节时会自动加入填充字段，以保证每个帧长不少于64字节<br>无效帧：<br>（1）长度不是整数个字节<br>（2）FCS检测有错<br>（3）数据长度不在46～1500字节之间，MAC首尾有18个，真正有效长度64～1518</p><hr><hr><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><ul><li><p>物理层扩展<br>光纤调制解调器：进行电信号和光信号的转换</p></li><li><p>数据链路层扩展</p></li></ul><p><strong>以太网交换机</strong>：特点：多接口的网桥，全双工方式，具有并行性，无碰撞传输<br>自学习能力：自学之前广播发出，学习有了MAC地址后不再广播<br>总线以太网到星型以太网</p><ul><li>虚拟局域网<br>VLAN划分</li></ul><h4 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h4><p>虚拟局域网，是一种通过将局域网内的设备逻辑地而不是物理地划分成一个个网段从而实现虚拟工作组的技术。 </p><p>划分Vlan的主要作用是隔离广播域。<br><strong>两种方法：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-046bedcd99d828e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/4061843-2d41b3494d676689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li><strong>VLAN的划分方法：</strong></li></ul><ol><li>基于端口的VLAN：<img src="https://upload-images.jianshu.io/upload_images/4061843-704a855e646f2dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>基于MAC地址的VLAN：<img src="https://upload-images.jianshu.io/upload_images/4061843-c81b7d97ff30a6aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>基于协议的VLAN：<img src="https://upload-images.jianshu.io/upload_images/4061843-112abcf0cb43d05d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>基于子网的VLAN：<img src="https://upload-images.jianshu.io/upload_images/4061843-76bad03b9816fe0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ol><ul><li><strong>VLAN工作原理：</strong><br>1、<img src="https://upload-images.jianshu.io/upload_images/4061843-b85066ee690950cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>2、<img src="https://upload-images.jianshu.io/upload_images/4061843-d9a31f8e75881381.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><p><strong>报文类型：</strong><img src="https://upload-images.jianshu.io/upload_images/4061843-674dff39b4885b4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><strong>端口类型：</strong><img src="https://upload-images.jianshu.io/upload_images/4061843-6f4b2a2c746cf7cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/4061843-538e6fcbebdce1ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li><strong>标准：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4061843-9bc609901fa1851b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><hr><hr><h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><ul><li>100BASE-T：100Mbit/s，星型拓扑，快速以太网</li><li>基比特以太网：1Gbit/s下全双工或半双工工作，使用IEEE 802.3协议的帧格式，只在半双工下使用CSMA/CD协议，与10BASE-T和100BASE-T技术向后兼容</li><li>10吉比特以太网和更快的以太网：10GE只在全双工方式</li><li>以太网宽带接入</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第二章 物理层</title>
      <link href="/2018/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2018/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="计算机网络——第二章-物理层"><a href="#计算机网络——第二章-物理层" class="headerlink" title="计算机网络——第二章 物理层"></a>计算机网络——第二章 物理层</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="物理层特性"><a href="#物理层特性" class="headerlink" title="物理层特性"></a>物理层特性</h4><blockquote><ol><li><p>机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。<img src="https://upload-images.jianshu.io/upload_images/4061843-abd5f7b090ce4a7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>电气特性：指明在接口电缆的各条线上出现的电压的范围。<img src="https://upload-images.jianshu.io/upload_images/4061843-e6f239dad5325182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>功能特性：指明某条线上出现的某一电平的电压表示何种意义。<img src="https://upload-images.jianshu.io/upload_images/4061843-ee491e462b50da98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>规程特性指明对于不同功能的各种可能事件的出现顺序<img src="https://upload-images.jianshu.io/upload_images/4061843-11d9aa0fd1a9aa9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li></ol></blockquote><hr><h4 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h4><ul><li><p>概念：<br>1、宽带线路：可通过较高数据率的线路，每秒有更多比特从结点注入到线路。<br>2、窄带线路：数据传输速率较低的线路。<br>3、宽带线路和窄带线路上比特的传播速率是一样的。</p></li><li><p><strong>接入技术：</strong></p></li></ul><ol><li><p>有线接入</p><blockquote><p>1、铜线接入：<br>（1）XDSL：DSL（Digital Subscriber Line，数字用户线）以铜质电话线为传输介质，在一根铜线上分别传送数据和语音信号。<br><em>引起线路传输损伤的几个主要因素：</em><br>①传输损耗<br>②噪声<br>③信号反射（混合线圈和回波）<br>（2）ADSL：ADSL技术可实现在一对普通电话双绞线上同时传送高速数据业务和话音业务。它的数据业务速率最高下行达8Mbps，最高上行速率达1Mbps。ADSL的传输距离最大可达4～5km。<br>ADSL的技术标准及发展：ADSL、 ADSL2、 ADSL2+<img src="https://upload-images.jianshu.io/upload_images/4061843-defb6a77dffcfb89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>2、光纤接入<br>（1）PON：无源光网络， PON是一种应用于接入网，由局端设备（OLT）与多个用户端设备（ONU/ONT）之间通过无源的光缆、光分/合路器等组成的光分配网（ODN）连接的光接入网络。所谓无源，是指在OLT(光线路终端)和ONU(光网络单元)之间的ODN (光分配网络)没有任何有源电子设备。采用WDM技术，实现单纤双向传输。<br><strong>构成：</strong><br>OLT（Optical Line Terminal）－光线路终端<br>ONU（Optical Network Unit）－光网络单元<br>ONT（ Optical Network Terminal）－光网络终端<br>ODN（Optical Distribution Network）－光分配网</p><p>3、光纤/铜轴混合接入<br>（1）HFC：</p></blockquote></li><li><p>无线接入</p><blockquote><p>1、wifi<br>2、WiMAX<br>3、蓝牙<br>4、3G、4G</p></blockquote></li></ol><hr><h4 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h4><ul><li>源系统（发送端、发送方）：<br>（1）源点：源站，信源，源点设备要产生要传输的数据<br>（2）发送器：将源点生成的数字比特流进行编码后给传输系统传输，如调制器</li><li>传输系统</li><li>目的系统（接收端、接收方）：<br>（1）接收器：将传输系统过来的信号接收并转为能够被目的设备处理的信号，如解调器<br>（2）终点：目的站，信宿，从接收器获取数字比特流，然后把信息输出</li></ul><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>消息：话音、文字、音频、视频等</li><li>数据：运送消息的实体，是使用特定方式表示的信息，通常是有意义的符号序列</li><li>信号：数据的电气或电磁的表现</li><li>模拟信号（连续信号）：代表消息的参数的取值是连续的</li><li>数字信号（离散信号）：代表消息的参数的取值是离散的，最原始的</li></ul><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><ul><li>单向信道：单工通信，只能有一个方向而没有反方向的交互</li><li>双向交替通信：半双工通信，通信的双方都可以发送消息，但双方不能同时发送或接收</li><li>双向同时通信：全双工通信，通信的双方可以同时发送和接收信息</li></ul><p><strong>基带信号</strong>：来自信源的信号<br><strong>调制</strong>：（1）基带调制：仅仅对基带信号的波形进行变换，变换后的信号仍是基带信号，也叫编码<br>（2）带通调制：用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换位模拟信号，调制后的信号叫带通信号</p><p><strong>常用编码方式</strong>：</p><ul><li>不归零制</li><li>归零制</li><li>曼彻斯特编码</li><li>差分曼彻斯特编码</li></ul><p><strong>基本带通的调制方法</strong>：</p><ul><li>调幅AM</li><li>调频FM</li><li>调相PM</li></ul><h4 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h4><p>（1）信道能够通过的频率范围：<br>码间串扰：接收端收到的信号波形就失去流码元之间的清晰界限<br>（2）信噪比：信号的平均功率和噪声的平均功率之比，S/N，信噪比越大，极限传输速率越高</p><hr><hr><h2 id="物理层的传输媒体"><a href="#物理层的传输媒体" class="headerlink" title="物理层的传输媒体"></a>物理层的传输媒体</h2><ul><li>导引型传输媒体<br>（1）双绞线<br>（2）同轴电缆<br>（3）光缆</li><li>非导引型传输媒体<br>（1）无线电波</li></ul><h2 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h2><ul><li>频分复用FDM</li><li>时分复用TDM</li><li>统计时分复用STDM：异步时分复用</li><li>波分复用WDM</li><li>码分复用CDM：码分多址CDMA </li></ul><h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><h4 id="宽带接入技术-1"><a href="#宽带接入技术-1" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h4><ul><li>ADSL技术：非数字用户线技术，数字技术对现有的模拟电话用户进行改造</li><li>光纤同轴混合网HFC：</li><li>FTTx技术：多种宽带光纤接入方式</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第一章 体系</title>
      <link href="/2018/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E4%BD%93%E7%B3%BB/"/>
      <url>/2018/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="计算机网络——第一章-体系"><a href="#计算机网络——第一章-体系" class="headerlink" title="计算机网络——第一章 体系"></a>计算机网络——第一章 体系</h1><h3 id="互联网发展阶段"><a href="#互联网发展阶段" class="headerlink" title="互联网发展阶段"></a>互联网发展阶段</h3><p>1、单个网络ARPANET向互联网发展，Internet的前身是美国的ARPANET<br>2、建成了三级结构的互联网，主干网、地区网、校园网<br>3、形成多层次ISP结构的互联网，ISP（互联网服务提供者、互联网服务提供商）</p><hr><h3 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h3><ul><li>ARPANET：单个网络，Internet的前身</li><li>internet：互连网，通用名词，泛指多个计算机网络互连而成的计算机网络</li><li>Internet：互联网、因特网。采用TCP/IP协议族作为通信的规则</li><li>ISP：Internet Service Provider，互联网服务提供者，如中国移动联通电信</li><li>IXP：Internet eXchange Point，互联网交换点，主要作用就是允许两个网络直接相连并交换分组</li><li>WWW：World Wide Web，万维网</li><li>ISOC：互联网协会</li><li>IAB：Internet Architecture Board，互联网体系结构委员会</li><li>IETF：Internet Engineering Task Force，互联网工程部</li><li>IESG：Internet Engineering Steering Group，互联网工程指导小组</li><li>IRTF：Internet Research Task Force，互联网研究部</li><li>IRSG：Internet Research Steering Group，研究指导小组</li><li>CHINANET：中国电信互联网</li><li>UNINET：联通</li><li>CMNET：移动</li><li>CERNET：中国教育和科研计算机网络</li><li>CSRNET：中国科学技术网</li></ul><hr><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><h5 id="一、边缘部分"><a href="#一、边缘部分" class="headerlink" title="一、边缘部分"></a>一、边缘部分</h5><ul><li>C/S：客户-服务器方式</li><li>P2P：对等方式，peer-to-peer</li></ul><h5 id="二、核心部分"><a href="#二、核心部分" class="headerlink" title="二、核心部分"></a>二、核心部分</h5><p><strong>路由器（router）</strong>：专用计算机，实现分组交换，任务是转发收到的分组</p><ul><li><p>电路交换：</p><blockquote><p>1、采用面向连接，独占电路方式。<br>2、语音通信特点：差错率要求不高，实时性要求高。<br>3、通话的全部时间内，两个用户始终占用端到端的通信资源。<br>4、传送计算机数据时效率很低<br>5、整个报文的比特流连续发送（比特流的形式）<br>6、传输单元：比特流，比特流直达终点</p><p>建立连接（占用通信资源）——通话（一直占用）——释放连接（归还资源）</p><p>空分交换：模拟信号，物理的实际电路，独占线路<br>同步时分交换：数字信号，帧结构方式，分时共享，独占时隙</p></blockquote></li><li><p>分组交换：</p><blockquote><p>1、采用存储转发技术<br>2、面向非连接<br>3、数据通信特点：差错要求极高，误码率达到10^-9，差错控制，实时性要求不高，突发性高<br>4、单个分组（报文再分组后）传送到相邻节点，存储在转发<br>5、如ATM、IP、MPLS<br>高效、灵活、迅速、可靠</p></blockquote></li></ul><p>主机为用户进行信息处理，路由器转发分组（分组交换）。</p><ul><li><p>报文交换：</p><blockquote><p>1、采用存储转发原理<br>2、整个报文先传送到相邻节点，全部存储后转发<br>3、报文为基本单位</p></blockquote></li><li><p>虚电路</p><blockquote><p>（1）建立逻辑上的连接，数据通过该逻辑路径<br>（2）通信完成后释放连接<br>（3）类似电路交换的通信过程，但不是物理电路<br>（4）典型应用：ATM、MPLS</p><p><strong>分类：</strong><br>1、SVC：交换虚电路，在每次呼叫时用户通过发送呼叫请求分组来临时建立虚电路的方式。<br>2、PVC：永久虚电路，用户事先已经要求网络运营商专门建立了固定的虚电路，就不需要在呼叫时再临时建立虚电路，而可以直接进入数据传送阶段，这种方式是永久虚电路，适用于业务量较大的集团用户</p></blockquote></li><li><p>ATM信元</p><blockquote><p>1、固定长度（5字节信元头+48净负荷=53字节信元）<br>2、信元长度小：可以减小组装、拆卸信元的等待时延和时延抖动，远超过采用总线结构的交换机处理速度，使得各个信元中可以被并行处理，从而满足实时业务。<br>3、取消逐段差错控制，只需端到端的差错控制，HEC仅负责信头的差错控制。<br>4、 用多组有序VPI/VCI标识一个虚连接，省去源地址、目的地址和包序号，信元到达顺序由ATM网络保证，这也更有利于硬件电路进行高速处理。<br><img src="https://upload-images.jianshu.io/upload_images/4061843-eb97ce2271b5a5cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>VP与VC：</strong><br>1、一个物理传输信道TP被分成若干个虚通路VP，一个VP又包含若干个虚通道VC。<br>2、VC是两个相邻节点之间的逻辑连接，VP是一束VC的集合。<br><img src="https://upload-images.jianshu.io/upload_images/4061843-8fe44d1db67cba75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>VP交换和VC交换：</strong><br>1、VP交换时，VCI不变<br> 2、VC交换时，修改VPI/VCI值并重新计算HEC</p></blockquote></li></ul><hr><h2 id="通信网的组成"><a href="#通信网的组成" class="headerlink" title="通信网的组成"></a>通信网的组成</h2><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li><p>硬件<img src="https://upload-images.jianshu.io/upload_images/4061843-725bbbacf87136a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/4061843-e549a7769f3c476b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>软件<img src="https://upload-images.jianshu.io/upload_images/4061843-20b71f377896d113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><h4 id="通信网的架构"><a href="#通信网的架构" class="headerlink" title="通信网的架构"></a>通信网的架构</h4><ul><li><p>垂直架构<br>OSI七层简化，从功能、垂直结构上，分为信息应用层、业务网层、接入与传送层<img src="https://upload-images.jianshu.io/upload_images/4061843-56cc9a53a7f67bf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>水平架构<br>基于用户接入网络实际的物理连接划分，分为用户驻地网（CPN）、接入网（AN）、核心网（CN）<img src="https://upload-images.jianshu.io/upload_images/4061843-2d37ec50ccfd22ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><img src="https://upload-images.jianshu.io/upload_images/4061843-a47499d0bf4c168a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li></ul><h4 id="电话网络与因特网的结构"><a href="#电话网络与因特网的结构" class="headerlink" title="电话网络与因特网的结构"></a>电话网络与因特网的结构</h4><p><img src="https://upload-images.jianshu.io/upload_images/4061843-4197a2c9bd6b5869.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><hr><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><ul><li>按作用范围<br>1、广域网WAN：Wide Area Network，远程网，核心部分，<br>2、城域网MAN：Metropolitan Area Network，范围一个城市左右<br>3、局域网LAN：Local Area Network，一般用微型计算机或工作站通过高速通信线路相连（10Mbit/s以上），如校园网、企业网<br>4、个人区域网PAN：Personal Area Network，无线个人局域网WPAN，10m左右</li></ul><p>注：若中央处理机之间的距离非常近（1m内）一般称之为多处理机系统</p><ul><li>按使用者<br>1、公用网：公众网<br>2、专用网：某个部门<br>3、用来把用户解入到互联网的网络：接入网AN（Access Network），本地接入网或居民接入网（通过ISP）</li></ul><hr><h2 id="网络的性能"><a href="#网络的性能" class="headerlink" title="网络的性能"></a>网络的性能</h2><h5 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h5><ul><li>速率：数据的传送速率，数据率或比特率（bit/s），一般说的额定速率或标称速率</li><li>带宽：频域和时域两种<br>（1）某个信号具有的频带带宽，信号的带宽值信号所包含的各种不同频率成分所占据有的频率范围，单位赫<br>（2）用于表示某通道传送数据的能力，单位时间内某信道所能通过的最高数据率，单位bit/s</li><li>吞吐量：单位时间内通过某个网络的实际的数据量</li><li>时延：数据从网络的一端到另一端所需要的时间，也称延迟或迟延<br>（1）发送时延：主机或路由器发送数据帧所需要的时间，从第一个到结束的最后一个，也叫传输时延，=数据帧长度/发送速率<br>（2）传播时延：电磁波在信道中传播一定的距离需要花费的时间，=信道长度/电磁波在信道上的速率<br>（3）处理时延：主机或路由器在收到分组时要花费一定的时间进行处理<br>（4）排队时延：分组经过网络传输时，经过路由器需要排队等待路由器的处理，这个往往取决于网络当时的通信量</li><li>时延带宽积：传播时延*带宽，又称以比特为单位的链路长度</li><li>往返时间RTT：</li><li>利用率：信道利用率（某信道有百分之几的时间是被利用的，数据通过）和网络利用率（全网络的信道利用率的加权平均值）</li></ul><h5 id="非性能指标"><a href="#非性能指标" class="headerlink" title="非性能指标"></a>非性能指标</h5><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性和可升级性</li><li>易于管理和维护</li></ul><hr><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><ul><li><p>因特网发展的三个阶段：<br>1、第一阶段是从单个网络<strong>ARPANET</strong>向互联网发展的过程。 1983 年 TCP/IP 协议成为 ARPANET 上的标准协议，故1983 年作为因特网的诞生时间。<br>2、第二阶段的特点是建成了三级结构的因特网，分为主干网、地区网和校园网（或企业网）。<br>3、第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网，出现了因特网服务提供者 ISP (Internet Service Provider)。</p></li><li><p>标准化工作<img src="https://upload-images.jianshu.io/upload_images/4061843-ebc26dbd3ca233b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li></ul><h5 id="OSI的七层协议"><a href="#OSI的七层协议" class="headerlink" title="OSI的七层协议"></a>OSI的七层协议</h5><p>7、应用层<br>6、表示层<br>5、会话层<br>4、运输层<br>3、网络层<br>2、数据链路层<br>1、物理层</p><h5 id="TCP-IP四层协议体系结构"><a href="#TCP-IP四层协议体系结构" class="headerlink" title="TCP/IP四层协议体系结构"></a>TCP/IP四层协议体系结构</h5><p>4、应用层（TELNET、FTP、SMTP）<br>3、运输层（TCP、UDP）<br>2、网际层（IP）<br>1、网络接口层</p><h4 id="五层协议体系"><a href="#五层协议体系" class="headerlink" title="五层协议体系"></a>五层协议体系</h4><p>5、应用层：<br> 通过应用进程间的交互来完成特定网络应用，协议定义的是应用进程间通信和交互的规则，数据单元是报文，如域名系统DNS、万维网HTTP、电子邮件SMTP</p><p>4、运输层：<br>负责向两台主机中进程之间的通信提供通用的数据传输服务<br>（1）传输控制协议TCP：提供面向连接的、可靠的数据传输服务，数据单位是报文段<br>（2）用户数据报协议UDP：提供无连接的、尽最大努力的数据传输服务（不保证数据的可靠性），数据单位是用户数据报</p><p>3、网络层：<br>负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组（IP数据报）或包进行传送</p><p>2、数据链路层：<br>简称链路层，将网络层传下来的IP数据报组装成帧，在两个相邻结点间的链路上传送帧，每一帧包括数据和必要的控制信息，加首部和尾部</p><p>1、物理层：<br>数据单位是比特，传送比特流</p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-d864263c50a352d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名.jpg"><br><img src="https://upload-images.jianshu.io/upload_images/4061843-d642c87a082fc385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h5 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h5><ul><li><p>协议数据单元PDU：对等层次之间传送的数据单元成为该层的PDU </p></li><li><p>对等层：相同的协议层次</p></li><li><p>协议栈：协议体系层次中，几个层次在一起像一个栈</p></li><li><p>实体：表示任何可发送或接收信息的硬件或软件进程</p></li><li><p>协议：控制两个对等实体或多个实体进行通信的规则的集合</p><blockquote><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，要实现本层协议，需要下一层提供服务（下向上一层提供服务）</p></blockquote></li><li><p>SAP：服务访问结点，在同一系统中相邻两层的实体进行交互（交换信息）的地方</p></li><li><p>SDU：服务数据单元，层与层之间交换的数据的单位</p></li><li><p>通信子网：网络中实现网络通信功能的设备及其软件的集合，通信设备、网络通信协议、通信控制软件等属于通信子网，是网络的内层，负责信息的传输。主要为用户提供数据的传输，转接，加工，变换等。包括各种通信设备（集线器交换机、路由器等）和通信线路。</p></li><li><p>资源子网：资源子网主要由网络的服务器、工作站、共享的打印机和其他设备及相关软件所组成。 资源子网的主体为网络资源设备，包括:用户计算机(也称工作站、网络存储系统、网络打印机、独立运行的网络数据设备、网络终端、服务器、网络上运行的各种软件资源、数据资源等</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习(六)——进程操作</title>
      <link href="/2018/05/14/Linux%E5%AD%A6%E4%B9%A0(%E5%85%AD)%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/14/Linux%E5%AD%A6%E4%B9%A0(%E5%85%AD)%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Linux学习-六-——进程操作"><a href="#Linux学习-六-——进程操作" class="headerlink" title="Linux学习(六)——进程操作"></a>Linux学习(六)——进程操作</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><blockquote><p>程序：程序是静态的，它是一些保存在磁盘上的指令的有序集合，是可执行文件，但没有任何执行的概念<br>进程：一个程序的一次执行的过程，是一个动态的概念，是程序执行时的一个实例</p></blockquote><hr><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>（是程序执行的过程）</p><ul><li>执行态：程序在运行，占用CPU</li><li>就绪态：具备执行条件，等待分配CPU的时间片</li><li>等待态：等待除CPU外的其他资源或条件（不能运行）</li></ul><hr><h2 id="Linux中进程结构"><a href="#Linux中进程结构" class="headerlink" title="Linux中进程结构"></a>Linux中进程结构</h2><ul><li>代码段</li><li>数据段</li><li>堆栈段</li></ul><hr><h2 id="进程控制块（PCB，又称进程描述符）"><a href="#进程控制块（PCB，又称进程描述符）" class="headerlink" title="进程控制块（PCB，又称进程描述符）"></a>进程控制块（PCB，又称进程描述符）</h2><p>（进程是Linux系统的调度和管理资源的基本单位，通过进程控制块来描述的）</p><blockquote><p>控制块：包含进程的描述信息、控制信息、资源信息</p><p>进程的静态描述，每一项是一个task_struct结构，系统进程数受task_struct数组大小限制，一般为512，新线程先分配task_struct结构并加入task数组</p></blockquote><h4 id="task-struct："><a href="#task-struct：" class="headerlink" title="task_struct："></a>task_struct：</h4><p>1.<em>进程状态（State）</em>：除三态外还有stopped（挂起状态，被暂停）、zombie（僵尸态，进程结束但未消亡）</p><p>2.<em>进程调度信息和策略</em></p><ul><li><p>用户模式</p></li><li><p>系统模式（内核模式）<br>进程通过系统调用或中断在两种模式间切换</p><p><strong>时间片轮调度</strong>：将所有的就绪任务按照First Come First Served原则排成队列，每次调度时将处理器分配给队首任务，让其执行一小段时间，一个时间片内任务未完成暂定送往队尾，将时间片给下一个队首</p></li></ul><p>3.<em>进程标识号（Identifiers）</em>：系统分配一个唯一的数值给进程</p><ul><li>进程号（PID）和父进程号（PPID）</li><li>PID唯一的标识一个进程</li><li>PID和PPID都是非零证书</li><li>系统调用getpid和getppid</li></ul><p>4.<em>进程通信有关的信息（IPC）</em>：</p><p>5.<em>时间和定时器信息（Times and Timers）</em></p><p>6.<em>文件系统信息（Files System）</em></p><h2 id="一些进程"><a href="#一些进程" class="headerlink" title="一些进程"></a>一些进程</h2><p>1、孤儿进程：如果父进程先退出，子进程还没退出，那么子进程将被托孤给init进程（所有进程的父进程，PID为1）<br>2、僵尸进程：进程终止，但是父进程还未获取其状态。会消耗一定的资源<br><img src="https://upload-images.jianshu.io/upload_images/4061843-12ebfac4c99f5d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>3、守护进程：在后台运行，不和任何终端关联，通常在系统启动时运行，命名以d结尾</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul><li>启动进程：手工启动和调度启动</li><li>相关命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps:查看系统中的进程</span><br><span class="line">jobs:显示当前shell下已启动的任务</span><br><span class="line">kill:向进程发送信号</span><br><span class="line">    kill -s 9 pid</span><br><span class="line">    kill %num</span><br><span class="line">fg:将后台进程转为前台进程</span><br><span class="line">    fg %num</span><br><span class="line">bg:将暂停的进程放到后台运行</span><br><span class="line">    bg %num</span><br><span class="line">ctrl+z:将前台运行程序，转为后台暂停</span><br></pre></td></tr></table></figure></li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ul><li>fork()/vfork<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun:pid_t fork(void);</span><br></pre></td></tr></table></figure></li></ul><p>返回：单调用双返回，子进程中返回为0，父进程中返回子进程ID，出错-1，可以判定子进程父进程<br>得到的子进程是父进程的一个复制品，fork后谁先执行不确定</p><p>vfork创建与fork基本相同，但是vfork并不完全复制父进程的数据段，而是和父进程共享数据段，vfork对于父子进程的执行次序有所限制，保证子线程先运行，直到exec或exit后父进程才可能被调用</p><ul><li>exec<br>提供在进程中启动另一个进程的方法，某进程一旦调用，正在执行的程序将会替换成新订单，只有进程号会被保留，进程还是原来的进程但是执行的程序被替换了，调用exec成功时无返回值，其后面的代码也不会执行。fork和exec启动一个新的指定的进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun: int execl(const char *pathname, const char *arg0, ..., NULL);</span><br><span class="line"></span><br><span class="line">fun: int execlp(const char *filename, const char *arg0, ...,NULL);</span><br><span class="line"></span><br><span class="line">fun: int execle(const char *pathname, const char *arg0, ...,NULL);</span><br><span class="line"></span><br><span class="line">fun: int execv(const char *pathname, const char *arg0, ..., NULL);</span><br><span class="line"></span><br><span class="line">fun: int execvp(const char *filename, const char *arg0, ..., NULL);</span><br><span class="line"></span><br><span class="line">fun: int execve(const char *path, const char *argv[], const char *envp[]);</span><br><span class="line">path：被执行应用程序的完整路径</span><br><span class="line">argv：传给被执行应用程序的命令行参数</span><br><span class="line">envp：传给被执行应用程序的环境变量</span><br><span class="line">argv[0]必须是程序的可执行文件的名字</span><br></pre></td></tr></table></figure></li></ul><p>execve才是真正的系统调用</p><h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><ul><li>exit/_exit<br>8种方式终止进程：<br>1、main返回<br>2、exit<br>3、_exit或_Exit<br>4、最后一个线程从启动例程返回<br>5、最后一个线程调用pthread_exit<br>6、abort异常终止<br>7、接到信号终止，异常终止<br>8、最后一个线程对取消请求做出响应<br><img src="https://upload-images.jianshu.io/upload_images/4061843-4e01f1d47dba7427.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status)</span><br><span class="line"></span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">void _exit(int status)</span><br><span class="line"></span><br><span class="line">status:0表示正常退出</span><br></pre></td></tr></table></figure><p>exit在_exit（直接使进程停止运行）上进行包装，生成终止状态字，可用wait或waitpid获取<br>调用exit后变为僵尸状态，保留PCB信息供wait收集</p><h4 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h4><p>wait/waitpid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">fun:pid_t wait(int *status)</span><br><span class="line">fun: pid_t wait(pid_t pid, int *status, int options);</span><br></pre></td></tr></table></figure><p>立即阻塞自己，如果找到僵尸线程（此处是它的子进程），会销毁后返回。没有找到就会一直阻塞<br>（1）如果所有子进程还在运行，则阻塞<br>（2）有子进程结束，得到子进程的终止状态和进程号<br>（3）没有子进程，返回-1<br><img src="https://upload-images.jianshu.io/upload_images/4061843-f4457494c2391c60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180521083757.png"></p><h4 id="程序中使用"><a href="#程序中使用" class="headerlink" title="程序中使用"></a>程序中使用</h4><p>system函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int system(const char *cmdstring);</span><br></pre></td></tr></table></figure><p>利用fork、exec、waitpid实现。若cdmstring为空指针，system成功时返回非零指针，失败时返回0，可用于测试system是否有效。cdmstring不为空，fork或waitpid出现错误返回-1。exec错误返回，表示shell无法执行这个命令行，返回与exit(127)的返回相同。都调用成功时返回shell的结束态</p><h4 id="进程标识号管理"><a href="#进程标识号管理" class="headerlink" title="进程标识号管理"></a>进程标识号管理</h4><p><strong>进程用户的标识管理</strong></p><ul><li>用户标识：real user id、effective user id</li><li>组标识号：real group id、 effective group id<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: signed short getuid(void);   //进程的真实用户id</span><br><span class="line">fun: signed short geteuid(void);  //取得目前进程有效的用户识别id</span><br><span class="line">fun: signed short getgid(void):  //组识别符</span><br><span class="line">fun: signed shor getegid(void);  //有效的组识别符</span><br><span class="line">fun: int setuid(uid_t uid);  //设置实际进程的实际用户、有效用户标识号</span><br><span class="line">fun: int setgid(gid_t gid);  //设置进程的实际组、有效组标识号</span><br></pre></td></tr></table></figure></li></ul><p>只有root用户才更改实际用户id</p><p><strong>进程标识号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: pid_t getpid(void);  //获取当前进程的id</span><br><span class="line">fun: pid_t getpgrp(void);  //获取当前进程所属的组识别码</span><br><span class="line">fun: pid_t getppid(void);  //取得目标进程的父进程识别码</span><br><span class="line">fun: int setpgrp(void);  //将当前进程的组识别码设为当前进程的进程识别码，可脱离控制终端</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab学习笔记</title>
      <link href="/2018/05/03/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/03/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/4061843-c9d46e361e15698b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-b1234e6c0a43a6ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-d1034b68e26c363b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-311af9ab7a2a21ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-8c63ded2b064274a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-fe055d68dcfcb75a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-1aea862eda95c587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-0c8b12f42f69f706.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-f0e46031a7d65b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-ad23d07bf52fe72c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-967bbc9690e674da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-15cb749aa9b0962e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-fd4e8bf345a4eac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-d0fc98e18b8551d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-0ea94260323878be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-6ba798884e4b7919.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-9130f9721b448643.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-55014258836bd5a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-797e870339b0906a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-c116f7d528864c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-bba7ad421be4bdf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-662b6b34778ec0c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-ae5286b6b9e6a998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-d419732d12b3aff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-80d2edaf680910a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-ebb57c30982fb592.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-b4ce041958de6839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-9cebb446d8d6662f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-03d64925be04ce13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-686149afecc29a6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习(四)——文件IO操作</title>
      <link href="/2018/04/23/Linux%E5%AD%A6%E4%B9%A0(%E5%9B%9B)%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/04/23/Linux%E5%AD%A6%E4%B9%A0(%E5%9B%9B)%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Linux学习-四-——文件IO操作"><a href="#Linux学习-四-——文件IO操作" class="headerlink" title="Linux学习(四)——文件IO操作"></a>Linux学习(四)——文件IO操作</h1><blockquote><p>标准I/O 与系统I/O的区别：</p><p>标准I/O建立在系统I/O上，有缓冲，比较耗时，可以实现更多的功能，对内核进行较复杂的操作，使用更人性；</p><p>系统I/O是操作系统为用户态运行的进程和硬件设备(如CPU、磁盘、打印机等)进行交互提供的一组接口，即就是设置在应用程序和硬件设备之间的一个接口层，可以说是操作系统留给用户程序的一个接口。调用系统函数，没有缓冲，不耗时，C 和汇编语言实现，执行效率高</p><p>系统调用是为了更直接的使用操作系统接口，而库函数则是为了人们编程的方便。</p></blockquote><blockquote><p>文件操作的一般过程：<br>打开-&gt;读/写-[定位]-关闭</p></blockquote><hr><ul><li><p>open函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int open(const char* pathname, int flags, .../*mode*/);</span><br><span class="line"></span><br><span class="line">O_RDONLY：只读形式</span><br><span class="line">O_WRONLY：只写形式</span><br><span class="line">O_RDWR：读写形式</span><br><span class="line">O_APPEND：追加模式</span><br><span class="line">O_TRUNC：若成功打开，则长度截为0</span><br><span class="line">O_ CREAT：文件不存在则创建</span><br></pre></td></tr></table></figure></li><li><p>close</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int close(int fd);</span><br></pre></td></tr></table></figure></li><li><p>read</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">size_t: unsigned int</span><br></pre></td></tr></table></figure></li><li><p>write</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unsitd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">*buf：输出缓冲区地址</span><br><span class="line">将buf缓冲区count字节写入文件</span><br></pre></td></tr></table></figure></li><li><p>creat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/type.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int creat(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure></li><li><p>lseek：自定义读取文件，指定文件偏移量的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: off_t lseek(int fds, off_t offset, int whence);</span><br><span class="line"></span><br><span class="line">fds:文件描述符</span><br><span class="line">offset：偏移量</span><br><span class="line">whence：当前位置的基点</span><br><span class="line">1.SEEK_SET：文件的开头</span><br><span class="line">2.SEEK_CUR：文件指针的位置</span><br><span class="line">3.SEEK_END：文件的末尾</span><br><span class="line">计算文件长度：Iseek(fd, 0, SEEK_END)</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="文件高级操作"><a href="#文件高级操作" class="headerlink" title="文件高级操作"></a>文件高级操作</h2><ul><li><p>文件模式的高7位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S_IFMT        0170000     文件类型的位遮罩  </span><br><span class="line">S_IFSOCK    0140000     socket  </span><br><span class="line">S_IFLNK       0120000     符号链接(symbolic link)  </span><br><span class="line">S_IFREG       0100000     一般文件  </span><br><span class="line">S_IFBLK       0060000     区块装置(block device)  </span><br><span class="line">S_IFDIR       0040000     目录  </span><br><span class="line">S_IFCHR      0020000     字符装置(character device)  </span><br><span class="line">S_IFIFO        0010000     先进先出(fifo)  </span><br><span class="line"></span><br><span class="line">S_ISUID       0004000     文件的(set user-id on execution)位  </span><br><span class="line">S_ISGID       0002000     文件的(set group-id on execution)位  </span><br><span class="line">S_ISVTX      0001000     文件的sticky位  </span><br><span class="line"></span><br><span class="line">用st_mode&amp;S_IFMT检测文件类型</span><br></pre></td></tr></table></figure></li><li><p>umask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun: mode_t umask(mode_t cmask)</span><br><span class="line"></span><br><span class="line">cmask==1: 文件模式的相应位的权限被禁止操作，新的屏蔽码</span><br><span class="line">函数返回旧屏蔽码</span><br></pre></td></tr></table></figure></li><li><p>chmod fchmod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun：int chmod(const *char filename, mode_t mode)</span><br><span class="line">fun：int fchmod(int fd, mode_t mode)</span><br><span class="line"></span><br><span class="line">fd: 文件描述符</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-938741ebbaaed9b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180502151447.png"></p><ul><li>chown fchown：修改权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun: int chown(const *char path, uid_t owner, gid_t group)</span><br><span class="line">fun: int fchown(int fd, uid_t owner, gid_t group)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-1859b6c3d6fe3098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180502151808.png"></p><ul><li><p>rename：重命名文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int rename(char* oldname, char* newname)</span><br><span class="line"></span><br><span class="line">可用于移动或复制文件</span><br></pre></td></tr></table></figure></li><li><p>truncate ftruncate：对文件的大小进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int truncate(const *char path, size_t length)</span><br><span class="line">fun: int ftruncate(int fd, size_t length)</span><br></pre></td></tr></table></figure></li><li><p>access(const *char pathname, int mode)<br><img src="https://upload-images.jianshu.io/upload_images/4061843-db9e930e79fd9d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180502152313.png"></p></li><li><p>utime  utimes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;utime.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int utime(const char* filename, struct utimebuf* buf)</span><br><span class="line">fun: int utimes(const char* filename, struct timeval tvp[2])</span><br><span class="line"></span><br><span class="line">改变一个文件的访问时间和修改时间,uimes具有更高的时间解析度</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-64d6dafae279f367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180502152750.png"></p><ul><li><p>stat fstat lstat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun: int stat(const char* pathname, struct stat *buf)</span><br><span class="line">fun: int fstat(int fd, struct stat *buf)</span><br><span class="line">fun: int lstat(const char* pathname,struct stat *buf)</span><br><span class="line"></span><br><span class="line">函数返回指定文件的信息</span><br></pre></td></tr></table></figure></li><li><p>duo dup2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int dup(int oldfd)</span><br><span class="line">fun: int dup2(int odlfd, int newfd)</span><br></pre></td></tr></table></figure></li><li><p>fcntl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int fcntl(int fd, int cmd)</span><br><span class="line">fun: int fcntl(int fd, int cmd, long arg)</span><br><span class="line">fun: int fcntl(int fd, int cmd, struct flock * lock)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-7409b6a707da7f83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180502153507.png"><br><img src="https://upload-images.jianshu.io/upload_images/4061843-c97d61321990bf8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180502153601.png"></p><ul><li><p>getwd getcwd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun: char * getwd(char *pathbuf)</span><br><span class="line">fun: char * getcwd(char *pathbuf, size_t size)</span><br><span class="line"></span><br><span class="line">绝对路径</span><br></pre></td></tr></table></figure></li><li><p>chdir fchdir</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun: int chdir(const char *path)</span><br><span class="line">fun: int fchdir(int fd)</span><br></pre></td></tr></table></figure></li><li><p>mkdir rmdir</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun: int mkdir(const char *pathname, mode_t mode)</span><br><span class="line"></span><br><span class="line">创建目录、删除目录</span><br></pre></td></tr></table></figure></li><li><p>opendir</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">fun: DIR * opendir(const char * name)</span><br></pre></td></tr></table></figure></li><li><p>closedir</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun: int closedir(DIR *dir)</span><br></pre></td></tr></table></figure></li><li><p>readdir</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun: struct dirent * readdir*DIR *dp)</span><br></pre></td></tr></table></figure></li><li><p>mknod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun: lint mknod(const char *path, mode_t mode, dev_t dev)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-82e727ea72bae56d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180502154308.png"></p><ul><li>mount umount<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/mount.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int mount(const char *source, const char *target, const char *dilesystemtype, unsigned long mountflags, const void *data)</span><br><span class="line">fun: int umount(const char *target)</span><br><span class="line">fun: int umount2(const char *target, int flags)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-0edcfc9e68252e4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180502154609.png"></p><ul><li><p>link</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int link(const char *oldpath, const char *newpath)</span><br></pre></td></tr></table></figure></li><li><p>symlink readlink</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">fun: int symlink(const char *oldpath, const char *newpath)</span><br><span class="line">fun: int readlink(const char *path, char *buf, size_t bufsiz)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4061843-0186cb1de76e2bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180502155706.png"></p><h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>又称流，文件I/O流</p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-598a5af0a7b32f2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075035.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-4a37cf8e531d4a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075052.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-7def174eda6539ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075143.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-c61afc39b82badab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075238.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-0af092b244d092db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075250.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-8089a950d70028a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075312.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-d8ed939c44c0729a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075347.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-7745cf7f3512dcaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075359.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-e5d969b105f5e2dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075411.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-feeebd21a776a6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075423.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-bcc4524d8b313370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075503.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-198130cf31f8a9a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075520.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-e4d932217168d571.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075543.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-9e9d65c1e310ab8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514075555.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习(五)——cron服务</title>
      <link href="/2018/04/23/Linux%E5%AD%A6%E4%B9%A0(%E4%BA%94)%E2%80%94%E2%80%94cron%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/04/23/Linux%E5%AD%A6%E4%B9%A0(%E4%BA%94)%E2%80%94%E2%80%94cron%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Linux学习-五-——cron服务"><a href="#Linux学习-五-——cron服务" class="headerlink" title="Linux学习(五)——cron服务"></a>Linux学习(五)——cron服务</h1><p><strong>cron：</strong>守护进程</p><blockquote><p>sudo service cron status：查看cron状态<br>sudo /etc/init.d/cron start：开启cron<br>sudo /etc/init.d/cron stop：关闭cron<br>sudo /etc/init.d/cron restart：重启cron</p></blockquote><hr><p><strong>crontab用法：</strong></p><blockquote><p>crontab –e : 修改 crontab 文件,如果文件不存在会自动创建。 (这样可以编辑模式打开个人的 crontab 配置文件,然后加入一下这行:0 0 * * * /home/linrui/XXXXXXXX.sh这将会在每天凌晨运行 指定的.sh 文件)<br>crontab –l : 显示 crontab 文件。<br>crontab -r : 删除 crontab 文件。<br>crontab -ir : 删除 crontab 文件前提醒用户。</p></blockquote><p>在 crontab 文件中写入需要执行的命令和时间,该文件中每行都包括六个域,其中前五个域是指定<br>命令被执行的时间,最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minute hour day-of-month month-of-year day-of-week commands</span><br><span class="line">合法值为:00-59 00-23 01-31 01-12 0-6 (0 is sunday)</span><br></pre></td></tr></table></figure><blockquote><p>除了数字还有几个特殊的符号:”*”、”/“和”-“、”,”<br> *代表所有的取值范围内的数字<br> “/“代表每的意思,”/5”表示每 5 个单位<br> “-“代表从某个数字到某个数字<br> “,”分开几个离散的数字<br>注:commands 注意以下几点<br> 要是存在文件,要写绝对路径<br> 即使是打印也不会显示在显示屏,在后台运行,最好重定向日志</p></blockquote><p>以下是 crontab 文件的格式:</p><blockquote><p><code>{minute} {hour} {day-of-month} {month} {day-of-week} {full-path-to-shell-script}</code><br>o minute: 区间为 0 – 59<br>o hour: 区间为 0 – 23<br>o day-of-month: 区间为 0 – 31<br>o month: 区间为 1 – 12. 1 是 1 月. 12 是 12 月.<br>o Day-of-week: 区间为 0 – 7. 周日可以是 0 或 7.</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/4061843-60f756ac69be4c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180527102400.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-edd332b37a6730e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180527102733.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习(一)——常用命令</title>
      <link href="/2018/04/18/Linux%E5%AD%A6%E4%B9%A0(%E4%B8%80)%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/04/18/Linux%E5%AD%A6%E4%B9%A0(%E4%B8%80)%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Linux学习-一-——常用命令"><a href="#Linux学习-一-——常用命令" class="headerlink" title="Linux学习(一)——常用命令"></a>Linux学习(一)——常用命令</h1><p>常用命令：</p><blockquote><p>su：切换到超级用户<br>su -user：切换到user</p></blockquote><blockquote><p>mysql -uroot -p：连接本地数据库</p></blockquote><blockquote><p>chmod：权限管理<br>a-x  go+w<br>a：all   g：group  o：other  u：user</p></blockquote><blockquote><p>who am i：用户身份<br>who：查看登录用户<br>useradd userName：新建用户<br>passwd userName：添加密码<br>userdel userName：删除用户<br>groupadd groupName：新建组<br>groupdel groupName：删除组</p></blockquote><blockquote><p>netstat -a：查看网络联机状态<br>ps -aux：查看后台执行的程序<br>ps -e | grep ssh：查看运行的进程</p></blockquote><blockquote><p>sync：将数据同步到硬盘中<br>shutdown -h n：n分钟后关机<br>shutdown -r n：n分钟后重启<br>reboot：重庆<br>halt：关闭系统</p></blockquote><blockquote><p>重定向：&gt; 直接覆盖文件， &gt;&gt; 在文件末尾追加</p></blockquote><blockquote><p>安装apt-get install</p></blockquote><blockquote><p>pwd：显示当前目录</p></blockquote><blockquote><p>ls：显示当前目录内容</p><p>-a：显示所有文件和目录，不含隐藏文件<br>-l：详细信息<br>-r：文件以相反次序显示<br>-t：按时间顺序<br>-A：不列出.开头，其余同-a<br>-F：列出文件名称后加一符号<br>-R：将目录下的文件也列出</p></blockquote><blockquote><p>mkdir：创建目录</p><p>-p：确定目录名称存在，不存在就新建一个</p></blockquote><blockquote><p>rm：删除目录（所有使用者）</p><p>-i：删除前逐一确<br>-f：不确认，直接删除<br>-r：将目录及目录下的文件逐一删除</p><p>rmdir：（当前目录有权限的所有者）</p><p>-p：子目录删除后为空也删除</p></blockquote><blockquote><p>cat：查看文件</p><p>-n：对行数编号<br>-b：空白行不编号<br>-s：连续两行以上的空白行为一行输出<br>-v：</p></blockquote><blockquote><p>more：查看文件</p><p>-num：一次显示的行数<br>-d：提示使用者<br>-l：取消遇见字符元^L会暂停的功能<br>-f：计算实际行数<br>-p：不以卷动的方式显示每一页，而是先清除荧幕后再显示内容<br>-c：跟 -p 相似，不同的是先显示内容再清除其他旧资料<br>-s：当遇到有连续两行以上的空白行，就代换为一行的空白行<br>-u：不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）<br>+/：在每个文件显示前搜寻该字串（pattern），然后从该字串之后开始显示<br>+num：从第 num 行开始显示<br>fileNames：欲显示内容的文件，可为复数个数 </p></blockquote><blockquote><p>less：查看文件（几乎和more一样）<br>允许用户向前向后翻阅文件</p></blockquote><blockquote><p>head：查看文件的头几行</p><p>-n：行数</p></blockquote><blockquote><p>tail：查看尾部</p><p>-n：行数<br>-f：动态显示，常用语跟踪消息文件</p></blockquote><blockquote><p>touch：新建空文件</p><p>-a：改变文件的读取时间记录<br>-m：改变文件的修改时间记录<br>-c：目的文件不存在不会新建文件<br>-f：不使用<br>-r：使用参考文件的时间记录<br>-d：设定时间与日期<br>-t：设定文件的时间记录<br>-no-create：不会建立新文件<br>–version：版本信息</p></blockquote><blockquote><p>cp：拷贝</p><p>-a：尽可能照原状进行复制<br>-r：将目录下的文件依序拷贝<br>-f：若相同文件存在，则先删除再复制</p></blockquote><blockquote><p>mv：移动文件</p><p>-i：若有同名文件，则先询问是否覆盖</p></blockquote><blockquote><p>ln：文件链接</p><p>-f：链结时先将与连结相同文件名的文件删除<br>-d：允许系统管理着硬链结自己的目录<br>-i：在删除与连结相同文件名的文件时先进行询问<br>-n：在进行软连结时，将dist视为一般文件<br>-s：进行软链结<br>-v：在连结之前显示其文件名<br>-b：将在链结时会被覆写或删除的文件进行备份<br>-S SUFFIX：将备份的文件都加上SUFFIX的字尾<br>-V MEHOD：指定备份的方式</p></blockquote><blockquote><p>?：通配符，可代替单个字符<br>*：任意字符<br>[charset]：charset集中的任何单个字符</p></blockquote><blockquote><p>whereis：查找文件（在特定的目录中查找符合条件的文件：原始代码、二进制文件、帮组文件）</p><p>-b：只查找二进制文件<br>-B&lt;目录&gt;：只在设置的目录下查找二进制文件<br>-f：不显示文件名前的路径名称<br>-m：只查找说明文件<br>-M&lt;目录&gt;：只在设置的目录下查找说明文件<br>-s：值查找原始代码文件<br>-S&lt;目录&gt;：只在设置的目录下查找原始代码文件<br>-u：查找不包含指定类型的文件</p></blockquote><blockquote><p>which：查找文件（在环境变量$PATH设置的目录查找符合条件的文件）</p><p>-n&lt;文件名长度&gt;：指定文件名长度，必须&gt;=所有文件中最长的文件名<br>-p&lt;文件名长度&gt;：包括了文件的路径<br>-w：指定输出时栏位的宽度<br>-V：显示版本信息</p></blockquote><blockquote><p>find：查找文件</p><p>-mount、-xdev：只检查和指定目录在同一个文件系统下的文件，避免列出其他文件系统的文件<br>-amin n：在过去n分钟内被读取过<br>-anewer file：比文件file更晚被读取过的文件<br>-atime n：在过去n天读取过的文件<br>-cmin n：在过去n分钟内被修改过<br>-cnewer file：比文件file更行的文件<br>-ctime n：在过去 n天修改过的文件<br>-empty：空的文件-gid n or -group name :  gid 是n或是group名称是name<br>-print：find命令将匹配的文件输出到标准输出<br>-ipath p：路径名称符合p的文件，ipath会忽略大小写<br>-name name，-iname name：文件名称符合name的文件，iname会忽略大小写<br>-size n：文件大小是n单位，本代表512为元组的区块，c表示字元数，k表示kilo bytes，w是二个未元组。 -type c：文件类型是c<br>d：目录<br>c：字型装置文件<br>b：区块装置文件<br>p：具名贮列<br>f：一般文件<br>l：符号链接<br>s：socket<br>-pid n：process id是n的文件</p></blockquote><blockquote><p>Locate：查找符合条件的文件（使用者可以很快速的搜寻文件系统内是否有指定的文件）</p><p>-u：建立数据库时，由根目录开始<br>-U<dir>：建立数据库时，可以指定开始的位置<br>-e<dir>：将<dir>排除在外<br>-l<level>：如果<level>是 1，则启动安全模式，安全模式下使用者不会看到权限和文件<br>-f<filetype>：将特定的文件系统排除在外<br>-q：安静模式，不会显示任何错误信息<br>-n：至多显示n个输出<br>-r：使用正规运算式做寻找的条件<br>-o：指定数据库存的名称<br>-d：指定数据库的路径<br>-h：显示辅助讯息<br>-v：显示更多的讯息<br>-V：版本信息</filetype></level></level></dir></dir></dir></p></blockquote><blockquote><p>grep：查找，它能使用正则表达式搜索文本，并把匹配的行打印出来。<br>查询vsftpd软件包是否安装</p><pre><code>#rpm –qa |grep vsftpd</code></pre></blockquote><blockquote><p>tar：压缩命令</p><p>-c或：create   建立新的备份文件。<br>-C&lt;目的目录&gt;或： directory=&lt;目的目录&gt;  切换到指定的目录。<br>-f&lt;备份文件&gt;或： file=&lt;备份文件&gt;   指定备份文件。<br>-k或：keep-old-files   解开备份文件时，不覆盖已有的文件。<br>-l或：one-file-system   复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。<br>-m或：modification-time   还原文件时，不变更文件的更改时间。<br>-t或：list   列出备份文件的内容。<br>-u或：update   仅置换较备份文件内的文件更新的文件。<br>-U或：unlink-first   解开压缩文件还原文件之前，先解除文件的连接。<br>-v或：verbose   显示指令执行过程。<br>-x或–extract或—get：从备份文件中还原文件。<br>-z或–gzip或—ungzip：通过gzip指令处理备份文件。</p></blockquote><blockquote><p>gzip：压缩</p><p>-c 将输出写到标准输出上，并保留原有文件。<br>-d 将压缩文件解压。<br>-l 对每个压缩文件，显示下列字段：<br>压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名字<br>-r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。<br>-t 测试，检查压缩文件是否完整。<br>-v 对每一个压缩和解压的文件，显示文件名和压缩比。<br>-num 用指定的数字 num 调整压缩的速度，-1 或 –fast 表示最快压缩方法（低压缩比）。<br>-9 或–best表示最慢压缩方法（高压缩比）。系统缺省值为 6。</p></blockquote><blockquote><p>gunzip：解压文件</p><p>-a或–ascii：使用ASCII文字模式。<br>-c或–stdout或–to-stdout：把解压后的文件输出到标准输出设备。<br>-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在及该文件是否为符号连接。<br>-h或–help：在线帮助。<br>-l或–list：列出压缩文件的相关信息。<br>-L或–license：显示版本和版权信息。<br>-n或–no-name：解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽略不予处理。<br>-N或–name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。<br>-q或–quiet：不显示警告信息。<br>-r或–recursive：递归处理，将指定目录下的所有文件及子目录一并处理。<br>-S或–suffix：更改压缩字尾字符串。<br>-t或–test：测试压缩文件是否正确无误。<br>-v或–verbose：显示指令执行过程。<br>-V或–version 显示版本信息。</p></blockquote><blockquote><p>–zip：压缩文件</p><p>-A：调整可执行的自动解压缩文件。<br>-b&lt;工作目录&gt;：指定暂时存放文件的目录<br>-c：替每个被压缩的文件加上注释<br>-d：从压缩文件内删除指定的文件。<br>-D：压缩文件内不建立目录名称。<br>-f：此参数的效果和指定”-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中。<br>-F：尝试修复已损坏的压缩文件。<br>-g：将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。<br>-h：在线帮助。<br>-i&lt;范本样式&gt;：只压缩符合条件的文件。<br>-j：只保存文件名称及其内容，而不存放任何目录名称。<br>-J：删除压缩文件前面不必要的数据。<br>-k：使用MS-DOS兼容格式的文件名称。<br>-l：压缩文件时，把LF字符置换成LF+CR字符。<br>-ll：压缩文件时，把LF+CR字符置换成LF字符。<br>-L：显示版权信息。<br>-m   将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。<br>-n&lt;字尾字符串&gt;   不压缩具有特定字尾字符串的文件<br>-o   以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。<br>-q   不显示指令执行过程<br>-r   递归处理，将指定目录下的所有文件和子目录一并处理<br>-S   包含系统和隐藏文件<br>-t&lt;日期时间&gt;   把压缩文件的日期设成指定的日期<br>-T   检查备份文件内的每个文件是否正确无误。<br>-u   更换较新的文件到压缩文件内。<br>-v   显示指令执行过程或显示版本信息。<br>-V   保存VMS操作系统的文件属性。<br>-w   在文件名称里假如版本编号，本参数仅在VMS操作系统下有效。<br>-x&lt;范本样式&gt;   压缩时排除符合条件的文件。<br>-X   不保存额外的文件属性。<br>-y   直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。<br>-z   替压缩文件加上注释<br>-$   保存第一个被压缩文件所在磁盘的卷册名称。</p></blockquote><blockquote><p>unzip：解压zip文件</p><p>-c   将解压缩的结果显示到屏幕上，并对字符做适当的转换。<br>-f   更新现有的文件。<br>-l   显示压缩文件内所包含的文件。<br>-p   与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。<br>-t   检查压缩文件是否正确。<br>-u   与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。<br>-v   执行是时显示详细的信息。<br>-z   仅显示压缩文件的备注文字。<br>-a   对文本文件进行必要的字符转换。<br>-b   不要对文本文件进行字符转换。<br>-C   压缩文件中的文件名称区分大小写。<br>-j   不处理压缩文件中原有的目录路径。<br>-L   将压缩文件中的全部文件名改为小写。<br>-M   将输出结果送到more程序处理。<br>-n   解压缩时不要覆盖原有的文件。<br>-o   不必先询问用户，unzip执行后覆盖原有文件。<br>-P&lt;密码&gt;   使用zip的密码选项。<br>-q   执行时不显示任何信息。<br>-s   将文件名中的空白字符转换为底线字符。<br>-V   保留VMS的文件版本信息。<br>-X   解压缩时同时回存文件原来的UID/GID。<br>[.zip文件]   指定.zip压缩文件。<br>[文件]   指定要处理.zip压缩文件中的哪些文件。<br>-d&lt;目录&gt;  指定文件解压缩后所要存储的目录。<br>-x&lt;文件&gt;  指定不要处理.zip压缩文件中的哪些文件。<br>-Z   unzip -Z等于执行zipinfo指令。 </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习(三)——GCC编程、GDB调试</title>
      <link href="/2018/04/16/Linux%E5%AD%A6%E4%B9%A0(%E4%B8%89)%E2%80%94%E2%80%94GCC%E3%80%81GDB%E8%B0%83%E8%AF%95/"/>
      <url>/2018/04/16/Linux%E5%AD%A6%E4%B9%A0(%E4%B8%89)%E2%80%94%E2%80%94GCC%E3%80%81GDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Linux学习-三-——GCC编程、GDB调试"><a href="#Linux学习-三-——GCC编程、GDB调试" class="headerlink" title="Linux学习(三)——GCC编程、GDB调试"></a>Linux学习(三)——GCC编程、GDB调试</h1><p><img src="https://upload-images.jianshu.io/upload_images/4061843-78c756b6a93472c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GCC使用"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-6088617a6db79a87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="make自动变量"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-15fc87f4e1c5d053.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GDB.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-f12f6829d8b7f4c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514074255.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-fe9bb1150ad468a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514074334.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-34f1741df0b4ec68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20180514074601.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习(二)——shell编程</title>
      <link href="/2018/03/26/Linux%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%E2%80%94%E2%80%94shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/03/26/Linux%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%E2%80%94%E2%80%94shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Linux学习-二-——shell编程"><a href="#Linux学习-二-——shell编程" class="headerlink" title="Linux学习(二)——shell编程"></a>Linux学习(二)——shell编程</h1><p><strong>shell脚本</strong><br>C语言通过调用API系统接口也可实现shell脚本功能</p><p>解释器：Bash、Csh、Ksh</p><p>bash hello  强制使用Bash解释器执行<br>sh hello 软连接，指向一个解释器</p><blockquote><p>shell<br><code>$n    $1 表示第一个参数，$2 表示第二个参数 ...</code><br><code>$#    命令行参数的个数</code><br><code>$0    当前程序的名称</code><br><code>$?    前一个命令或函数的返回码</code><br><code>$*    以“参数1 参数2 ... ” 形式保存所有参数</code><br><code>$@    以“参数1” “参数2” ... 形式保存所有参数</code><br><code>$$    本程序的(进程ID号)PID</code><br><code>$!     上一个命令的PID</code><br>read：读取信息（键盘或者文件）</p></blockquote><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。</p><p>当为[ d ]则是目录<br>当为[ - ]则是文件；<br>若是[ l ]则表示为链接文档(link file)；<br>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；<br>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</p><p>默认是字符串，表达式加空格、expr、let、$(( ))</p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-32d09b434147cbc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-503cad7ba1598907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-8155e0d274b98b15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-b96463388f1fba52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-52ab68a86a39769d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-ddbabbb91d203ec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-d9424622db57bfe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/4061843-0ab3da2608014041.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习笔记</title>
      <link href="/2016/11/01/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/11/01/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a>Markdown学习笔记</h1><p><img src="http://upload-images.jianshu.io/upload_images/4061843-a066d691214d2292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>//单个字符保留一个空格，#越多，字体反而越小，而且只能放在首位</p><h1 id="有序和无序文本"><a href="#有序和无序文本" class="headerlink" title="有序和无序文本"></a>有序和无序文本</h1><p><img src="http://upload-images.jianshu.io/upload_images/4061843-9b5d76816b3e3711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>无序</p><ul><li>文本</li><li>文本</li></ul><p>有序</p><ol><li>文本1</li><li>文本2<br>//有序和无序之间要隔一个空行,否则将以在前的格式显示,空行结束文本显示格式</li></ol><h1 id="链接和图片的写入"><a href="#链接和图片的写入" class="headerlink" title="链接和图片的写入"></a>链接和图片的写入</h1><p><a href="http://www.jianshu.com" target="_blank" rel="noopener">简书</a><br>//链接要紧跟[]，同时注意这些符号是在英文状态下的半角输入</p><p><img src="http://upload-images.jianshu.io/upload_images/4061843-26a41c75417f8196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="http://upload-images.jianshu.io/upload_images/4061843-6bcc90e2e4728a02.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="psbY7HX20PM.jpg"></p><p>#文本引用<br>//注意保留一个空格，同时使用三个*时，便是粗斜体，当使用斜体和粗体相邻时，注意用空格分隔，当使用多个时，要注意个数的匹配和分隔</p><p><img src="http://upload-images.jianshu.io/upload_images/4061843-10a690a20e6d1aea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p><em>一盏灯， 一片昏黄；</em> <strong>一简书</strong>， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 <strong><em>保持淡定， 才能欣赏到最美丽的风景！</em></strong> 保持淡定， 人生从此不再寂寞。</p></blockquote><h1 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h1><p>//代码引用“`”总是成对出现，前后都有，当三个及以上出现时，便是段的引用，需要注意个数的搭配</p><p><img src="http://upload-images.jianshu.io/upload_images/4061843-866d96a07894f819.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><code>Hello world</code><br><code>Good</code><br>`hello world<br> hello world``//个数不匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一段代码</span><br><span class="line">the second</span><br></pre></td></tr></table></figure><p>#表格<br>//“|”左边不能省略，右边可省，左边如果要省略第一个，则下面所有行都要省略，“:”靠近哪边的“|”，表格中的内容偏向哪一边，两边都有时，靠中间，需要与“-”一起用，并且第二行至少有两个“|”，前两个“|”中间不能为空或者其他无意义符号，可以是“-”和“:”</p><p><img src="http://upload-images.jianshu.io/upload_images/4061843-1be5aea0bc67fb07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><table><thead><tr><th align="left">Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td align="left"><em>col 3 is</em></td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td align="left"><strong>col 2 is</strong></td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><table><thead><tr><th align="left">dog</th><th align="center">bird</th><th align="right">cat</th></tr></thead><tbody><tr><td align="left">foo</td><td align="center">foo</td><td align="right">foo</td></tr><tr><td align="left">bar</td><td align="center">bar</td><td align="right">bar</td></tr><tr><td align="left">baz</td><td align="center">baz</td><td align="right">baz</td></tr></tbody></table><h1 id="显示连接中带括号的图片"><a href="#显示连接中带括号的图片" class="headerlink" title="显示连接中带括号的图片"></a>显示连接中带括号的图片</h1><p>//第一个[]显示的是名字，第二个和第二行的[]中的数字必须相同，不论数字为多少</p><p><img src="http://upload-images.jianshu.io/upload_images/4061843-50fb4220c923cd9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="http://latex.codecogs.com/gif.latex?%5Cprod%20%5C(n_%7Bi%7D%5C)+1" alt="**显示括号中的图片**"></p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
